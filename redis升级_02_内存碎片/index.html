

<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title>Redis 内存碎片整理调研 - Nanciico&#39;s Blog</title><meta name="Description" content="分析 Redis 内存碎片整理功能，给出控制内存碎片可行方案。"><meta property="og:title" content="Redis 内存碎片整理调研" />
<meta property="og:description" content="分析 Redis 内存碎片整理功能，给出控制内存碎片可行方案。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Nanciico.github.io/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-19T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-04-19T00:00:00+00:00" /><meta property="og:site_name" content="Nanciico&#39;s Blog" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Redis 内存碎片整理调研"/>
<meta name="twitter:description" content="分析 Redis 内存碎片整理功能，给出控制内存碎片可行方案。"/>
<meta name="application-name" content="DoIt">
<meta name="apple-mobile-web-app-title" content="DoIt">

<meta name="theme-color" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/images/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="https://Nanciico.github.io/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/" /><link rel="prev" href="https://Nanciico.github.io/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/" /><link rel="next" href="https://Nanciico.github.io/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" />
<link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/color.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.css">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.css">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Redis 内存碎片整理调研",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/Nanciico.github.io\/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87\/"
        },"genre": "posts","keywords": "Redis","wordcount":  2468 ,
        "url": "https:\/\/Nanciico.github.io\/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87\/","datePublished": "2023-04-19T00:00:00+00:00","dateModified": "2023-04-19T00:00:00+00:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "Nanciico"
            },"description": "分析 Redis 内存碎片整理功能，给出控制内存碎片可行方案。"
    }
    </script><script src="//instant.page/5.2.0" defer type="module" integrity="sha384-jnZyxPjiipYXnSU0ygqeac2q7CVYMbh84q0uHVRRxEtvFPiQYbXWUorga2aqZJ0z"></script>
</head>

<body header-desktop="auto" header-mobile="auto"><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme); document.documentElement.style.setProperty('color-scheme', theme === 'light' ? 'light' : 'dark'); window.theme = theme;   window.isDark = window.theme !== 'light' }
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('auto' === 'light' || 'auto' === 'dark' || 'auto' === 'black') setTheme('auto'), saveTheme('auto'); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
        window.switchThemeEventSet = new Set()
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Nanciico&#39;s Blog"><span class="header-title-pre">🥳</span><span id="desktop-header-typeit" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/" title="标签"> 标签 </a><a class="menu-item" href="/categories/" title="分类"> 分类 </a><a class="menu-item" href="/series" title="系列"> 系列 </a><a class="menu-item" href="https://github.com/Nanciico" title="GitHub" rel="noopener noreferrer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Nanciico&#39;s Blog"><span class="header-title-pre">🥳</span><span id="mobile-header-typeit" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="标签">标签</a><a class="menu-item" href="/categories/" title="分类">分类</a><a class="menu-item" href="/series" title="系列">系列</a><a class="menu-item" href="https://github.com/Nanciico" title="GitHub" rel="noopener noreferrer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="toc" id="toc-auto">
        <h2 class="toc-title">目录</h2>
        <div class="toc-content" id="toc-content-auto"><nav id="TableOfContents">
  <ul>
    <li><a href="#内存碎片产生原因">内存碎片产生原因</a>
      <ul>
        <li><a href="#内存分配原因">内存分配原因</a></li>
        <li><a href="#频繁修改-redis-中数据">频繁修改 Redis 中数据</a></li>
      </ul>
    </li>
    <li><a href="#内存碎片率">内存碎片率</a></li>
    <li><a href="#内存碎片整理功能默认配置">内存碎片整理功能默认配置</a></li>
    <li><a href="#内存碎片整理的实现">内存碎片整理的实现</a>
      <ul>
        <li><a href="#控制占用-cpu-时间比率限制的实现">控制占用 CPU 时间比率限制的实现</a></li>
        <li><a href="#内存碎片整理核心实现">内存碎片整理核心实现</a></li>
        <li><a href="#内存碎片整理大-key-是否阻塞">内存碎片整理大 Key 是否阻塞</a></li>
      </ul>
    </li>
    <li><a href="#手动内存整理-memory-purge">手动内存整理 Memory Purge</a></li>
    <li><a href="#结论">结论</a></li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav></div>
    </div><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC", "true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Redis 内存碎片整理调研</h1><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><span class="author fas fa-user-circle fa-fw"></span><a href="https://github.com/Nanciico" title="Author" target="_blank" rel="noopener noreferrer author" class="author">Nanciico</a>
                </span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/"><i class="far fa-folder fa-fw"></i>中间件技术</a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/redis-%E5%8D%87%E7%BA%A7/"><i class="far fa-list-alt fa-fw"></i>Redis 升级</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2023-04-19">2023-04-19</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="2023-04-19">2023-04-19</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 2468 字&nbsp;<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 5 分钟&nbsp;</div>
        </div><div class="details series-nav open">
                                <div class="details-summary series-title">
                                    <span>系列 - Redis 升级</span>
                                    <span><i class="details-icon fas fa-angle-right"></i></span>
                                </div>
                                <div class="details-content series-content">
                                    <nav>
                                        <ul>
                                                    <li><a href="/redis%E5%8D%87%E7%BA%A7_00_%E5%BC%80%E7%AF%87/">Redis 升级 —— 前言</a></li>
                                                    <li><a href="/redis%E5%8D%87%E7%BA%A7_01_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/">Redis 异步删除解决大 Key 过期阻塞问题可行性分析</a></li><li><span class="active">Redis 内存碎片整理调研</span></li></ul>
                                    </nav>
                                </div>
                            </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#内存碎片产生原因">内存碎片产生原因</a>
      <ul>
        <li><a href="#内存分配原因">内存分配原因</a></li>
        <li><a href="#频繁修改-redis-中数据">频繁修改 Redis 中数据</a></li>
      </ul>
    </li>
    <li><a href="#内存碎片率">内存碎片率</a></li>
    <li><a href="#内存碎片整理功能默认配置">内存碎片整理功能默认配置</a></li>
    <li><a href="#内存碎片整理的实现">内存碎片整理的实现</a>
      <ul>
        <li><a href="#控制占用-cpu-时间比率限制的实现">控制占用 CPU 时间比率限制的实现</a></li>
        <li><a href="#内存碎片整理核心实现">内存碎片整理核心实现</a></li>
        <li><a href="#内存碎片整理大-key-是否阻塞">内存碎片整理大 Key 是否阻塞</a></li>
      </ul>
    </li>
    <li><a href="#手动内存整理-memory-purge">手动内存整理 Memory Purge</a></li>
    <li><a href="#结论">结论</a></li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><hr>
<h2 id="内存碎片产生原因" class="headerLink">
    <a href="#%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87%e4%ba%a7%e7%94%9f%e5%8e%9f%e5%9b%a0" class="header-mark"></a>1 内存碎片产生原因</h2><p>内存碎片产生有两种原因</p>
<h3 id="内存分配原因" class="headerLink">
    <a href="#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%8e%9f%e5%9b%a0" class="header-mark"></a>1.1 内存分配原因</h3><blockquote>
<p>To store user keys, Redis allocates at most as much memory as the maxmemory setting enables (however there are small extra allocations possible).</p>
</blockquote>
<p>Redis 在分配内存时有可能会分配少量额外空间。</p>
<p>Redis 封装的 zmalloc 方法会调用 ztrymalloc_usable 方法额外分配 PREFIX_SIZE 大小的空间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cm">/* Try allocating memory, and return NULL if failed.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * &#39;*usable&#39; is set to the usable size if non NULL. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">ztrymalloc_usable</span><span class="p">(</span><span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">usable</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Possible overflow, return NULL, so that the caller can panic or handle a failed allocation. */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">SIZE_MAX</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">MALLOC_MIN_SIZE</span><span class="p">(</span><span class="n">size</span><span class="p">)</span><span class="o">+</span><span class="n">PREFIX_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef HAVE_MALLOC_SIZE
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">size</span> <span class="o">=</span> <span class="n">zmalloc_size</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">update_zmalloc_stat_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">usable</span><span class="p">)</span> <span class="o">*</span><span class="n">usable</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="o">*</span><span class="p">((</span><span class="n">size_t</span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">)</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">update_zmalloc_stat_alloc</span><span class="p">(</span><span class="n">size</span><span class="o">+</span><span class="n">PREFIX_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">usable</span><span class="p">)</span> <span class="o">*</span><span class="n">usable</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="o">+</span><span class="n">PREFIX_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其次在默认内存分配器 Jemalloc 下，会按照固定大小分配内存，比如需要申请 6 bytes，但实际分配 8 bytes。</p>
<h3 id="频繁修改-redis-中数据" class="headerLink">
    <a href="#%e9%a2%91%e7%b9%81%e4%bf%ae%e6%94%b9-redis-%e4%b8%ad%e6%95%b0%e6%8d%ae" class="header-mark"></a>1.2 频繁修改 Redis 中数据</h3><blockquote>
<p>Redis will not always free up (return) memory to the OS when keys are removed. This is not something special about Redis, but it is how most malloc() implementations work. For example if you fill an instance with 5GB worth of data, and then remove the equivalent of 2GB of data, the Resident Set Size (also known as the RSS, which is the number of memory pages consumed by the process) will probably still be around 5GB, even if Redis will claim that the user memory is around 3GB. This happens because the underlying allocator can&rsquo;t easily release the memory. For example often most of the removed keys were allocated in the same pages as the other keys that still exist.</p>
</blockquote>
<p>在删除数据时，Redis 不会直接将该部分内存归还操作系统，原因是有可能有其他数据落在相同页上，这部分删除的内存也会产生内存碎片。</p>
<hr>
<h2 id="内存碎片率" class="headerLink">
    <a href="#%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87%e7%8e%87" class="header-mark"></a>2 内存碎片率</h2><p>mem_fragmentation_ratio = used_memory_rss / used_memory</p>
<p>可以理解为 Redis 向操作系统申请的内存与 Redis 实际使用内存的比。</p>
<p>理想情况下内存碎片率维持在 1.03 最好。正常情况下在 1-1.5 之间。</p>
<hr>
<h2 id="内存碎片整理功能默认配置" class="headerLink">
    <a href="#%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87%e6%95%b4%e7%90%86%e5%8a%9f%e8%83%bd%e9%bb%98%e8%ae%a4%e9%85%8d%e7%bd%ae" class="header-mark"></a>3 内存碎片整理功能默认配置</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">activedefrag = 0                        # 内存碎片整理总开关，默认不开启。
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">active-defrag-cycle-min = 1             # 内存碎片整理的 CPU 时间占总 CPU 时间不低于 1%。
</span></span><span class="line"><span class="cl">active-defrag-cycle-max = 25            # 内存碎片整理的 CPU 时间占总 CPU 时间不高于 25%。
</span></span><span class="line"><span class="cl">active-defrag-threshold-lower = 10      # 内存碎片率小于 10%，不进行内存碎片整理。
</span></span><span class="line"><span class="cl">active-defrag-threshold-upper = 100     # 在 100% 碎片率时达到最大的碎片整理力度。
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">active-defrag-max-scan-fields = 1000    # key 中包含的 field 大于 1000 会被单独处理。
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">active-defrag-ignore-bytes = 100mb      # 碎片总空间少于 100mb 不进行内存整理。
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="内存碎片整理的实现" class="headerLink">
    <a href="#%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87%e6%95%b4%e7%90%86%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>4 内存碎片整理的实现</h2><p>内存碎片整理功能通过 activeDefragCycle 函数实现，该函数通过 serverCron 函数调用，在开启该功能后会被定时调用。一次完整的内存碎片整理过程需要多次调用 activeDefragCycle 函数，即会横跨多次定时任务。</p>
<h3 id="控制占用-cpu-时间比率限制的实现" class="headerLink">
    <a href="#%e6%8e%a7%e5%88%b6%e5%8d%a0%e7%94%a8-cpu-%e6%97%b6%e9%97%b4%e6%af%94%e7%8e%87%e9%99%90%e5%88%b6%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>4.1 控制占用 CPU 时间比率限制的实现</h3><p>通过 active-defrag-cycle-min、active-defrag-cycle-max、active-defrag-threshold-lower、active-defrag-threshold-upper 四个配置能够控制内存碎片整理功能占用 CPU 时间的百分比。</p>
<p>该百分比最终会被计算为每次执行 activeDefragCycle 函数的最大时间限制 timeLimit，从而控制每次执行内存碎片整理功能的时间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#define INTERPOLATE(x, x1, x2, y1, y2) ( (y1) + ((x)-(x1)) * ((y2)-(y1)) / ((x2)-(x1)) )
</span></span></span><span class="line"><span class="cl"><span class="cp">#define LIMIT(y, min, max) ((y)&lt;(min)? min: ((y)&gt;(max)? max: (y)))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span> 
</span></span><span class="line"><span class="cl"><span class="cm">/* decide if defrag is needed, and at what CPU effort to invest in it */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">computeDefragCycles</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="n">frag_bytes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获得内存碎片率和内存碎片的总字节数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">frag_pct</span> <span class="o">=</span> <span class="n">getAllocatorFragmentation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frag_bytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* If we&#39;re not already running, and below the threshold, exit. */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果当前未进行内存碎片整理，且内存碎片率和内存碎片总字节数不满足阈值要求，退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">server</span><span class="p">.</span><span class="n">active_defrag_running</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">frag_pct</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">active_defrag_threshold_lower</span> <span class="o">||</span> <span class="n">frag_bytes</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">active_defrag_ignore_bytes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="cm">/* Calculate the adaptive aggressiveness of the defrag */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 自适应计算内存碎片清理的 cpu 占用百分比
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">cpu_pct</span> <span class="o">=</span> <span class="n">INTERPOLATE</span><span class="p">(</span><span class="n">frag_pct</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">server</span><span class="p">.</span><span class="n">active_defrag_threshold_lower</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">server</span><span class="p">.</span><span class="n">active_defrag_threshold_upper</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">server</span><span class="p">.</span><span class="n">active_defrag_cycle_min</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">server</span><span class="p">.</span><span class="n">active_defrag_cycle_max</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将 cpu 占用百分比限制在 [active_defrag_cycle_min, active_defrag_cycle_max]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cpu_pct</span> <span class="o">=</span> <span class="n">LIMIT</span><span class="p">(</span><span class="n">cpu_pct</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">server</span><span class="p">.</span><span class="n">active_defrag_cycle_min</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">server</span><span class="p">.</span><span class="n">active_defrag_cycle_max</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="cm">/* We allow increasing the aggressiveness during a scan, but don&#39;t
</span></span></span><span class="line"><span class="cl"><span class="cm">      * reduce it. */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">cpu_pct</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">active_defrag_running</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 记录比率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">server</span><span class="p">.</span><span class="n">active_defrag_running</span> <span class="o">=</span> <span class="n">cpu_pct</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">serverLog</span><span class="p">(</span><span class="n">LL_VERBOSE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;Starting active defrag, frag=%.0f%%, frag_bytes=%zu, cpu=%d%%&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">frag_pct</span><span class="p">,</span> <span class="n">frag_bytes</span><span class="p">,</span> <span class="n">cpu_pct</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>计算公式： cycle-min + (frag_pct - threshold_lower) * (cycle_max - cycle_min) / (threshold_upper - threshold_lower)。</p>
<p>若当前内存碎片率为 1.5，则计算出来的 cpu_pct = 14。</p>
<p>则 <code>timelimit = 1000000 * server.active_defrag_running / server.hz / 100 = 1000000 * 14 / 10 / 100 = 14,000 μs = 14 ms</code>。</p>
<p>该值计算出来后，会在每 16 次 scan，或每 512 次指针移动，或每 64 个 key 完成内存整理完毕后，判断运行时间是否超过运行时间限制，若超过则退出本次内存整理。</p>
<p>即在内存碎片率为 1.5 时，每次定时任务会花费 14ms 左右时间整理内存碎片。</p>
<h3 id="内存碎片整理核心实现" class="headerLink">
    <a href="#%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87%e6%95%b4%e7%90%86%e6%a0%b8%e5%bf%83%e5%ae%9e%e7%8e%b0" class="header-mark"></a>4.2 内存碎片整理核心实现</h3><p>内存整理功能通过 scan 键空间实现。每次 scan 时会调用 defragScanCallback 回调函数，执行 scan 出来的 key 的内存碎片清理工作。</p>
<p><code>cursor = dictScan(db-&gt;dict, cursor, defragScanCallback, defragDictBucketCallback, db);</code></p>
<p>defragScanCallback 调用 defragKey 函数，先尝试整理 key 对象，再判断 value 对象的编码从而调用相关函数整理 value 对象。</p>
<p>最终都会调用 activeDefragAlloc 函数进行内存整理。内存整理的过程为：分配新内存、内存复制、释放旧内存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cm">/* Defrag helper for generic allocations.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * returns NULL in case the allocation wasn&#39;t moved.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * when it returns a non-null value, the old pointer was already released
</span></span></span><span class="line"><span class="cl"><span class="cm"> * and should NOT be accessed. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="nf">activeDefragAlloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="o">*</span><span class="n">newptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">je_get_defrag_hint</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">server</span><span class="p">.</span><span class="n">stat_active_defrag_misses</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* move this allocation to a new allocation.
</span></span></span><span class="line"><span class="cl"><span class="cm">     * make sure not to use the thread cache. so that we don&#39;t get back the same
</span></span></span><span class="line"><span class="cl"><span class="cm">     * pointers we try to free */</span>
</span></span><span class="line"><span class="cl">    <span class="n">size</span> <span class="o">=</span> <span class="n">zmalloc_size</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 分配新内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">newptr</span> <span class="o">=</span> <span class="n">zmalloc_no_tcache</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 内存复制
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">memcpy</span><span class="p">(</span><span class="n">newptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 释放旧内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">zfree_no_tcache</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">newptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样就完成了单个内存区域的内存整理。</p>
<h3 id="内存碎片整理大-key-是否阻塞" class="headerLink">
    <a href="#%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87%e6%95%b4%e7%90%86%e5%a4%a7-key-%e6%98%af%e5%90%a6%e9%98%bb%e5%a1%9e" class="header-mark"></a>4.3 内存碎片整理大 Key 是否阻塞</h3><p>假设有一大 key 其拥有的元素为 fields 个。</p>
<p>在处理到该 key 时，会比较 fields 与 active-defrag-max-scan-fields 的大小，若 fields &gt; active-defrag-max-scan-fields，则将其标记为大 key 放在一个列表里，并跳过该 key 的内存整理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">dictSize</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">active_defrag_max_scan_fields</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">defragLater</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">kde</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="n">defragged</span> <span class="o">+=</span> <span class="n">activeDefragSdsDict</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">DEFRAG_SDS_DICT_VAL_IS_SDS</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 scan 下一个桶之前，会检查列表里是否有大 key 未完成内存整理，若有则会单独为大 key 进行内存整理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cm">/* before scanning the next bucket, see if we have big keys left from the previous bucket to scan */</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">defragLaterStep</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">endtime</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">quit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* time is up, we didn&#39;t finish all the work */</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span> <span class="cm">/* this will exit the function and we&#39;ll continue on the next cycle */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在整理大 key 的内存时，也会分多次整理。会在每 16 次迭代，或每 512 个指针移动，或每 64 个 field 内存整理完毕后，判断运行时间是否超过运行时间限制，若超过则退出本次内存整理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">quit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">defragLaterItem</span><span class="p">(</span><span class="n">de</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">defrag_later_cursor</span><span class="p">,</span> <span class="n">endtime</span><span class="p">,</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">quit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* time is up, we didn&#39;t finish all the work */</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="cm">/* Once in 16 scan iterations, 512 pointer reallocations, or 64 fields
</span></span></span><span class="line"><span class="cl"><span class="cm">        * (if we have a lot of pointers in one hash bucket, or rehashing),
</span></span></span><span class="line"><span class="cl"><span class="cm">        * check if we reached the time limit. */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">quit</span> <span class="o">||</span> <span class="p">(</span><span class="o">++</span><span class="n">iterations</span> <span class="o">&gt;</span> <span class="mi">16</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">                    <span class="n">server</span><span class="p">.</span><span class="n">stat_active_defrag_hits</span> <span class="o">-</span> <span class="n">prev_defragged</span> <span class="o">&gt;</span> <span class="mi">512</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">                    <span class="n">server</span><span class="p">.</span><span class="n">stat_active_defrag_scanned</span> <span class="o">-</span> <span class="n">prev_scanned</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">quit</span> <span class="o">||</span> <span class="n">ustime</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">endtime</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">key_defragged</span> <span class="o">!=</span> <span class="n">server</span><span class="p">.</span><span class="n">stat_active_defrag_hits</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">server</span><span class="p">.</span><span class="n">stat_active_defrag_key_hits</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">                <span class="n">server</span><span class="p">.</span><span class="n">stat_active_defrag_key_misses</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">prev_defragged</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">stat_active_defrag_hits</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">prev_scanned</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">stat_active_defrag_scanned</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">defrag_later_cursor</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>即一个大 key 的内存整理会分多次处理，不会长时间阻塞主线程。</p>
<hr>
<h2 id="手动内存整理-memory-purge" class="headerLink">
    <a href="#%e6%89%8b%e5%8a%a8%e5%86%85%e5%ad%98%e6%95%b4%e7%90%86-memory-purge" class="header-mark"></a>5 手动内存整理 Memory Purge</h2><p>该命令只在使用 jemalloc 内存分配器下生效。</p>
<p>该命令清理内存脏页，和上述内存碎片整理功能管理的不是相同区域。</p>
<hr>
<h2 id="结论" class="headerLink">
    <a href="#%e7%bb%93%e8%ae%ba" class="header-mark"></a>6 结论</h2><p>Redis 内存碎片整理功能是通过 scan 命令渐进式地整理每次迭代到的 key，每次调用的时间复杂度为 O(1), 完整执行完一次内存碎片整理功能的时间复杂度为 O(n)。</p>
<p>内存碎片整理大 key 会将大 key 分多次处理，不会长时间阻塞主线程。</p>
<p>内存碎片整理功能的核心作用是降低内存碎片率，提高内存利用率以节省内存成本。</p>
<p>但内存整理功能在主线程中执行，会阻塞主线程而降低 Redis 的性能。</p>
<hr>
<h2 id="参考资料" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" class="header-mark"></a>7 参考资料</h2><p><a href="https://redis.io/docs/management/optimization/memory-optimization/" target="_blank" rel="noopener noreferrer">Memory optimization | Redis</a></p>
<p><a href="https://github.com/redis/redis/blob/unstable/src/defrag.c" target="_blank" rel="noopener noreferrer">redis/defrag.c at unstable · redis/redis · GitHub</a></p>
<p><a href="https://redis.io/commands/memory-purge/" target="_blank" rel="noopener noreferrer">MEMORY PURGE | Redis</a></p>
<hr>
</div>

        <div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2023-04-19</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share"><button title="分享到 Twitter" data-sharer="twitter" data-url="https://Nanciico.github.io/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/" data-title="Redis 内存碎片整理调研" data-hashtags="Redis"><span class="fab fa-twitter fa-fw"></span></button><button title="分享到 Facebook" data-sharer="facebook" data-url="https://Nanciico.github.io/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/" data-hashtag="Redis"><span class="fab fa-facebook-square fa-fw"></span></button><button title="分享到 WhatsApp" data-sharer="whatsapp" data-url="https://Nanciico.github.io/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/" data-title="Redis 内存碎片整理调研" data-web><span class="fab fa-whatsapp fa-fw"></span></button><button title="分享到 Line" data-sharer="line" data-url="https://Nanciico.github.io/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/" data-title="Redis 内存碎片整理调研"><span data-svg-src="/lib/simple-icons/icons/line.min.svg"></span></button><button title="分享到 微博" data-sharer="weibo" data-url="https://Nanciico.github.io/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/" data-title="Redis 内存碎片整理调研"><span class="fab fa-weibo fa-fw"></span></button><button title="分享到 Myspace" data-sharer="myspace" data-url="https://Nanciico.github.io/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/" data-title="Redis 内存碎片整理调研" data-description="分析 Redis 内存碎片整理功能，给出控制内存碎片可行方案。"><span data-svg-src="/lib/simple-icons/icons/myspace.min.svg"></span></button><button title="分享到 Blogger" data-sharer="blogger" data-url="https://Nanciico.github.io/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/" data-title="Redis 内存碎片整理调研" data-description="分析 Redis 内存碎片整理功能，给出控制内存碎片可行方案。"><span class="fab fa-blogger fa-fw"></span></button><button title="分享到 Evernote" data-sharer="evernote" data-url="https://Nanciico.github.io/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/" data-title="Redis 内存碎片整理调研"><span class="fab fa-evernote fa-fw"></span></button></div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/redis/">Redis</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/" class="prev" rel="prev" title="算法第四版 —— Union-Find 算法"><i class="fas fa-angle-left fa-fw"></i>算法第四版 —— Union-Find 算法</a>
            <a href="/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="next" rel="next" title="算法第四版 —— 初级排序算法">算法第四版 —— 初级排序算法<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2022 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/Nanciico" target="_blank" rel="noopener noreferrer">Nanciico</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
            <div class="footer-line"></div>
            <div class="footer-line">
            </div>
        </div></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.css"><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/katex/copy-tex.min.css">
        <noscript><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"></noscript><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":20},"comment":{},"data":{"desktop-header-typeit":"Nanciico's Blog~","mobile-header-typeit":"Nanciico's Blog~"},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"distance":100,"findAllMatches":false,"fuseIndexURL":"/index.json","highlightTag":"em","ignoreFieldNorm":false,"ignoreLocation":false,"isCaseSensitive":false,"location":0,"maxResultLength":10,"minMatchCharLength":2,"noResultsFound":"没有找到结果","snippetLength":50,"threshold":0.3,"type":"fuse","useExtendedSearch":false},"sharerjs":true,"table":{"sort":true},"twemoji":true,"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"desktop-header-typeit":["desktop-header-typeit"],"mobile-header-typeit":["mobile-header-typeit"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/lib/tablesort/tablesort.min.js"></script><script type="text/javascript" src="/lib/twemoji/twemoji.min.js" defer></script><script type="text/javascript" src="/js/twemoji.min.js" defer></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/typeit/typeit.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js" defer></script><script type="text/javascript" src="/lib/katex/auto-render.min.js" defer></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js" defer></script><script type="text/javascript" src="/lib/katex/mhchem.min.js" defer></script><script type="text/javascript" src="/js/katex.min.js" defer></script><script type="text/javascript" src="/js/theme.min.js" defer></script></div>
</body>

</html>