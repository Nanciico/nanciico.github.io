[{"categories":["「汇编语言」"],"content":"「汇编语言」基础知识","date":"2023-07-10","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」基础知识","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["「汇编语言」"],"content":"汇编语言是直接在硬件之上工作的编程语言，需要了解硬件系统的结构，才能有效地应用汇编语言对其编程。 ","date":"2023-07-10","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」基础知识","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#"},{"categories":["「汇编语言」"],"content":" 机器语言机器语言是机器指令的集合，每一种微处理器由于硬件设计和内部结构的不同，都有自己的机器指令集。 机器语言由 0、1 表示高低电平，有不易阅读、不易查错、难于辨别和查错等缺点。 ","date":"2023-07-10","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」基础知识","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#机器语言"},{"categories":["「汇编语言」"],"content":" 汇编语言","date":"2023-07-10","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」基础知识","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#汇编语言"},{"categories":["「汇编语言」"],"content":"「汇编语言」阅读开篇","date":"2023-07-09","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」阅读开篇","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/"},{"categories":["「汇编语言」"],"content":" 前言本系列文章记录学习《汇编语言》——王爽 的知识点，为接下来系统学习操作系统打下基础。 ","date":"2023-07-09","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/:1:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」阅读开篇","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/#前言"},{"categories":["「汇编语言」"],"content":" 学习汇编的目的 充分获得底层编程的体验； 深刻理解机器运行程序的机理。 ","date":"2023-07-09","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/:1:1","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」阅读开篇","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/#学习汇编的目的"},{"categories":["「汇编语言」"],"content":" 学习汇编语言的重心通过学习关键指令来深入理解机器工作的基本原理，培养底层编程意识和思想。 ","date":"2023-07-09","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/:1:2","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」阅读开篇","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/#学习汇编语言的重心"},{"categories":["「算法第四版」"],"content":"快速排序","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"categories":["「算法第四版」"],"content":" 快速排序的优点 实现简单，适用于各种不同的输入数据，且在一般应用中比其他排序算法都要快的多； 原地排序，只需要很小的辅助栈的额外空间； 将长度为 N 的数组排序所需的时间和 N * lgN 成正比。 快速排序的缺点是非常脆弱，在实现时要非常小心才能避免低劣的性能。 ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序的优点"},{"categories":["「算法第四版」"],"content":" 快速排序基本算法 public class Quick { /** * Rearranges the array in ascending order, using the natural order. * * @param a the array to be sorted */ public static void sort(Comparable[] a) { StdRandom.shuffle(a); sort(a, 0, a.length - 1); } // quicksort the subarray from a[lo] to a[hi] private static void sort(Comparable[] a, int lo, int hi) { if (hi \u003c= lo) return; int j = partition(a, lo, hi); sort(a, lo, j - 1); sort(a, j + 1, hi); } // partition the subarray a[lo..hi] so that a[lo..j-1] \u003c= a[j] \u003c= a[j+1..hi] // and return the index j. private static int partition(Comparable[] a, int lo, int hi) { int i = lo; int j = hi + 1; Comparable v = a[lo]; while (true) { // find item on lo to swap while (less(a[++i], v)) { if (i == hi) break; } // find item on hi to swap while (less(v, a[--j])) { if (j == lo) break; // redundant since a[lo] acts as sentinel } // check if pointers cross if (i \u003e= j) break; exch(a, i, j); } // put partitioning item v at a[j] exch(a, lo, j); // now, a[lo .. j-1] \u003c= a[j] \u003c= a[j+1 .. hi] return j; } // is v \u003c w ? private static boolean less(Comparable v, Comparable w) { if (v == w) return false; // optimization when reference equals return v.compareTo(w) \u003c 0; } // exchange a[i] and a[j] private static void exch(Object[] a, int i, int j) { Object swap = a[i]; a[i] = a[j]; a[j] = swap; } } 快速排序是一种分治的排序算法。它将一个数组切分成两个子数组，将两部分独立地排序。其与归并排序是互补的。 由于切分过程总是能排定一个元素，用归纳法可以证明递归能够正确地将数组排序：如果左子数组和右子数组都是有序的，那么由左子数组、切分元素和右子数组组成的结果数组也一定是有序的。 ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序基本算法"},{"categories":["「算法第四版」"],"content":" 快速排序的性能特点由于快速排序切分方法的内循环简洁短小，相比归并排序与希尔排序，其内循环中很少移动数据，因此快速排序性能一般比其他的排序算法性能高。 快速排序的另一个特点是比较次数很少，快速排序的最好情况是每次都正好能将数组对半分。 ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序的性能特点"},{"categories":["「算法第四版」"],"content":" 快速排序的算法改进 切换到插入排序。对于小数组，快速排序比插入排序慢。因为快速排序的 sort 递归方法在小数组中也会调用自己。 三取样切分。能够使得快速排序的切分效果更好，但代价是需要计算中位数。同时可以将取样元素放在数组末尾作为“哨兵”来去掉切分方法的边界测试。 熵最优排序。一个元素全部重复的子数组不需要继续排序，但是快速排序的基础算法还会继续将它切分为更小的数组。在含有大量重复元素的数组的情况下，快速排序会使元素全部重复的子数组经常出现，这部分的优化能够将当前线性对数级的性能提高到线性级别。 ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:4:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序的算法改进"},{"categories":["「算法第四版」"],"content":" 快速排序的哨兵 public class QuickSentinel { public static void sort(Comparable[] a) { if (a == null || a.length \u003c 2) return; // 将数组的最大元素放在最右边作为哨兵，除非和相等的元素交换，否则该元素永远不会移动 int maxIndex = 0; for (int i = 1; i \u003c a.length; i++) { if (less(a[maxIndex], a[i])) { maxIndex = i; } } exch(a, maxIndex, a.length - 1); sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { if (lo \u003e= hi) return; int mid = partition(a, lo, hi); sort(a, lo, mid - 1); sort(a, mid + 1, hi); } private static int partition(Comparable[] a, int lo, int hi) { int i = lo, j = hi + 1; Comparable pivot = a[lo]; while (true) { while (less(a[++i], pivot)) { // 切分元素本身就是哨兵 } while (less(pivot, a[--j])) { // 右侧哨兵取消边界检查 } if (i \u003e= j) break; exch(a, i, j); } exch(a, lo, j); return j; } } ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:4:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序的哨兵"},{"categories":["「算法第四版」"],"content":" 快速排序的非递归实现 class QuickNoRecursive { public static void sort(Comparable[] a) { if (a == null || a.length \u003c 2) return; Stack\u003cInteger\u003e stack = new Stack\u003c\u003e(); stack.push(0); stack.push(a.length - 1); sort(a, stack); } // 使用栈来模拟递归栈 private static void sort(Comparable[] a, Stack\u003cInteger\u003e stack) { while (!stack.isEmpty()) { int hi = stack.pop(); int lo = stack.pop(); if (lo \u003e= hi) continue; int mid = partition(a, lo, hi); // 先将较小的子数组压入栈，可以保证栈最多只会有 lgN 个元素 if (hi - mid \u003e mid - lo) { stack.push(mid + 1); stack.push(hi); stack.push(lo); stack.push(mid - 1); } else { stack.push(lo); stack.push(mid - 1); stack.push(mid + 1); stack.push(hi); } } } private static int partition(Comparable[] a, int lo, int hi) { int i = lo; int j = hi + 1; Comparable v = a[lo]; while (true) { while (less(a[++i], v)) { if (i == hi) break; } while (less(v, a[--j])) { if (j == lo) break; } if (i \u003e= j) break; exch(a, i, j); } exch(a, lo, j); return j; } } ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:4:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序的非递归实现"},{"categories":["「算法第四版」"],"content":" 快速排序优化代码的实现 public class Quick { // cutoff to insertion sort, must be \u003e= 1 private static final int INSERTION_SORT_CUTOFF = 8; /** * Rearranges the array in ascending order, using the natural order. * @param a the array to be sorted */ public static void sort(Comparable[] a) { // StdRandom.shuffle(a); sort(a, 0, a.length - 1); } // quicksort the subarray from a[lo] to a[hi] private static void sort(Comparable[] a, int lo, int hi) { if (hi \u003c= lo) return; // cutoff to insertion sort (Insertion.sort() uses half-open intervals) int n = hi - lo + 1; if (n \u003c= INSERTION_SORT_CUTOFF) { Insertion.sort(a, lo, hi + 1); return; } int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); } // partition the subarray a[lo..hi] so that a[lo..j-1] \u003c= a[j] \u003c= a[j+1..hi] // and return the index j. private static int partition(Comparable[] a, int lo, int hi) { int n = hi - lo + 1; int m = median3(a, lo, lo + n/2, hi); // 取样确定切分元素 exch(a, m, lo); int i = lo; int j = hi + 1; Comparable v = a[lo]; // 切分元素为最大、最小的情况，直接返回 // a[lo] is unique largest element while (less(a[++i], v)) { if (i == hi) { exch(a, lo, hi); return hi; } } // a[lo] is unique smallest element while (less(v, a[--j])) { if (j == lo + 1) return lo; } // the main loop while (i \u003c j) { exch(a, i, j); while (less(a[++i], v)) ; while (less(v, a[--j])) ; } // put partitioning item v at a[j] exch(a, lo, j); // now, a[lo .. j-1] \u003c= a[j] \u003c= a[j+1 .. hi] return j; } // return the index of the median element among a[i], a[j], and a[k] private static int median3(Comparable[] a, int i, int j, int k) { return (less(a[i], a[j]) ? (less(a[j], a[k]) ? j : less(a[i], a[k]) ? k : i) : (less(a[k], a[j]) ? j : less(a[k], a[i]) ? k : i)); } // is v \u003c w ? private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u003c 0; } // exchange a[i] and a[j] private static void exch(Object[] a, int i, int j) { Object swap = a[i]; a[i] = a[j]; a[j] = swap; } } 上述代码是对二向切分的快速排序的优化版本： 每次排序抽样三个元素，并以三个元素的中位数作为切分元素，优化切分效果； 使用插入排序提升小数组的排序速度； 对于切分元素 lo 是最大（最小）情况进行优化。 ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:4:3","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序优化代码的实现"},{"categories":["「算法第四版」"],"content":" 三向切分的快速排序三向切分的快速排序适用于大量重复主键的随机数组。通过统计待排序数组的香农信息量，可以得出三向切分的快速排序所需要的比较次数的上下界。 三向切分的快速排序是信息量最优的。因为对于包含大量重复元素的数组，它将排序时间从线性对数级降低到了线性级别。三向切分的最坏情况正是所有主键均不相同。 ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:5:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#三向切分的快速排序"},{"categories":["「算法第四版」"],"content":" Dijkstra 三向切分的快速排序 public class Quick3way { /** * Rearranges the array in ascending order, using the natural order. * * @param a the array to be sorted */ public static void sort(Comparable[] a) { StdRandom.shuffle(a); sort(a, 0, a.length - 1); } // quicksort the subarray a[lo .. hi] using 3-way partitioning private static void sort(Comparable[] a, int lo, int hi) { if (hi \u003c= lo) return; int lt = lo, gt = hi; Comparable v = a[lo]; int i = lo + 1; while (i \u003c= gt) { // 从左到右遍历数组一次 int cmp = a[i].compareTo(v); // 使用 compareTo 比较元素，而非 less 方法 if (cmp \u003c 0) exch(a, lt++, i++); else if (cmp \u003e 0) exch(a, i, gt--); else i++; } // a[lo..lt-1] \u003c v = a[lt..gt] \u003c a[gt+1..hi]. sort(a, lo, lt - 1); sort(a, gt + 1, hi); } } l l l o o o l l t t ( ( v v ) ) l t l t e q ( v ) e q ( i v ) g t g t g g t t ( ( v v ) ) h h h i i i 从左到右遍历数组一次，维护一个指针 lt 使得 a[lo..lt-1] 中的元素都小于 v，一个指针 gt 使得 a[gt+1..hi] 中的元素都大于 v，，一个指针 i 使得 a[lt..i-1] 中的元素都等于 v,a[i..gt] 中的元素都还未确定。 a[i] 小于 v，将 a[lt] 和 a[i] 交换，将 lt 和 i 加一; a[i] 大于 v，将 a[gt] 和 a[i] 交换，将 gt 减一; a[j] 等于 v，将 i 加一。 在数组中重复元素不多的普通情况下它比标准的二分法多使用了很多次交换。J.Bently 和 D.Mcllrov 的快速排序方法，使得三向切分的快速排序比归并排序和其他排序方法在包括重复元素很多的实际应用中更快。 ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:5:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#dijkstra-三向切分的快速排序"},{"categories":["「算法第四版」"],"content":" 快速三向切分（J.Bently, D.Mcllrov） public class QuickBentleyMcIlroy { // cutoff to insertion sort, must be \u003e= 1 private static final int INSERTION_SORT_CUTOFF = 8; // cutoff to median-of-3 partitioning private static final int MEDIAN_OF_3_CUTOFF = 40; /** * Rearranges the array in ascending order, using the natural order. * @param a the array to be sorted */ public static void sort(Comparable[] a) { sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { int n = hi - lo + 1; // cutoff to insertion sort if (n \u003c= INSERTION_SORT_CUTOFF) { insertionSort(a, lo, hi); return; } // use median-of-3 as partitioning element else if (n \u003c= MEDIAN_OF_3_CUTOFF) { int m = median3(a, lo, lo + n/2, hi); exch(a, m, lo); } // use Tukey ninther as partitioning element else { int eps = n/8; int mid = lo + n/2; int m1 = median3(a, lo, lo + eps, lo + eps + eps); int m2 = median3(a, mid - eps, mid, mid + eps); int m3 = median3(a, hi - eps - eps, hi - eps, hi); int ninther = median3(a, m1, m2, m3); exch(a, ninther, lo); } // Bentley-McIlroy 3-way partitioning int i = lo, j = hi+1; int p = lo, q = hi+1; Comparable v = a[lo]; while (true) { while (less(a[++i], v)) if (i == hi) break; while (less(v, a[--j])) if (j == lo) break; // pointers cross if (i == j \u0026\u0026 eq(a[i], v)) exch(a, ++p, i); if (i \u003e= j) break; exch(a, i, j); if (eq(a[i], v)) exch(a, ++p, i); if (eq(a[j], v)) exch(a, --q, j); } i = j + 1; for (int k = lo; k \u003c= p; k++) exch(a, k, j--); for (int k = hi; k \u003e= q; k--) exch(a, k, i++); sort(a, lo, j); sort(a, i, hi); } // sort from a[lo] to a[hi] using insertion sort private static void insertionSort(Comparable[] a, int lo, int hi) { for (int i = lo; i \u003c= hi; i++) for (int j = i; j \u003e lo \u0026\u0026 less(a[j], a[j-1]); j--) exch(a, j, j-1); } // return the index of the median element among a[i], a[j], and a[k] private static int median3(Comparable[] a, int i, int j, int k) { return (less(a[i], a[j]) ? (less(a[j], a[k]) ? j : less(a[i], a[k]) ? k : i) : (less(a[k], a[j]) ? j : less(a[k], a[i]) ? k : i)); } // is v \u003c w ? private static boolean less(Comparable v, Comparable w) { if (v == w) return false; // optimization when reference equal return v.compareTo(w) \u003c 0; } // does v == w ? private static boolean eq(Comparable v, Comparable w) { if (v == w) return true; // optimization when reference equal return v.compareTo(w) == 0; } // exchange a[i] and a[j] private static void exch(Object[] a, int i, int j) { Object swap = a[i]; a[i] = a[j]; a[j] = swap; } } l l l o o o e q ( v ) l t ( v ) p l t ( v j ) i e q ( v ) j g t ( v ) i q g t e ( q v ( ) v ) h h h i i i 上述代码的基本思想是：将重复元素放置于子数组两端的方式实现的信息量最优的排序算法。 使用两个索引 p 和 q，使得 a[lo..p-1] 和 a[q+1..hi] 的元素都和 a[lo] 相等。 使用另外两个索引 i 和 j，使得 a[p..i-1] 小于 a[lo]，a[j+i..q]大于 a[lo]。 在内循环中加入代码，在 a[i] 和 v 相当时将其与 a[p] 交换(并将 p 加 1 )，在 a[j] 和 v 相等且 a[i] 和 a[j] 尚未和 v 进行比较之前将其与 a[q] 交换。 使用 Tukey’s ninther 方法来找出切分元素，选择三组，每组三个元素，分别取三组元素的中位数，然后取三个中位数的中位数作为切分元素，且在排序小数组时切换到插入排序。 ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:5:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速三向切分jbently-dmcllrov"},{"categories":["分布式锁"],"content":"记录在分布式锁开发中的两个编码规范","date":"2023-06-25","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_3_%E4%B8%A4%E4%B8%AA%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"两个编码规范","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_3_%E4%B8%A4%E4%B8%AA%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"categories":["分布式锁"],"content":" 不要生吞异常Unlock 发送请求，如果发生 Socket 异常导致逻辑上解锁但实际上未解锁，是否需要将异常抛出？ 若不处理异常，Redis 中的 Key 会在设定的 30s 后过期，过期后可以将其与解锁看做等效，因此可以不处理异常； 若需要处理异常，则将该异常抛出，用户在使用 Unlock 时需要处理该异常。 原则：不要在代码中假设某种异常不会发生，或者忽略某中异常是无所谓的。 如果不将异常抛出或没有输出到日志，程序在出现莫名其妙的异常后会难以定位问题。因此不要忽略异常。 ","date":"2023-06-25","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_3_%E4%B8%A4%E4%B8%AA%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/:1:0","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"两个编码规范","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_3_%E4%B8%A4%E4%B8%AA%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/#不要生吞异常"},{"categories":["分布式锁"],"content":" 区分“判断”与“校验”在代码中，如果只有满足某种条件才能继续向后执行，应该使用校验。如果对于某个条件需要执行不同的分支，应该使用判断。 不要用判断取代校验，这会导致忽略某些异常。 // 校验，正确的用法 internal void Unlock(string name) { if (!(_lockEntries.TryGetValue(name, out var entry) \u0026\u0026 entry.IsEntered())) { throw new ExitLocalLockException(\"Exit local lock occurs an exception, \" + \"the local lock is missing or the local lock is not held by the current thread. \" + $\"LockName: [{name}]\"); } entry.Exit(); entry.DecRef(); } // 判断，会忽略异常。 internal void Unlock(string name) { if (_lockEntries.TryGetValue(name, out var entry) \u0026\u0026 entry.IsEntered()) { entry.Exit(); entry.DecRef(); } } ","date":"2023-06-25","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_3_%E4%B8%A4%E4%B8%AA%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/:2:0","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"两个编码规范","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_3_%E4%B8%A4%E4%B8%AA%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/#区分判断与校验"},{"categories":["分布式锁"],"content":"针对分布式锁续约设计的阻塞优先队列","date":"2023-06-24","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_2_%E9%98%BB%E5%A1%9E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"阻塞优先队列","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_2_%E9%98%BB%E5%A1%9E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["分布式锁"],"content":" 使用阻塞优先队列的原因续约线程从阻塞优先队列中获取分布式锁对象进行续约。 如果阻塞优先队列为空，线程应该等待阻塞优先队列有数据后再来获取数据； 如果阻塞优先队列不为空，但未到分布式锁的续约时间，则线程需要等待分布式锁能够续约后再来获取数据； 如果阻塞优先队列不为空，且已经到了分布式锁的续约时间，此时线程应从阻塞优先队列中获取数据并进行续约操作。 因此在本场景下，线程有两个时机是需要阻塞的。 ","date":"2023-06-24","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_2_%E9%98%BB%E5%A1%9E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:1:0","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"阻塞优先队列","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_2_%E9%98%BB%E5%A1%9E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#使用阻塞优先队列的原因"},{"categories":["分布式锁"],"content":" 阻塞优先队列的实现 public class LockPriorityBlockingQueue\u003cT\u003e where T : LockBase { private int _capacity; private int _size; private T[] _heap; private readonly object _locker = new object(); public LockPriorityBlockingQueue() { _capacity = 10; _size = 0; _heap = new T[_capacity + 1]; } public void Offer(T item) { Monitor.Enter(_locker); GrowIfNecessary(); try { Insert(item); Monitor.Pulse(_locker); } finally { Monitor.Exit(_locker); } } public T Poll() { Monitor.Enter(_locker); T item; try { var waitTime = Timeout.Infinite; while ((item = Peek()) == null || (waitTime = item.NextRenewTime) \u003e 0) { Monitor.Wait(_locker, waitTime); waitTime = Timeout.Infinite; } item = Delete(); } finally { Monitor.Exit(_locker); } return item; } } 其中 Insert、Delete、Peek 等方法为优先队列的基本操作。 ","date":"2023-06-24","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_2_%E9%98%BB%E5%A1%9E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:0","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"阻塞优先队列","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_2_%E9%98%BB%E5%A1%9E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#阻塞优先队列的实现"},{"categories":["分布式锁"],"content":"使用引用计数算法管理本地锁生命周期。","date":"2023-06-23","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_1_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"引用计数算法","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_1_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"},{"categories":["分布式锁"],"content":" 什么是引用计数 In computer science, reference counting is a programming technique of storing the number of references, pointers, or handles to a resource, such as an object, a block of memory, disk space, and others. In garbage collection algorithms, reference counts may be used to deallocate objects that are no longer needed. 对于一个实现了引用计数的对象，引用计数算法能够跟踪有多少引用处于活动状态。当引用的数量降至 0，我们可以安全的释放该对象的内存。 引用计数也是实现基本的垃圾回收算法的方式。 如果一个对象在多线程环境中需要安全关闭，可以考虑使用引用计数算法。 ","date":"2023-06-23","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_1_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/:1:0","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"引用计数算法","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_1_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/#什么是引用计数"},{"categories":["分布式锁"],"content":" 引用计数算法的实现ElasticSearch 代码中实现了基本的的引用计数算法。 public abstract class AbstractRefCounted implements RefCounted { private final AtomicInteger refCount = new AtomicInteger(1); private final String name; public AbstractRefCounted(String name) { this.name = name; } @Override public final void incRef() { if (tryIncRef() == false) { alreadyClosed(); } } @Override public final boolean tryIncRef() { do { int i = refCount.get(); if (i \u003e 0) { if (refCount.compareAndSet(i, i + 1)) { return true; } } else { return false; } } while (true); } @Override public final boolean decRef() { int i = refCount.decrementAndGet(); assert i \u003e= 0; if (i == 0) { try { closeInternal(); } catch (Exception e) { throw e; } return true; } return false; } protected void alreadyClosed() { throw new IllegalStateException(name + \" is already closed can't increment refCount current count [\" + refCount.get() + \"]\"); } /** * Returns the current reference count. */ public int refCount() { return this.refCount.get(); } /** gets the name of this instance */ public String getName() { return name; } /** * Method that is invoked once the reference count reaches zero. * */ protected abstract void closeInternal(); } ","date":"2023-06-23","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_1_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/:2:0","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"引用计数算法","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_1_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/#引用计数算法的实现"},{"categories":["分布式锁"],"content":" 分布式锁设计中如何使用引用计数在分布式锁的设计中，本地锁生命周期通过引用计数进行管理，保证本地锁的安全关闭。 ","date":"2023-06-23","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_1_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/:3:0","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"引用计数算法","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_1_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/#分布式锁设计中如何使用引用计数"},{"categories":["分布式锁"],"content":" 如何获取本地锁对象 如果能够从字典中获取本地锁对象则直接返回该对象； 如果字典中没有本地锁对象，创建一个本地锁对象并加入到字典中，返回该对象； 如果上述两个操作都失败了，则重试，直到成功获取本地锁对象。 private LockEntry GetLockEntry(string name) { while (true) { if (_lockEntries.TryGetValue(name, out var entry)) { if (entry.TryIncRef()) { return entry; } } var newEntry = new LockEntry(name); if (_lockEntries.TryAdd(name, newEntry)) { return newEntry; } } } ","date":"2023-06-23","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_1_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/:3:1","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"引用计数算法","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_1_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/#如何获取本地锁对象"},{"categories":["分布式锁"],"content":" 如何安全关闭本地锁对象只需要实现 CloseInternal() 方法，在引用计数降至 0 时，从字典中将该对象移除就可以了。 internal class LockEntry : AbstractRefCounted { internal LockEntry(string name) : base(name) { } protected override void CloseInternal() { LocalLockManager.Instance.Remove(Name); } } ","date":"2023-06-23","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_1_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/:3:2","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"引用计数算法","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_1_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/#如何安全关闭本地锁对象"},{"categories":["分布式锁"],"content":"记录基于Redis的分布式锁设计流程。","date":"2023-06-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_0_%E8%AE%BE%E8%AE%A1/","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"Redis分布式锁设计","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_0_%E8%AE%BE%E8%AE%A1/"},{"categories":["分布式锁"],"content":" Redis键值存储设计采用Hash结构作为分布式锁的存储结构。 KEY存储分布式锁名LockName； FIELD存储分布式锁GUID:ThreadId；（每个分布式锁对象会生成一个GUID，ThreadId为Lock操作时当前线程Id。） VALUE存储分布式锁的重入次数。 ","date":"2023-06-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_0_%E8%AE%BE%E8%AE%A1/:1:0","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"Redis分布式锁设计","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_0_%E8%AE%BE%E8%AE%A1/#redis键值存储设计"},{"categories":["分布式锁"],"content":" 请求量优化设计应用尝试获取分布式锁失败时，需要重试争抢锁，直到成功获取分布式锁。在重试争抢分布式锁期间会产生不必要的请求，需要优化这部分请求，降低Redis服务器压力。 在单应用多线程争抢同一把分布式锁锁的场景下，使用本地锁保证该应用在同一时刻只有一个线程重试争抢分布式锁。 flowchart LR A([Start]) --\u003e B(Try to get distributed lock) B --\u003e C{Succeed to get distributed lock?} C --\u003e|Yes| D([End]) C --\u003e|No| F(Try to get local lock) subgraph Retry direction LR F --\u003e G(Try to get distributed lock) G --\u003e H{Succeed to get distributed lock?} H --\u003e|No| G H --\u003e|Yes| I(Release local lock) end I --\u003e D ","date":"2023-06-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_0_%E8%AE%BE%E8%AE%A1/:2:0","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"Redis分布式锁设计","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_0_%E8%AE%BE%E8%AE%A1/#请求量优化设计"},{"categories":["分布式锁"],"content":" 本地锁管理设计使用本地锁管理分布式锁，此时引出了本地锁管理的问题。 所有的本地锁存放在一个 ConcurrentDictionary 中。当线程需要重试以获取分布式锁时，需要先获取本地锁对象（获取不到锁对象则需要创建本地锁对象）并持有本地锁。线程重试获取分布式锁成功后需要释放本地锁，且如果此时没有线程等待本地锁对象，则需要将本地锁对象从字典中删除。 本地锁生命周期通过引用计数进行管理，保证本地锁的安全关闭。 ","date":"2023-06-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_0_%E8%AE%BE%E8%AE%A1/:2:1","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"Redis分布式锁设计","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_0_%E8%AE%BE%E8%AE%A1/#本地锁管理设计"},{"categories":["分布式锁"],"content":" 分布式锁续约设计如果每个成功获取分布式锁的线程都新开一个守护线程进行锁续约，则会导致应用新开大量的线程造成资源浪费。因此需要统一管理需要续约的分布式锁。 分布式锁默认30s过期，每10s续约一次（过期时间的 1/3，这样每个分布式锁能够容忍续约失败一次）。 固定开 2-3 个线程对所有的分布式锁进行续约，使用阻塞优先队列管理需要续约的分布式锁对象。 续约线程从阻塞优先队列获取分布式锁对象； 如果分布式锁对象已经 Unlock，则不续约该锁； 如果分布式锁对象在续约过程中发生异常，放回阻塞优先队列，该分布式锁默认会在10s后再次续约； 如果分布式锁对象续约成功，放回阻塞优先队列，该分布式锁默认会在10s后再次续约； 如果分布式锁对象续约失败且未 Unlock。即在续约时分布式锁不存在，判定分布式锁已经失效。停止续约该分布式锁，并使用Cancel机制通知用户线程分布式锁已失效，用户线程可以调用 RenewFailed 方法判断分布式锁是否失效。 flowchart LR A(Lock) A --\u003e Q[/PriorityBlockingQueue\\] Q --\u003e|Poll| T((Renew Threads)) T --\u003e|Succeed to renew renew occured an exception Offer| Q T --\u003e B(Already unlocked) T --\u003e C(Lock has already lost) ","date":"2023-06-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_0_%E8%AE%BE%E8%AE%A1/:3:0","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"Redis分布式锁设计","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_0_%E8%AE%BE%E8%AE%A1/#分布式锁续约设计"},{"categories":["分布式锁"],"content":" 分布式锁失效场景由于分布式锁使用单点锁实现，并且由于 Redis 本身的局限性，导致有如下锁失效场景： 异步复制：在锁未同步到从节点时主节点宕机，此时客户端认为拿到锁，但主从切换后锁已丢失； 缓存淘汰LRU/LFU有淘汰锁的可能性； 同一把锁连续两次续约失败且期间并未解锁，锁会因过期而导致失效。 其中，异步复制导致的锁失效问题，可以使用 WAIT 命令解决，但本设计不实现。 ","date":"2023-06-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_0_%E8%AE%BE%E8%AE%A1/:4:0","series":["Redis分布式锁"],"tags":["分布式锁"],"title":"Redis分布式锁设计","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_0_%E8%AE%BE%E8%AE%A1/#分布式锁失效场景"},{"categories":["「算法第四版」"],"content":"归并排序","date":"2023-05-21","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」归并排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"categories":["「算法第四版」"],"content":" 自顶向下的归并排序 public class Merge { public static void sort(Comparable[] a) { Comparable[] aux = new Comparable[a.length]; sort(a, aux, 0, a.length - 1); } // mergesort a[lo..hi] using auxiliary array aux[lo..hi] private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) { if (hi \u003c= lo) return; int mid = lo + (hi - lo) / 2; sort(a, aux, lo, mid); sort(a, aux, mid + 1, hi); merge(a, aux, lo, mid, hi); } // stably merge a[lo .. mid] with a[mid+1 ..hi] using aux[lo .. hi] private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) { // copy to aux[] for (int k = lo; k \u003c= hi; k++) { aux[k] = a[k]; } // merge back to a[] int i = lo, j = mid + 1; for (int k = lo; k \u003c= hi; k++) { if (i \u003e mid) a[k] = aux[j++]; else if (j \u003e hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; // to ensure stability else a[k] = aux[i++]; } } } ","date":"2023-05-21","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」归并排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#自顶向下的归并排序"},{"categories":["「算法第四版」"],"content":" 自顶向下归并排序索引 public class Merge { // Returns a permutation that gives the elements in the array in ascending order. public static int[] indexSort(Comparable[] a) { int n = a.length; int[] index = new int[n]; for (int i = 0; i \u003c n; i++) index[i] = i; int[] aux = new int[n]; sort(a, index, aux, 0, n - 1); return index; } // mergesort a[lo..hi] using auxiliary array aux[lo..hi] private static void sort(Comparable[] a, int[] index, int[] aux, int lo, int hi) { if (hi \u003c= lo) return; int mid = lo + (hi - lo) / 2; sort(a, index, aux, lo, mid); sort(a, index, aux, mid + 1, hi); merge(a, index, aux, lo, mid, hi); } // stably merge a[lo .. mid] with a[mid+1 .. hi] using aux[lo .. hi] private static void merge(Comparable[] a, int[] index, int[] aux, int lo, int mid, int hi) { // copy to aux[] for (int k = lo; k \u003c= hi; k++) { aux[k] = index[k]; } // merge back to a[] int i = lo, j = mid + 1; for (int k = lo; k \u003c= hi; k++) { if (i \u003e mid) index[k] = aux[j++]; else if (j \u003e hi) index[k] = aux[i++]; else if (less(a[aux[j]], a[aux[i]])) index[k] = aux[j++]; else index[k] = aux[i++]; } } } ","date":"2023-05-21","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:1:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」归并排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#自顶向下归并排序索引"},{"categories":["「算法第四版」"],"content":" 自顶向下归并排序的优化 对小规模子数组使用插入排序。使用插入排序处理小规模的子数组（比如长度小于 15），一般可以将归并排序的运行时间缩短 10% ~ 15%； 测试数组是否已经有序。添加判断条件若 a[mid] \u003c= a[mid + 1]，则此时数组已经是有序的，可以跳过 merge 方法； 不将元素复制到辅助数组。节省将数组复制到用于归并的辅助数组所用的时间。需要调用两种排序方法，一种将数据从输入数组排序到辅助数组，一种将数组从辅助数组排序到输入数组。在递归调用的每个层次交换输入数组和辅助数组的角色。 public class Merge { private static final int CUTOFF = 7; // cutoff to insertion sort public static void sort(Comparable[] a) { Comparable[] aux = a.clone(); sort(aux, a, 0, a.length - 1); } private static void sort(Comparable[] src, Comparable[] dst, int lo, int hi) { // 1. 对小规模子数组使用插入排序 if (hi \u003c= lo + CUTOFF) { insertionSort(dst, lo, hi); return; } int mid = lo + (hi - lo) / 2; sort(dst, src, lo, mid); // 递归调用的每个层次交换输入数组和辅助数组的角色 sort(dst, src, mid + 1, hi); // sort 方法每次递归的结果为：传入的参数 dst 有序 // 2. 测试数组是否有序以跳过 merge 方法 // using System.arraycopy() is a bit faster than loop if (!less(src[mid + 1], src[mid])) { System.arraycopy(src, lo, dst, lo, hi - lo + 1); return; } merge(src, dst, lo, mid, hi); } private static void merge(Comparable[] src, Comparable[] dst, int lo, int mid, int hi) { // 3. 不将元素复制到辅助数组 int i = lo, j = mid + 1; for (int k = lo; k \u003c= hi; k++) { if (i \u003e mid) dst[k] = src[j++]; else if (j \u003e hi) dst[k] = src[i++]; else if (less(src[j], src[i])) dst[k] = src[j++]; // to ensure stability else dst[k] = src[i++]; } } // sort from a[lo] to a[hi] using insertion sort private static void insertionSort(Comparable[] a, int lo, int hi) { for (int i = lo; i \u003c= hi; i++) for (int j = i; j \u003e lo \u0026\u0026 less(a[j], a[j - 1]); j--) exch(a, j, j - 1); } } ","date":"2023-05-21","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:1:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」归并排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#自顶向下归并排序的优化"},{"categories":["「算法第四版」"],"content":" 自底向上的归并排序","date":"2023-05-21","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」归并排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#自底向上的归并排序"},{"categories":["「算法第四版」"],"content":" 自底向上归并排序数组 public class Merge { public static void sort(Comparable[] a) { int n = a.length; Comparable[] aux = new Comparable[n]; for (int len = 1; len \u003c n; len *= 2) { for (int lo = 0; lo \u003c n - len; lo += len + len) { int mid = lo + len - 1; int hi = Math.min(lo + len + len - 1, n - 1); merge(a, aux, lo, mid, hi); } } } private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) { // copy to aux[] for (int k = lo; k \u003c= hi; k++) { aux[k] = a[k]; } // merge back to a[] int i = lo, j = mid + 1; for (int k = lo; k \u003c= hi; k++) { if (i \u003e mid) a[k] = aux[j++]; // this copying is unnecessary else if (j \u003e hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; } } } ","date":"2023-05-21","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:2:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」归并排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#自底向上归并排序数组"},{"categories":["「算法第四版」"],"content":" 自底向上归并排序链表 class LinkedListNatureMerge { public static void sort(LinkedList\u003cComparable\u003e a) { if (a == null || a.size() \u003c 2) return; LinkedList.Node sentinel = a.new Node(null, a.first); while (true) { LinkedList.Node prev = sentinel; LinkedList.Node lo = prev.next; LinkedList.Node mid = findAscIndex(lo, a.last); if (mid == a.last) break; while (mid != a.last) { LinkedList.Node hi = findAscIndex(mid.next, a.last); prev = merge(prev, lo, mid, hi); if (a.last.next != null) a.last = prev; // 维护链表 last 指针 lo = prev.next; mid = findAscIndex(lo, a.last); } } a.first = sentinel.next; // 维护链表 first 指针 } private static LinkedList.Node merge(LinkedList.Node prev, LinkedList.Node lo, LinkedList.Node mid, LinkedList.Node hi) { LinkedList.Node next = hi.next; LinkedList.Node p1 = lo; LinkedList.Node p2 = mid.next; mid.next = null; hi.next = null; while (p1 != null \u0026\u0026 p2 != null) { if (less(p2.item, p1.item)) { prev.next = p2; p2 = p2.next; } else { prev.next = p1; p1 = p1.next; } prev = prev.next; } if (p1 == null) { prev.next = p2; } else { prev.next = p1; } while (prev.next != null) { prev = prev.next; } prev.next = next; return prev; } private static LinkedList.Node findAscIndex(LinkedList.Node node, LinkedList.Node last) { if (node == null) return last; while (node.next != null) { if (less(node.next.item, node.item)) return node; node = node.next; } return last; } public static boolean isSorted(LinkedList\u003cComparable\u003e a) { LinkedList.Node pointer = a.first; while (pointer.next != null) { if (less(pointer.next.item, pointer.item)) return false; pointer = pointer.next; } return true; } private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u003c 0; } static class LinkedList\u003cItem extends Comparable\u003e { Node first; Node last; private int size; LinkedList() { first = last = null; size = 0; } public void insert(Item item) { if (first == null) { first = last = new Node(item, null); } else { first = new Node(item, first); } size++; } public Item remove() { if (first == null) return null; Node temp = first; if (first == last) { first = last = null; } else { first = first.next; } size--; return temp.item; } public int size() { return size; } class Node { Item item; Node next; Node(Item item, Node next) { this.item = item; this.next = next; } } } } ","date":"2023-05-21","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:2:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」归并排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#自底向上归并排序链表"},{"categories":["「算法第四版」"],"content":" 归并排序的特点归并排序是分治思想的典型应用。 归并排序的算法复杂度： 对于长度为 N 的任意数组，自底向上的归并排序需要 1/2NlgN 至 NlgN次比较，最多访问数组 6NlgN 次； 没有任何基于比较的算法能够保证使用少于 lg(N!) ~ NlgN次比较将长度为 N 的数组排序； 归并排序是一种渐进最优的基于比较排序的算法，归并排序在最坏情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是 ~NlgN。 ","date":"2023-05-21","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」归并排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#归并排序的特点"},{"categories":["「算法第四版」"],"content":"选择排序、插入排序和希尔排序","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["「算法第四版」"],"content":" 排序算法类的模版 public class Sort { public static void sort(Comparable[] a) { // 排序算法具体实现 } private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u003c 0; } private static void exch(Comparable[] a, int i, int j) { Comparable temp = a[i]; a[i] = a[j]; a[j] = temp; } private static void show(Comparable[] a) { for (int i = 0; i \u003c a.length; i++) StdOut.print(a[i] + \" \"); StdOut.println(); } private static boolean isSorted(Comparable[] a) { for (int i = 1; i \u003c a.length; i++) { if (less(a[i], a[i - 1])) return false; } return true; } } ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#排序算法类的模版"},{"categories":["「算法第四版」"],"content":" 选择排序","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#选择排序"},{"categories":["「算法第四版」"],"content":" 选择排序算法描述首先，找到数组中最小的元素，其次，将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。直到将整个数组排序。 ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#选择排序算法描述"},{"categories":["「算法第四版」"],"content":" 选择排序的实现 public class Selection { public static void sort(Comparable[] a) { int n = a.length; for (int i = 0; i \u003c n; i++) { int min = i; for (int j = i + 1; j \u003c n; j++) { if (less(a[j], a[min])) min = j; } exch(a, i, min); assert isSorted(a, 0, i); } assert isSorted(a); } } 算法将第 i 小的元素放到 a[i] 中。数组的第 i 个位置的左边是 i 个最小的元素且它们不会再被访问。 ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#选择排序的实现"},{"categories":["「算法第四版」"],"content":" 选择排序的特点对于长度为 N 的数组，选择排序需要大约 (N^2) / 2 次比较和 N 次交换。 运行时间和输入无关。 数据移动是最少的。数据移动与数组长度线性相关。 ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:3","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#选择排序的特点"},{"categories":["「算法第四版」"],"content":" 插入排序","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#插入排序"},{"categories":["「算法第四版」"],"content":" 插入排序算法描述初始状态，把第一个元素看做只有一个元素的有序序列，从第二个元素开始及其之后的元素是未排序序列。对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#插入排序算法描述"},{"categories":["「算法第四版」"],"content":" 插入排序的实现 public class Insertion { public static void sort(Comparable[] a) { int n = a.length; for (int i = 1; i \u003c n; i++) { for (int j = i; j \u003e 0 \u0026\u0026 less(a[j], a[j - 1]); j--) { exch(a, j, j - 1); } assert isSorted(a, 0, i); } assert isSorted(a); } public static void sort(Comparable[] a, int lo, int hi) { for (int i = lo + 1; i \u003c hi; i++) { for (int j = i; j \u003e lo \u0026\u0026 less(a[j], a[j - 1]); j--) { exch(a, j, j - 1); } } assert isSorted(a, lo, hi); } } 对于 1 到 N - 1 之间的每个 i，将 a[i] 与 a[0] 到 a[i - 1] 中比它小的所有元素依次有序地交换。在索引 i 由左向右变化的过程中，它左侧的元素总是有序的，当 i 到达数组右端时完成排序。 在内循环中将较大的元素都向右移动而不总是交换两个元素，可以大幅提高插入排序的速度。 public class InsertionSortWithoutExchange { public static void sort(Comparable[] a) { int n = a.length; for (int i = 1; i \u003c n; i++) { Comparable value = a[i]; int j; for (j = i; j \u003e 0 \u0026\u0026 less(value, a[j - 1]); j--) { a[j] = a[j - 1]; } a[j] = value; } assert isSorted(a, 0, n - 1); } } 先找出最小的元素并将其置于数组的最左边，这样能够规避判断边界条件 j \u003e 0 从而提高插入排序速度，这个元素被称为哨兵。 public class InsertionWithSentinel { public static void sort(Comparable[] a) { int min = 0; for (int i = 1; i \u003c a.length; i++) if (less(a[i], a[min])) min = i; exch(a, 0, min); for (int i = 2; i \u003c a.length; i++) { for (int j = i; less(j, j - 1); j--) { exch(a, j, j - 1); } } } } ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#插入排序的实现"},{"categories":["「算法第四版」"],"content":" 插入排序的特点对于随机排列的长度为 N 且逐渐不重复的数组，平均情况下插入排序需要 ~(N^2)/4 次比较与交换。最坏情况下需要 ~(N^2)/2 次比较与交换。最好情况下需要 N - 1 次比较和 0 次交换。 插入排序所需时间取决于元素的初始顺序。因此插入排序适合实际应用中部分有序的非随机数组。 插入排序的比较和交换的次数相等。 ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:3","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#插入排序的特点"},{"categories":["「算法第四版」"],"content":" 希尔排序","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#希尔排序"},{"categories":["「算法第四版」"],"content":" 希尔排序算法描述希尔排序是更高效的插入排序。 对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数维的一端移动到另一端。 希尔排序使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 h 有序数组。在进行排序时，如果 h 很大，我们就能将元素移动到很远的地方，为实现更小的 h 有序创造方便。对于任意以 1 结尾的 h 序列，我们都能够将数组排序。这就是希尔排序。 希尔排序比插入排序更高效的原因：排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。 ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#希尔排序算法描述"},{"categories":["「算法第四版」"],"content":" 希尔排序的实现递增序列为 (3^k - 1) / 2 的希尔排序。 public class Shell { public static void sort(Comparable[] a) { int n = a.length; // 3x+1 increment sequence: 1, 4, 13, 40, 121, 364, 1093, ... int h = 1; while (h \u003c n / 3) h = 3 * h + 1; while (h \u003e= 1) { // h-sort the array for (int i = h; i \u003c n; i++) { for (int j = i; j \u003e= h \u0026\u0026 less(a[j], a[j - h]); j -= h) { exch(a, j, j - h); } } assert isHsorted(a, h); h /= 3; } assert isSorted(a); } // is the array h-sorted? private static boolean isHsorted(Comparable[] a, int h) { for (int i = h; i \u003c a.length; i++) if (less(a[i], a[i - h])) return false; return true; } } 也可以将希尔排序的递增序列存储在一个数组中。 class ShellSortKeepIncrementSequence { public static void sort(Comparable[] a) { int n = a.length; int[] incrementSequence = getIncrementSequence(n); for (int h : incrementSequence) { for (int i = h; i \u003c n; i++) { for (int j = i; j \u003e= h \u0026\u0026 less(a[j], a[j - h]); j -= h) { exch(a, j, j - h); } } } } private static int[] getIncrementSequence(int n) { int size = (int) (Math.log(2 * n + 1) / Math.log(3)); int[] incrementSequence = new int[size]; for (int h = 0, i = size - 1; i \u003e= 0; i--) { h = 3 * h + 1; incrementSequence[i] = h; } return incrementSequence; } } 一个更加高效的递增序列为 1，5，19，41, 109，209，505，929，2161，3905，8929，16 001，36 289，64 769，146 305，260 609。该序列通过 9 * (4^k) - 9 * (2^k) + 1 与 (4^k) - 3 * (2^k) + 1 综合得到 。在实际应用中可能可以将性能改进 20% ~ 40%。 class ShellSortHighPerformanceIncrementSequence { public static void sort(Comparable[] a) { int n = a.length; Stack\u003cInteger\u003e incrementSequence = getIncrementSequence(n); while (!incrementSequence.isEmpty()) { int h = incrementSequence.pop(); for (int i = h; i \u003c n; i++) { for (int j = i; j \u003e= h \u0026\u0026 less(a[j], a[j - h]); j -= h) { exch(a, j, j - h); } } } } private static Stack\u003cInteger\u003e getIncrementSequence(int n) { Stack\u003cInteger\u003e sequence = new Stack\u003c\u003e(); int value = -1; int k = 0; while (true) { value = (int) (9 * Math.pow(4, k) - 9 * Math.pow(2, k) + 1); if (value \u003c n) sequence.push(value); value = (int) (Math.pow(4, k + 2) - 3 * Math.pow(2, k + 2) + 1); if (value \u003c n) sequence.push(value); if (value \u003e= n) break; k++; } return sequence; } } ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#希尔排序的实现"},{"categories":["「算法第四版」"],"content":" 希尔排序的特点希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大。 对于中等大小的数组它的运行时间是可以接受的。它的代码量很小，且不需要使用额外的内存空间。 解决一个排序问题时，可以先用希尔排序，然后再考虑是否值得将它替换为更加复杂的排序算法。 ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:3","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#希尔排序的特点"},{"categories":["Redis升级"],"content":"分析 Redis 内存碎片整理功能，给出控制内存碎片可行方案。","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/"},{"categories":["Redis升级"],"content":" 内存碎片产生原因内存碎片产生有两种原因 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:1:0","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#内存碎片产生原因"},{"categories":["Redis升级"],"content":" 内存分配原因 To store user keys, Redis allocates at most as much memory as the maxmemory setting enables (however there are small extra allocations possible). Redis 在分配内存时有可能会分配少量额外空间。 Redis 封装的 zmalloc 方法会调用 ztrymalloc_usable 方法额外分配 PREFIX_SIZE 大小的空间。 /* Try allocating memory, and return NULL if failed. * '*usable' is set to the usable size if non NULL. */ void *ztrymalloc_usable(size_t size, size_t *usable) { /* Possible overflow, return NULL, so that the caller can panic or handle a failed allocation. */ if (size \u003e= SIZE_MAX/2) return NULL; void *ptr = malloc(MALLOC_MIN_SIZE(size)+PREFIX_SIZE); if (!ptr) return NULL; #ifdef HAVE_MALLOC_SIZE size = zmalloc_size(ptr); update_zmalloc_stat_alloc(size); if (usable) *usable = size; return ptr; #else *((size_t*)ptr) = size; update_zmalloc_stat_alloc(size+PREFIX_SIZE); if (usable) *usable = size; return (char*)ptr+PREFIX_SIZE; #endif } 其次在默认内存分配器 Jemalloc 下，会按照固定大小分配内存，比如需要申请 6 bytes，但实际分配 8 bytes。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:1:1","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#内存分配原因"},{"categories":["Redis升级"],"content":" 频繁修改 Redis 中数据 Redis will not always free up (return) memory to the OS when keys are removed. This is not something special about Redis, but it is how most malloc() implementations work. For example if you fill an instance with 5GB worth of data, and then remove the equivalent of 2GB of data, the Resident Set Size (also known as the RSS, which is the number of memory pages consumed by the process) will probably still be around 5GB, even if Redis will claim that the user memory is around 3GB. This happens because the underlying allocator can’t easily release the memory. For example often most of the removed keys were allocated in the same pages as the other keys that still exist. 在删除数据时，Redis 不会直接将该部分内存归还操作系统，原因是有可能有其他数据落在相同页上，这部分删除的内存也会产生内存碎片。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:1:2","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#频繁修改-redis-中数据"},{"categories":["Redis升级"],"content":" 内存碎片率mem_fragmentation_ratio = used_memory_rss / used_memory 可以理解为 Redis 向操作系统申请的内存与 Redis 实际使用内存的比。 理想情况下内存碎片率维持在 1.03 最好。正常情况下在 1-1.5 之间。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:2:0","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#内存碎片率"},{"categories":["Redis升级"],"content":" 内存碎片整理功能默认配置 activedefrag = 0 # 内存碎片整理总开关，默认不开启。 active-defrag-cycle-min = 1 # 内存碎片整理的 CPU 时间占总 CPU 时间不低于 1%。 active-defrag-cycle-max = 25 # 内存碎片整理的 CPU 时间占总 CPU 时间不高于 25%。 active-defrag-threshold-lower = 10 # 内存碎片率小于 10%，不进行内存碎片整理。 active-defrag-threshold-upper = 100 # 在 100% 碎片率时达到最大的碎片整理力度。 active-defrag-max-scan-fields = 1000 # key 中包含的 field 大于 1000 会被单独处理。 active-defrag-ignore-bytes = 100mb # 碎片总空间少于 100mb 不进行内存整理。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:3:0","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#内存碎片整理功能默认配置"},{"categories":["Redis升级"],"content":" 内存碎片整理的实现内存碎片整理功能通过 activeDefragCycle 函数实现，该函数通过 serverCron 函数调用，在开启该功能后会被定时调用。一次完整的内存碎片整理过程需要多次调用 activeDefragCycle 函数，即会横跨多次定时任务。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:4:0","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#内存碎片整理的实现"},{"categories":["Redis升级"],"content":" 控制占用 CPU 时间比率限制的实现通过 active-defrag-cycle-min、active-defrag-cycle-max、active-defrag-threshold-lower、active-defrag-threshold-upper 四个配置能够控制内存碎片整理功能占用 CPU 时间的百分比。 该百分比最终会被计算为每次执行 activeDefragCycle 函数的最大时间限制 timeLimit，从而控制每次执行内存碎片整理功能的时间。 #define INTERPOLATE(x, x1, x2, y1, y2) ( (y1) + ((x)-(x1)) * ((y2)-(y1)) / ((x2)-(x1)) ) #define LIMIT(y, min, max) ((y)\u003c(min)? min: ((y)\u003e(max)? max: (y))) /* decide if defrag is needed, and at what CPU effort to invest in it */ void computeDefragCycles() { size_t frag_bytes; // 获得内存碎片率和内存碎片的总字节数 float frag_pct = getAllocatorFragmentation(\u0026frag_bytes); /* If we're not already running, and below the threshold, exit. */ // 如果当前未进行内存碎片整理，且内存碎片率和内存碎片总字节数不满足阈值要求，退出 if (!server.active_defrag_running) { if(frag_pct \u003c server.active_defrag_threshold_lower || frag_bytes \u003c server.active_defrag_ignore_bytes) return; } /* Calculate the adaptive aggressiveness of the defrag */ // 自适应计算内存碎片清理的 cpu 占用百分比 int cpu_pct = INTERPOLATE(frag_pct, server.active_defrag_threshold_lower, server.active_defrag_threshold_upper, server.active_defrag_cycle_min, server.active_defrag_cycle_max); // 将 cpu 占用百分比限制在 [active_defrag_cycle_min, active_defrag_cycle_max] cpu_pct = LIMIT(cpu_pct, server.active_defrag_cycle_min, server.active_defrag_cycle_max); /* We allow increasing the aggressiveness during a scan, but don't * reduce it. */ if (cpu_pct \u003e server.active_defrag_running) { // 记录比率 server.active_defrag_running = cpu_pct; serverLog(LL_VERBOSE, \"Starting active defrag, frag=%.0f%%, frag_bytes=%zu, cpu=%d%%\", frag_pct, frag_bytes, cpu_pct); } } 计算公式： cycle-min + (frag_pct - threshold_lower) * (cycle_max - cycle_min) / (threshold_upper - threshold_lower)。 若当前内存碎片率为 1.5，则计算出来的 cpu_pct = 14。 则 timelimit = 1000000 * server.active_defrag_running / server.hz / 100 = 1000000 * 14 / 10 / 100 = 14,000 μs = 14 ms。 该值计算出来后，会在每 16 次 scan，或每 512 次指针移动，或每 64 个 key 完成内存整理完毕后，判断运行时间是否超过运行时间限制，若超过则退出本次内存整理。 即在内存碎片率为 1.5 时，每次定时任务会花费 14ms 左右时间整理内存碎片。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:4:1","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#控制占用-cpu-时间比率限制的实现"},{"categories":["Redis升级"],"content":" 内存碎片整理核心实现内存整理功能通过 scan 键空间实现。每次 scan 时会调用 defragScanCallback 回调函数，执行 scan 出来的 key 的内存碎片清理工作。 cursor = dictScan(db-\u003edict, cursor, defragScanCallback, defragDictBucketCallback, db); defragScanCallback 调用 defragKey 函数，先尝试整理 key 对象，再判断 value 对象的编码从而调用相关函数整理 value 对象。 最终都会调用 activeDefragAlloc 函数进行内存整理。内存整理的过程为：分配新内存、内存复制、释放旧内存。 /* Defrag helper for generic allocations. * * returns NULL in case the allocation wasn't moved. * when it returns a non-null value, the old pointer was already released * and should NOT be accessed. */ void* activeDefragAlloc(void *ptr) { size_t size; void *newptr; if(!je_get_defrag_hint(ptr)) { server.stat_active_defrag_misses++; return NULL; } /* move this allocation to a new allocation. * make sure not to use the thread cache. so that we don't get back the same * pointers we try to free */ size = zmalloc_size(ptr); // 分配新内存 newptr = zmalloc_no_tcache(size); // 内存复制 memcpy(newptr, ptr, size); // 释放旧内存 zfree_no_tcache(ptr); return newptr; } 这样就完成了单个内存区域的内存整理。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:4:2","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#内存碎片整理核心实现"},{"categories":["Redis升级"],"content":" 内存碎片整理大 Key 是否阻塞假设有一大 key 其拥有的元素为 fields 个。 在处理到该 key 时，会比较 fields 与 active-defrag-max-scan-fields 的大小，若 fields \u003e active-defrag-max-scan-fields，则将其标记为大 key 放在一个列表里，并跳过该 key 的内存整理。 if (dictSize(d) \u003e server.active_defrag_max_scan_fields) defragLater(db, kde); else defragged += activeDefragSdsDict(d, DEFRAG_SDS_DICT_VAL_IS_SDS); 在 scan 下一个桶之前，会检查列表里是否有大 key 未完成内存整理，若有则会单独为大 key 进行内存整理。 /* before scanning the next bucket, see if we have big keys left from the previous bucket to scan */ if (defragLaterStep(db, endtime)) { quit = 1; /* time is up, we didn't finish all the work */ break; /* this will exit the function and we'll continue on the next cycle */ } 在整理大 key 的内存时，也会分多次整理。会在每 16 次迭代，或每 512 个指针移动，或每 64 个 field 内存整理完毕后，判断运行时间是否超过运行时间限制，若超过则退出本次内存整理。 do { int quit = 0; if (defragLaterItem(de, \u0026defrag_later_cursor, endtime,db-\u003eid)) quit = 1; /* time is up, we didn't finish all the work */ /* Once in 16 scan iterations, 512 pointer reallocations, or 64 fields * (if we have a lot of pointers in one hash bucket, or rehashing), * check if we reached the time limit. */ if (quit || (++iterations \u003e 16 || server.stat_active_defrag_hits - prev_defragged \u003e 512 || server.stat_active_defrag_scanned - prev_scanned \u003e 64)) { if (quit || ustime() \u003e endtime) { if(key_defragged != server.stat_active_defrag_hits) server.stat_active_defrag_key_hits++; else server.stat_active_defrag_key_misses++; return 1; } iterations = 0; prev_defragged = server.stat_active_defrag_hits; prev_scanned = server.stat_active_defrag_scanned; } } while(defrag_later_cursor); 即一个大 key 的内存整理会分多次处理，不会长时间阻塞主线程。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:4:3","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#内存碎片整理大-key-是否阻塞"},{"categories":["Redis升级"],"content":" 手动内存整理 Memory Purge该命令只在使用 jemalloc 内存分配器下生效。 该命令清理内存脏页，和上述内存碎片整理功能管理的不是相同区域。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:5:0","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#手动内存整理-memory-purge"},{"categories":["Redis升级"],"content":" 结论Redis 内存碎片整理功能是通过 scan 命令渐进式地整理每次迭代到的 key，每次调用的时间复杂度为 O(1), 完整执行完一次内存碎片整理功能的时间复杂度为 O(n)。 内存碎片整理大 key 会将大 key 分多次处理，不会长时间阻塞主线程。 内存碎片整理功能的核心作用是降低内存碎片率，提高内存利用率以节省内存成本。 但内存整理功能在主线程中执行，会阻塞主线程而降低 Redis 的性能。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:6:0","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#结论"},{"categories":["Redis升级"],"content":" 参考资料Memory optimization | Redis redis/defrag.c at unstable · redis/redis · GitHub MEMORY PURGE | Redis ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:7:0","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_2_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#参考资料"},{"categories":["「算法第四版」"],"content":"「算法第四版」Union-Find 算法","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/"},{"categories":["「算法第四版」"],"content":" 动态连通性问题及其应用若整数对 (p, q) 是“相连”的，则： 自反性：p 和 p 是相连的； 对称性：如果 p 和 q 是相连的，那么 q 和 p 也是相连的； 传递性：如果 p 和 q 是相连的且 q 和 r 是相连的，那么 p 和 r 也是相连的。 当且仅当两个对象相连时它们才属于同一个等价类。 判断一对新的对象是否“相连”，这样的问题叫动态连通性问题。 ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#动态连通性问题及其应用"},{"categories":["「算法第四版」"],"content":" 网络在大型计算机网络中，输入的整数表示主机(触点)，整数对表示网络(连接)，同一网络中的主机属于同一等价类(连通分量)。 在社交网络中，整数可以表示社交网络中的人，整数对表示朋友关系。 ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:1:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#网络"},{"categories":["「算法第四版」"],"content":" 数学集合将每个整数看做属于不同的数学集合，每一个整数对则需要先判断是否在同一数学集合中。若不是，则将 p 所属集合与 q 所属集合归并到同一集合。 ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:1:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#数学集合"},{"categories":["「算法第四版」"],"content":" Union-Find 算法的 API public class UF UF(int N) 以整数标志 [0, N-1] 初始化 N 个触点 void union(int p, int q) 在 p 和 q 之间添加一条连接 int find(int p) p (0 \u003c= p \u003c= N-1) 所在的分量标识符 boolean connected(int p, int q) p 和 q 是否连通 int count() 连通分量的数量 ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#union-find-算法的-api"},{"categories":["「算法第四版」"],"content":" Union-Find 算法的实现基本的 UF 算法实现见如下代码，union 与 find 的详细实现分别见 Quick-Find，Quick-Union，Weighted Quick-Union，Quick-Union with Path Compresson 的实现。 public class UF { private int[] id; private int count; public UF(int n) { count = n; id = new int[n]; for (int i = 0; i \u003c n; i++) id[i] = i; } public void union(int p, int q); public int find(int p); public boolean connected(int p, int q) { return find(p) == find(q); } public int count() { return count; } private void validate(int p) { int n = id.length; if (p \u003c 0 || p \u003e= n) { throw new IllegalArgumentException(\"index \" + p + \" is not between 0 and \" + (n-1)); } } public static void main(String[] args) { int n = StdIn.readInt(); UF uf = new UF(n); while (!StdIn.isEmpty()) { int p = StdIn.readInt(); int q = StdIn.readInt(); if (uf.find(p) == uf.find(q)) continue; uf.union(p, q); StdOut.println(p + \" \" + q); } StdOut.println(uf.count() + \" components\"); } } ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#union-find-算法的实现"},{"categories":["「算法第四版」"],"content":" Quick-Find public class QuickFindUF { private int[] id; // id[i] = component identifier of i private int count; // number of components public QuickFindUF(int n) { count = n; id = new int[n]; for (int i = 0; i \u003c n; i++) id[i] = i; } public void union(int p, int q) { validate(p); validate(q); int pID = id[p]; // needed for correctness int qID = id[q]; // to reduce the number of array accesses // p and q are already in the same component if (pID == qID) return; for (int i = 0; i \u003c id.length; i++) if (id[i] == pID) id[i] = qID; count--; } public int find(int p) { validate(p); return id[p]; } } Quick-Find 算法中，find 方法的时间复杂度为 O(1)，但 union 方法的时间复杂度为 O(n)。 ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:3:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#quick-find"},{"categories":["「算法第四版」"],"content":" Quick-Union public class QuickUnionUF { private int[] parent; // parent[i] = parent of i private int count; // number of components public QuickUnionUF(int n) { parent = new int[n]; count = n; for (int i = 0; i \u003c n; i++) { parent[i] = i; } } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootP] = rootQ; count--; } public int find(int p) { validate(p); while (p != parent[p]) p = parent[p]; return p; } } Quick-Union 算法中，h 表示树的高度，find 方法的时间复杂度为 O(h)，union 方法的时间复杂度为 2·O(h) + 1 = O(h)。 ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:3:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#quick-union"},{"categories":["「算法第四版」"],"content":" Weighted Quick-Union public class WeightedQuickUnionUF { private int[] parent; // parent[i] = parent of i private int[] size; // size[i] = number of elements in subtree rooted at i private int count; // number of components public WeightedQuickUnionUF(int n) { count = n; parent = new int[n]; size = new int[n]; for (int i = 0; i \u003c n; i++) { parent[i] = i; size[i] = 1; } } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; // make smaller root point to larger one if (size[rootP] \u003c size[rootQ]) { parent[rootP] = rootQ; size[rootQ] += size[rootP]; } else { parent[rootQ] = rootP; size[rootP] += size[rootQ]; } count--; } public int find(int p) { validate(p); while (p != parent[p]) p = parent[p]; return p; } } 加权 Quick-Union 算法在最坏情况下，即归并的两个树大小总是相等，此时能够保证对数级别的性能 O(logN)。 加权 Quick-Union 算法能够在合理时间范围内处理大规模动态连通性问题。 ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:3:3","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#weighted-quick-union"},{"categories":["「算法第四版」"],"content":" Weighted Quick-Union with Path Compresson public class WeightedQuickUnionWithPathCompression { private final int[] parent; private final int[] size; private int count; WeightedQuickUnionWithPathCompression(int n) { parent = new int[n]; size = new int[n]; for (int i = 0; i \u003c n; i++) { parent[i] = i; size[i] = 1; } count = n; } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; if (size[rootP] \u003c size[rootQ]) { parent[rootP] = rootQ; size[rootQ] += size[rootP]; } else { parent[rootQ] = rootP; size[rootP] += size[rootQ]; } count--; } public int find(int p) { validate(p); int root = p; while (root != parent[root]) { root = parent[root]; } // Path Compression while (parent[p] != root) { int temp = parent[p]; parent[p] = root; p = temp; } return root; } } 路经压缩的加权 Quick-Union 算法，find 方法能够得到几乎完全扁平化的树，使得算法的均摊成本接近 O(1)。 路经压缩的加权 Quick-Union 算法是本题的最优算法。 ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:3:4","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#weighted-quick-union-with-path-compresson"},{"categories":null,"content":"整理记录 Shell Script 语法","date":"2023-04-14","objectID":"/shell-script-%E6%95%B4%E7%90%86/","series":null,"tags":null,"title":"Shell Script 整理","uri":"/shell-script-%E6%95%B4%E7%90%86/"},{"categories":null,"content":" Shell 参数处理特殊字符 #!/bin/bash echo \"Starting program at $(date)\" # 1. $( CMD ) 运行 CMD 命令 echo \"Running program $0 with $# arguments with pid $$\" # 2. 见特殊字符表 for file in \"$@\"; do # 3. 见特殊字符表 grep foobar \"$file\" \u003e /dev/null 2\u003e /dev/null # 4. \"2\u003e /dev/null\" 把标准错误重定向到/dev/null if [[ $? -ne 0 ]]; then # 5. 见特殊字符表；在比较操作中使用双中括号 echo \"File $file does not have any foobar, adding one\" echo \"# foobar\" \u003e\u003e \"$file\" fi done ","date":"2023-04-14","objectID":"/shell-script-%E6%95%B4%E7%90%86/:1:0","series":null,"tags":null,"title":"Shell Script 整理","uri":"/shell-script-%E6%95%B4%E7%90%86/#shell-参数处理特殊字符"},{"categories":null,"content":" 特殊字符表 参数处理 说明 $0 Shell Script 名字 $# 参数个数 $$ 进程 PID $@ 所有参数 $? 上一条命令的返回码 ","date":"2023-04-14","objectID":"/shell-script-%E6%95%B4%E7%90%86/:1:1","series":null,"tags":null,"title":"Shell Script 整理","uri":"/shell-script-%E6%95%B4%E7%90%86/#特殊字符表"},{"categories":null,"content":" Test 命令的双中括号Differences Between Single and Double Brackets in Bash. ","date":"2023-04-14","objectID":"/shell-script-%E6%95%B4%E7%90%86/:1:2","series":null,"tags":null,"title":"Shell Script 整理","uri":"/shell-script-%E6%95%B4%E7%90%86/#test-命令的双中括号"},{"categories":null,"content":" Safe-bgsave 脚本整理 #!/bin/bash function help() # 1. 函数声明 { echo \"usage: safe-bgsave -t THRESHOLD -i INTERVAL -p PORT.\" echo \" safe-bgsave -t 20 -i 1 -p 7002\" exit } # success return 0; fail return 1. function safe_bgsave() { # check security local available=`free -g | grep Mem | awk '{print $7}'` # 2. awk 选取第 7 列 if [ ${available} -le ${THRESHOLD} ] then echo `date` \" Available memory: ${available} \u003c= threshold: ${THRESHOLD}. Do not process bgsave.\" \u003e\u003e ${LOG_PATH} 2\u003e\u00261 return 1 fi # bgsave local bgsave=`${REDIS_CLI} -p ${PORT} bgsave` echo `date` \" ${bgsave}.\" \u003e\u003e ${LOG_PATH} 2\u003e\u00261 # 3. 字符串拼接；\"2\u003e\u00261\" 将标准错误重定向到标准输出 sleep ${INTERVAL} local pid=`ps -ef | grep \"${PROCESS_NAME}\" | grep -v grep | awk '{print $2}'` while [ -n \"${pid}\" ] do available=`free -g | grep Mem | awk '{print $7}'` if [ ${available} -le ${THRESHOLD} ] then echo `date` \" bgsave failed. Available memory: ${available} \u003c= threshold: ${THRESHOLD}. Trying to kill process.\" \u003e\u003e ${LOG_PATH} 2\u003e\u00261 kill \"${pid}\" return 1 fi sleep ${INTERVAL} pid=`ps -ef | grep \"${PROCESS_NAME}\" | grep -v grep | awk '{print $2}'` done echo `date` \" bgsave success.\" \u003e\u003e ${LOG_PATH} 2\u003e\u00261 return 0 } # Begin [ $# -ne 6 ] \u0026\u0026 help # 4. 检查参数个数；调用 help 函数 while [ -n \"$1\" ] # 5. 参数赋值的写法 do case \"$1\" in -t) THRESHOLD=$2 shift 2 # 6. 将参数数组向左移动两位 ;; -i) INTERVAL=$2 shift 2 ;; -p) PORT=$2 shift 2 ;; *) help ;; esac done REDIS_CLI=\"redis-cli\" PROCESS_NAME=\"redis-rdb-bgsave\" LOG_PATH=\"/opt/data/redis/safe_bgsave.${PORT}.log\" safe_bgsave if [ $? -eq 1 ] then exit 1 fi exit 0 ","date":"2023-04-14","objectID":"/shell-script-%E6%95%B4%E7%90%86/:2:0","series":null,"tags":null,"title":"Shell Script 整理","uri":"/shell-script-%E6%95%B4%E7%90%86/#safe-bgsave-脚本整理"},{"categories":["「算法第四版」"],"content":"「算法第四版」算法分析","date":"2023-04-12","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」算法分析","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"},{"categories":["「算法第四版」"],"content":" 算法分析的方法 Observe some feature of the natural world, generally with precise measurements. Hypothesize a model that is consistent with the observations. Predict events using the hypothesis. Verify the predictions by making further observations. Validate by repeating until the hypothesis and observations agree. ","date":"2023-04-12","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」算法分析","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#算法分析的方法"},{"categories":["「算法第四版」"],"content":" 算法运行时间实验程序执行速度的快慢通常取决于问题的规模。 通过观察代码初步预测程序的执行时间。 使用类似 DoublingTest 方法不断增加问题规模并计时，进入“预测——验证”循环。 public class DoublingTest { public static double timeTrial(int N) { // Time ThreeSum.count() for N random 6-digit ints. int MAX = 1000000; int[] a = new int[N]; for (int i = 0; i \u003c N; i++) a[i] = StdRandom.uniformInt(-MAX, MAX); Stopwatch timer = new Stopwatch(); int cnt = ThreeSum.count(a); return timer.elapsedTime(); } public static void main(String[] args) { // Print table of running times. for (int N = 250; true; N += N) { // Print time for problem size N. double time = timeTrial(N); StdOut.printf(\"%7d %5.1f\\n\", N, time); } } } 分析实验数据，得到其运行时间的数学模型。 ","date":"2023-04-12","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」算法分析","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#算法运行时间实验"},{"categories":["「算法第四版」"],"content":" 运行时间的数学模型得到运行时间的数学模型步骤：（书：P114） 确定输入模型，定义问题规模 识别内循环 根据内循环中的操作确定成本模型 对于给定的输入，判断这些操作的执行频率 ","date":"2023-04-12","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」算法分析","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#运行时间的数学模型"},{"categories":["「算法第四版」"],"content":" 增长数量级 描述 增长的数量级 典型代码 说明 举例 常数级别 1 a = b + c 普通语句 两个数相加 对数级别 logN 二分查找 二分策略 二分查找 线性级别 N 循环 循环 循环查找最大元素 线性对数级别 NlogN 归并排序 Merge.sort 和 快速排序 Quick.sort 归并排序，快速排序 归并排序，快速排序 平方级别 N^2 选择排序 Selection.sort 和 插入排序 Insertion.sort 双层循环 选择排序，插入排序 立方级别 N^3 ThreeSum 三层循环 三层循环 三层循环 指数级别 2^N 第六章 穷举查找 检查所有子集 ","date":"2023-04-12","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」算法分析","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#增长数量级"},{"categories":["「算法第四版」"],"content":" 倍率实验通过倍率实验能够简单有效地预测任意程序的性能并判断它们运行时间大致的增长数量级，但对比值没有极限的算法无效。 public class DoublingRatio { public static double timeTrial(int N) { // Time ThreeSum.count() for N random 6-digit ints. int MAX = 1000000; int[] a = new int[N]; for (int i = 0; i \u003c N; i++) a[i] = StdRandom.uniformInt(-MAX, MAX); Stopwatch timer = new Stopwatch(); int cnt = ThreeSum.count(a); return timer.elapsedTime(); } public static void main(String[] args) { double prev = timeTrial(125); for (int N = 250; true; N += N) { double time = timeTrial(N); StdOut.printf(\"%6d %7.1f \", N, time); StdOut.printf(\"%5.1f\\n\", time / prev); prev = time; } } } 在有性能问题的情况家应该考虑对编写过的所有程序进行倍率实验，以便能找到性能问题。 ","date":"2023-04-12","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」算法分析","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#倍率实验"},{"categories":["「算法第四版」"],"content":"「算法第四版」背包、队列和栈","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/"},{"categories":["「算法第四版」"],"content":" 背包背包 API： 背包 public class Bag\u003cItem\u003e implements Iterable\u003cItem\u003e Bag() 创建一个背包 void add(Item item) 添加一个元素 boolean isEmpty() 背包是否为空 int size() 背包中元素数量 背包是一种不支持从中删除元素的集合数据类型——他的目的是帮助用例收集元素并迭代遍历所有收集到的元素。 ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#背包"},{"categories":["「算法第四版」"],"content":" 背包的链表实现 import java.util.Iterator; public class Bag\u003cItem\u003e implements Iterable\u003cItem\u003e { private Node first; private class Node { Item item; Node next; } public void add(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; } @Override public Iterator\u003cItem\u003e iterator() { return new ListIterator(); } private class ListIterator implements Iterator\u003cItem\u003e { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:1:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#背包的链表实现"},{"categories":["「算法第四版」"],"content":" 先进先出（FIFO）队列队列 API： 先进先出（FIFO）队列 public class Queue\u003cItem\u003e implements Interable\u003cItem\u003e Queue() 创建空队列 void enqueue(Item item) 添加一个元素 Item dequeue() 删除最早添加的元素 boolean isEmpty() 队列是否为空 int size() 队列中的元素数量 先进先出队列是一种基于先进先出（FIFO）策略的集合类型。 ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#先进先出fifo队列"},{"categories":["「算法第四版」"],"content":" 队列的实现 队列的链表实现 import java.util.Iterator; public class Queue\u003cItem\u003e implements Iterable\u003cItem\u003e { private Node first; private Node last; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void enqueue(Item item) { Node oldLast = last; last = new Node(); last.item = item; last.next = null; if (isEmpty()) { first = last; } else { oldLast.next = last; } size++; } public Item dequeue() { Item item = first.item; first = first.next; if (isEmpty()) { last = null; } size--; return item; } @Override public Iterator\u003cItem\u003e iterator() { return new ListIterator(); } private class ListIterator implements Iterator\u003cItem\u003e { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:2:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#队列的实现"},{"categories":["「算法第四版」"],"content":" 队列的实现 队列的链表实现 import java.util.Iterator; public class Queue implements Iterable { private Node first; private Node last; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void enqueue(Item item) { Node oldLast = last; last = new Node(); last.item = item; last.next = null; if (isEmpty()) { first = last; } else { oldLast.next = last; } size++; } public Item dequeue() { Item item = first.item; first = first.next; if (isEmpty()) { last = null; } size--; return item; } @Override public Iterator iterator() { return new ListIterator(); } private class ListIterator implements Iterator { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:2:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#队列的链表实现"},{"categories":["「算法第四版」"],"content":" 后进先出（LIFO）栈栈 API： public class Stack\u003cItem\u003e implements Iterable\u003cItem\u003e Stack() 创建一个空栈 void push() 添加一个元素 Item pop() 删除最近添加的元素 boolean isEmpty() 栈是否为空 int size() 栈中元素数量 ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#后进先出lifo栈"},{"categories":["「算法第四版」"],"content":" 栈的实现 栈的数组实现 import java.util.Iterator; public class ResizingArrayStack\u003cItem\u003e implements Iterable\u003cItem\u003e { private Item[] array = (Item[]) new Object[1]; private int size = 0; public boolean isEmpty() { return size == 0; } public int size() { return size; } public void push(Item item) { if (size == array.length) { resize(2 * array.length); } array[size++] = item; } public Item pop() { Item item = array[--size]; array[size] = null; if (size \u003e 0 \u0026\u0026 size == array.length / 4) { resize(array.length / 2); } return item; } private void resize(int length) { Item[] temp = (Item[]) new Object[length]; for (int i = 0; i \u003c size; i++) { temp[i] = array[i]; } array = temp; } @Override public Iterator\u003cItem\u003e iterator() { return new ReverseArrayIterator(); } private class ReverseArrayIterator implements Iterator\u003cItem\u003e { private int index = size; @Override public boolean hasNext() { return index \u003e 0; } @Override public Item next() { return array[--index]; } } } 栈的链表实现 import java.util.Iterator; public class Stack\u003cItem\u003e implements Iterable\u003cItem\u003e { private Node first; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void push(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; size++; } public Item pop() { Item item = first.item; first = first.next; size--; return item; } @Override public Iterator\u003cItem\u003e iterator() { return new ListIterator(); } private class ListIterator implements Iterator\u003cItem\u003e { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:3:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#栈的实现"},{"categories":["「算法第四版」"],"content":" 栈的实现 栈的数组实现 import java.util.Iterator; public class ResizingArrayStack implements Iterable { private Item[] array = (Item[]) new Object[1]; private int size = 0; public boolean isEmpty() { return size == 0; } public int size() { return size; } public void push(Item item) { if (size == array.length) { resize(2 * array.length); } array[size++] = item; } public Item pop() { Item item = array[--size]; array[size] = null; if (size \u003e 0 \u0026\u0026 size == array.length / 4) { resize(array.length / 2); } return item; } private void resize(int length) { Item[] temp = (Item[]) new Object[length]; for (int i = 0; i \u003c size; i++) { temp[i] = array[i]; } array = temp; } @Override public Iterator iterator() { return new ReverseArrayIterator(); } private class ReverseArrayIterator implements Iterator { private int index = size; @Override public boolean hasNext() { return index \u003e 0; } @Override public Item next() { return array[--index]; } } } 栈的链表实现 import java.util.Iterator; public class Stack implements Iterable { private Node first; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void push(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; size++; } public Item pop() { Item item = first.item; first = first.next; size--; return item; } @Override public Iterator iterator() { return new ListIterator(); } private class ListIterator implements Iterator { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:3:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#栈的数组实现"},{"categories":["「算法第四版」"],"content":" 栈的实现 栈的数组实现 import java.util.Iterator; public class ResizingArrayStack implements Iterable { private Item[] array = (Item[]) new Object[1]; private int size = 0; public boolean isEmpty() { return size == 0; } public int size() { return size; } public void push(Item item) { if (size == array.length) { resize(2 * array.length); } array[size++] = item; } public Item pop() { Item item = array[--size]; array[size] = null; if (size \u003e 0 \u0026\u0026 size == array.length / 4) { resize(array.length / 2); } return item; } private void resize(int length) { Item[] temp = (Item[]) new Object[length]; for (int i = 0; i \u003c size; i++) { temp[i] = array[i]; } array = temp; } @Override public Iterator iterator() { return new ReverseArrayIterator(); } private class ReverseArrayIterator implements Iterator { private int index = size; @Override public boolean hasNext() { return index \u003e 0; } @Override public Item next() { return array[--index]; } } } 栈的链表实现 import java.util.Iterator; public class Stack implements Iterable { private Node first; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void push(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; size++; } public Item pop() { Item item = first.item; first = first.next; size--; return item; } @Override public Iterator iterator() { return new ListIterator(); } private class ListIterator implements Iterator { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:3:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#栈的链表实现"},{"categories":["「算法第四版」"],"content":" 栈的应用Dijkstra 双栈算术表达式求值算法 public class Evaluate { public static void main(String[] args) { Stack\u003cString\u003e ops = new Stack\u003c\u003e(); Stack\u003cDouble\u003e vals = new Stack\u003c\u003e(); while (!StdIn.isEmpty()) { String s = StdIn.readString(); switch (s) { case \"(\" -\u003e { ; } case \"+\", \"-\", \"*\", \"/\", \"sqrt\" -\u003e ops.push(s); case \")\" -\u003e { String op = ops.pop(); double v = vals.pop(); v = switch (op) { case \"+\" -\u003e vals.pop() + v; case \"-\" -\u003e vals.pop() - v; case \"*\" -\u003e vals.pop() * v; case \"/\" -\u003e vals.pop() / v; case \"sqrt\" -\u003e Math.sqrt(v); default -\u003e v; }; vals.push(v); } default -\u003e vals.push(Double.parseDouble(s)); } } StdOut.println(vals.pop()); } } ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:3:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#栈的应用"},{"categories":null,"content":"Volatile 变量与线程安全","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"},{"categories":null,"content":" 一个线程不安全的现象一个数组实现的环形缓冲区，变量 readPos 和 writePos 分别记录下一个读取的索引和下一个写入的索引。当缓冲区为空时，消费者会在数据存入缓冲区前等待。当缓冲区满时，生产者会等待将数据存入缓冲区。 public class RingBuffer\u003cItem\u003e { private final Item[] buffer; private int readPos; private int writePos; RingBuffer(int capacity) { this.buffer = (Item[]) new Object[capacity]; this.readPos = 0; this.writePos = 0; } public void write(Item item) { while (isFull()) ; buffer[writePos] = item; writePos = (writePos + 1) % buffer.length; } public Item read() { while (isEmpty()) ; Item item = buffer[readPos]; readPos = (readPos + 1) % buffer.length; return item; } private boolean isEmpty() { return readPos == writePos; } private boolean isFull() { return ((writePos + 1) % buffer.length) == readPos; } public static void main(String[] args) { RingBuffer\u003cInteger\u003e ringBuffer = new RingBuffer\u003c\u003e(10); Thread writer1 = new Thread(() -\u003e { for (int item = 0; item \u003c Integer.MAX_VALUE; item++) { ringBuffer.write(item); } }); writer1.start(); while (true) { StdOut.println(ringBuffer.read()); } } } 在运行此测试用例时发现两个线程都容易进入死循环。写入线程一直认为缓冲区是满的，消费线程一直认为缓冲区是空的。经过排查，此现象是 readPos 和 writePos 变量不一致导致的。 在写入线程中，writePos 变量只会被写入线程修改，因此该变量对于写入线程来说始终是最新值。而写入线程调用 isFull 方法的 readPos 变量会被读取线程修改，导致写入线程中 readPos 变量是旧数据。 在读取线程中，readPos 变量只会被读取线程修改，因此该变量对于读取线程来说始终是最新值。而读取线程调用 isEmpty 方法的 writePos 变量会被写入线程修改，导致读取线程中 writePos 变量是旧数据。 ","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:1:0","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#一个线程不安全的现象"},{"categories":null,"content":" 解决方案将 readPos 和 writePos 改为 volatile 变量，在这个场景中能够保证这两个变量的线程安全。 那么 volatile 变量在此场景中是如何保证线程安全的呢？ ","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:2:0","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#解决方案"},{"categories":null,"content":" volatile 变量机制","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:3:0","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#volatile-变量机制"},{"categories":null,"content":" 可见行保证对于非 volatile 变量，JVM 不会保证线程修改变量会被立即从 CPU 缓存中回写到主内存中。使得另一个线程可能会从主内存读取到该变量的旧值。 对于 volatile 变量，JVM 会保证线程每次都会从主内存中读取该变量。并且对该变量的修改会被立即回写到主内存。此时其余所有线程都会看到该变量的最新值。 ","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:3:1","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#可见行保证"},{"categories":null,"content":" happens-before 保证happens-before 保证会对指令重排序进行限制。 对 volatile 变量进行写入操作之前的所有指令不会因指令重排序导致这些指令在写入操作的后面； 对 volatile 变量进行读取操作之后的所有指令不会因指令重排序导致这些指令在写入操作的之前。 即本应在 volatile 变量读取与写入操作之间的指令，不会因为指令重排序导致这些指令在变量读取与写入操作之外。 ","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:3:2","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#happens-before-保证"},{"categories":null,"content":" volatile 变量何时是线程安全的？在以下两个场景，volatile 变量是线程安全的： 当只有一个线程向 volatile 变量写入，其余多个线程仅读取该变量时，总会读取最新的数据，此时是线程安全的； 当多个线程向 volatile 变量写入并且对变量的操作是原子操作（被写入的新值不依赖旧值），此时是线程安全的。 ","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:4:0","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#volatile-变量何时是线程安全的"},{"categories":null,"content":" 一个 volitile 变量例子 public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } ","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:5:0","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#一个-volitile-变量例子"},{"categories":null,"content":" 参考资料Concurrency in Java: “synchronized” and “volatile” keywords Volatile Variables and Thread Safety ","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:6:0","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#参考资料"},{"categories":["Redis升级"],"content":"通过分析 Redis 异步删除源码，判断异步删除能否解决大 Key 过期阻塞主线程的问题。","date":"2023-03-04","objectID":"/redis%E5%8D%87%E7%BA%A7_1_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis异步删除解决大Key过期阻塞问题可行性分析","uri":"/redis%E5%8D%87%E7%BA%A7_1_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/"},{"categories":["Redis升级"],"content":"自 Redis 4 版本引入了异步删除方法 unlink，官方对该接口的解释： “This command is very similar to DEL: it removes the specified keys. Just like DEL a key is ignored if it does not exist. However the command performs the actual memory reclaiming in a different thread, so it is not blocking, while DEL is. This is where the command name comes from: the command just unlinks the keys from the keyspace. The actual removal will happen later asynchronously.” 可知 unlink 与 del 用法相同，只不过内存回收在另一个不同线程中，内存回收操作在 unlink 方法调用结束之后，因此是非阻塞方法。 ","date":"2023-03-04","objectID":"/redis%E5%8D%87%E7%BA%A7_1_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/:0:0","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis异步删除解决大Key过期阻塞问题可行性分析","uri":"/redis%E5%8D%87%E7%BA%A7_1_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/#"},{"categories":["Redis升级"],"content":" 源码分析","date":"2023-03-04","objectID":"/redis%E5%8D%87%E7%BA%A7_1_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/:1:0","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis异步删除解决大Key过期阻塞问题可行性分析","uri":"/redis%E5%8D%87%E7%BA%A7_1_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/#源码分析"},{"categories":["Redis升级"],"content":" 异步删除流程同步删除与异步删除的方法入口分别为 delCommand 方法与 unlinkCommand 方法。 void delCommand(client *c) { delGenericCommand(c,server.lazyfree_lazy_user_del); } void unlinkCommand(client *c) { delGenericCommand(c,1); } 这两个方法都调用 delGenericCommand 方法，server.lazyfree_lazy_user_del 可通过配置文件配置，配置后可以使 del 命令与 unlink 命令完全相同。 /* This command implements DEL and LAZYDEL. */ void delGenericCommand(client *c, int lazy) { int numdel = 0, j; for (j = 1; j \u003c c-\u003eargc; j++) { expireIfNeeded(c-\u003edb,c-\u003eargv[j],0); // 判断传入的 lazy 值选择异步删除或同步删除 int deleted = lazy ? dbAsyncDelete(c-\u003edb,c-\u003eargv[j]) : dbSyncDelete(c-\u003edb,c-\u003eargv[j]); if (deleted) { signalModifiedKey(c,c-\u003edb,c-\u003eargv[j]); notifyKeyspaceEvent(NOTIFY_GENERIC, \"del\",c-\u003eargv[j],c-\u003edb-\u003eid); server.dirty++; numdel++; } } addReplyLongLong(c,numdel); } delGenericCommand 方法判断传入的 lazy 参数值决定异步删除或者同步删除。 /* Delete a key, value, and associated expiration entry if any, from the DB */ int dbSyncDelete(redisDb *db, robj *key) { return dbGenericDelete(db, key, 0); } /* Delete a key, value, and associated expiration entry if any, from the DB. If * the value consists of many allocations, it may be freed asynchronously. */ int dbAsyncDelete(redisDb *db, robj *key) { return dbGenericDelete(db, key, 1); } 同步删除和异步删除都是调用 dbGenericDelete 方法，仅传入的 async 参数不同。 /* Helper for sync and async delete. */ static int dbGenericDelete(redisDb *db, robj *key, int async) { /* Deleting an entry from the expires dict will not free the sds of * the key, because it is shared with the main dictionary. */ // 删除 expires 字典中该 key，但不会删除 SDS 结构，因为该 SDS 在 dict 字典中被共享。 if (dictSize(db-\u003eexpires) \u003e 0) dictDelete(db-\u003eexpires,key-\u003eptr); // 数据库字典中移除 key，不释放内存。 dictEntry *de = dictUnlink(db-\u003edict,key-\u003eptr); if (de) { robj *val = dictGetVal(de); /* Tells the module that the key has been unlinked from the database. */ moduleNotifyKeyUnlink(key,val,db-\u003eid); /* We want to try to unblock any client using a blocking XREADGROUP */ if (val-\u003etype == OBJ_STREAM) signalKeyAsReady(db,key,val-\u003etype); if (async) { // 异步释放内存 freeObjAsync(key, val, db-\u003eid); dictSetVal(db-\u003edict, de, NULL); } if (server.cluster_enabled) slotToKeyDelEntry(de, db); // 释放内存 dictFreeUnlinkedEntry(db-\u003edict,de); return 1; } else { return 0; } } /* You need to call this function to really free the entry after a call * to dictUnlink(). It's safe to call this function with 'he' = NULL. */ void dictFreeUnlinkedEntry(dict *d, dictEntry *he) { if (he == NULL) return; dictFreeKey(d, he); dictFreeVal(d, he); zfree(he); } dbGenericDelete 方法首先将 key 在 expires 字典中删除并释放内存，再在 dict 字典中移除该 key，但此时不释放内存。 通过 async 参数判断是否需要异步释放内存，若需要则会调用 freeObjAsync 方法进行异步释放内存，若不需要异步释放内存，则在 dictFreeUnlinkedEntry 方法中直接释放。 若进入 freeObjAsync 方法但不满足异步释放条件（在 freeObjAsync 方法中），也会在 dictFreeUnlinkedEntry 方法中直接释放。 /* If there are enough allocations to free the value object asynchronously, it * may be put into a lazy free list instead of being freed synchronously. The * lazy free list will be reclaimed in a different bio.c thread. If the value is * composed of a few allocations, to free in a lazy way is actually just * slower... So under a certain limit we just free the object synchronously. */ #define LAZYFREE_THRESHOLD 64 /* Free an object, if the object is huge enough, free it in async way. */ void freeObjAsync(robj *key, robj *obj, int dbid) { // 计算异步删除阈值 size_t free_effort = lazyfreeGetFreeEffort(key,obj,dbid); /* Note that if the object is shared, to reclaim it now it is not * possible. This rarely happens, however sometimes the implementation * of parts of the Redis core may call incrRefCount() to protect * objects, and then call dbDelete(). */ if (free_effort \u003e LAZYFREE_THRESHOLD \u0026\u0026 obj-\u003erefcount == 1) { atomicIncr(lazyfree_objects,1); // 任务超过异步删除阈值，创建异步删除任务 bioCreateLazyFreeJob(lazyfreeFreeObject,1,obj); } else { decrRefCount(obj); } } 重点看 freeObjAsync 方法，先计算该 key 的异步删除阈值，若大于阈值 64，则为该 key 创建异步删除任务。 void bioCreateLazyFreeJob(lazy_free_fn free_fn, int arg_count, ...) { va_list valist; /* Allocate memory for the job structure and all required * a","date":"2023-03-04","objectID":"/redis%E5%8D%87%E7%BA%A7_1_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/:1:1","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis异步删除解决大Key过期阻塞问题可行性分析","uri":"/redis%E5%8D%87%E7%BA%A7_1_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/#异步删除流程"},{"categories":["Redis升级"],"content":" 惰性删除与异步删除Redis 惰性删除策略是否采用异步删除策略？ 在惰性删除中，Redis 在操作 Key 时会先判断该 Key 是否过期，若过期则会删除该 Key。 /* This function is called when we are going to perform some operation * in a given key, but such key may be already logically expired even if * it still exists in the database. The main way this function is called * is via lookupKey*() family of functions. * * The behavior of the function depends on the replication role of the * instance, because by default replicas do not delete expired keys. They * wait for DELs from the master for consistency matters. However even * replicas will try to have a coherent return value for the function, * so that read commands executed in the replica side will be able to * behave like if the key is expired even if still present (because the * master has yet to propagate the DEL). * * In masters as a side effect of finding a key which is expired, such * key will be evicted from the database. Also this may trigger the * propagation of a DEL/UNLINK command in AOF / replication stream. * * On replicas, this function does not delete expired keys by default, but * it still returns 1 if the key is logically expired. To force deletion * of logically expired keys even on replicas, use the EXPIRE_FORCE_DELETE_EXPIRED * flag. Note though that if the current client is executing * replicated commands from the master, keys are never considered expired. * * On the other hand, if you just want expiration check, but need to avoid * the actual key deletion and propagation of the deletion, use the * EXPIRE_AVOID_DELETE_EXPIRED flag. * * The return value of the function is 0 if the key is still valid, * otherwise the function returns 1 if the key is expired. */ int expireIfNeeded(redisDb *db, robj *key, int flags) { if (!keyIsExpired(db,key)) return 0; /* If we are running in the context of a replica, instead of * evicting the expired key from the database, we return ASAP: * the replica key expiration is controlled by the master that will * send us synthesized DEL operations for expired keys. The * exception is when write operations are performed on writable * replicas. * * Still we try to return the right information to the caller, * that is, 0 if we think the key should be still valid, 1 if * we think the key is expired at this time. * * When replicating commands from the master, keys are never considered * expired. */ if (server.masterhost != NULL) { if (server.current_client == server.master) return 0; if (!(flags \u0026 EXPIRE_FORCE_DELETE_EXPIRED)) return 1; } /* In some cases we're explicitly instructed to return an indication of a * missing key without actually deleting it, even on masters. */ if (flags \u0026 EXPIRE_AVOID_DELETE_EXPIRED) return 1; /* If clients are paused, we keep the current dataset constant, * but return to the client what we believe is the right state. Typically, * at the end of the pause we will properly expire the key OR we will * have failed over and the new primary will send us the expire. */ if (checkClientPauseTimeoutAndReturnIfPaused()) return 1; /* Delete the key */ // 删除 key deleteExpiredKeyAndPropagate(db,key); return 1; } expireIfNeeded 方法会调用 deleteExpiredKeyAndPropagate 方法删除 key。 删除 key 时会读取 server.lazyfree_lazy_expire 配置决定删除策略。server.lazyfree_lazy_expire 可在配置文件中配置，配置后惰性删除将采用异步删除策略。 /* Delete the specified expired key and propagate expire. */ void deleteExpiredKeyAndPropagate(redisDb *db, robj *keyobj) { mstime_t expire_latency; latencyStartMonitor(expire_latency); if (server.lazyfree_lazy_expire) // 采用异步删除策略 dbAsyncDelete(db,keyobj); else dbSyncDelete(db,keyobj); latencyEndMonitor(expire_latency); latencyAddSampleIfNeeded(\"expire-del\",expire_latency); notifyKeyspaceEvent(NOTIFY_EXPIRED,\"expired\",keyobj,db-\u003eid); signalModifiedKey(NULL, db, keyobj); propagateDeletion(db,keyobj,server.lazyfree_lazy_expire); server.stat_expiredkeys++; } 结论：Redis 惰性删除在配置后可采用异步删除策略。 ","date":"2023-03-04","objectID":"/redis%E5%8D%87%E7%BA%A7_1_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/:1:2","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis异步删除解决大Key过期阻塞问题可行性分析","uri":"/redis%E5%8D%87%E7%BA%A7_1_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/#惰性删除与异步删除"},{"categories":["Redis升级"],"content":" 定时删除与异步删除定时任务 serverCron 方法最终会调用 activeExpireCycleTryExpire 方法，该方法仍会调用 deleteExpiredKeyAndPropagate 方法。 /* Helper function for the activeExpireCycle() function. * This function will try to expire the key that is stored in the hash table * entry 'de' of the 'expires' hash table of a Redis database. * * If the key is found to be expired, it is removed from the database and * 1 is returned. Otherwise no operation is performed and 0 is returned. * * When a key is expired, server.stat_expiredkeys is incremented. * * The parameter 'now' is the current time in milliseconds as is passed * to the function to avoid too many gettimeofday() syscalls. */ int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) { long long t = dictGetSignedIntegerVal(de); if (now \u003e t) { sds key = dictGetKey(de); robj *keyobj = createStringObject(key,sdslen(key)); // 删除 key deleteExpiredKeyAndPropagate(db,keyobj); decrRefCount(keyobj); return 1; } else { return 0; } } 结论：Redis 定时删除在配置后可采用异步删除策略。 ","date":"2023-03-04","objectID":"/redis%E5%8D%87%E7%BA%A7_1_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/:1:3","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis异步删除解决大Key过期阻塞问题可行性分析","uri":"/redis%E5%8D%87%E7%BA%A7_1_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/#定时删除与异步删除"},{"categories":["Redis升级"],"content":" 结论异步删除策略能够在删除大 Key 时避免主线程阻塞，惰性删除与定时删除在配置后均可采用异步删除策略，因此异步删除能够解决大 Key 过期引起的主线程阻塞问题。 ","date":"2023-03-04","objectID":"/redis%E5%8D%87%E7%BA%A7_1_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/:2:0","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis异步删除解决大Key过期阻塞问题可行性分析","uri":"/redis%E5%8D%87%E7%BA%A7_1_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/#结论"},{"categories":["Redis升级"],"content":"记录Redis升级流程。","date":"2023-03-03","objectID":"/redis%E5%8D%87%E7%BA%A7_0_%E5%BC%80%E7%AF%87/","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis升级——开篇","uri":"/redis%E5%8D%87%E7%BA%A7_0_%E5%BC%80%E7%AF%87/"},{"categories":["Redis升级"],"content":" 现版本存在的问题目前在生产环境中部署的旧版本Redis存在的问题： 大 key 过期删除引发集群节点阻塞失去响应不可用； 内存碎片高，内存使用率低； 运维时，手动主从切换总会产生复制风暴问题，主从无法同步； bgsave 内存消耗较高，有 OOM 风险。 ","date":"2023-03-03","objectID":"/redis%E5%8D%87%E7%BA%A7_0_%E5%BC%80%E7%AF%87/:1:0","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis升级——开篇","uri":"/redis%E5%8D%87%E7%BA%A7_0_%E5%BC%80%E7%AF%87/#现版本存在的问题"},{"categories":["Redis升级"],"content":" 推进版本升级由于以上原因，开始推进 Redis 版本升级。 版本升级工作流程： 通过文档与源码，调研 Redis 新特性； 客户端兼容性改造； 功能测试、性能测试和稳定性测试； 开发配套监控和运维工具； 推进上线。 ","date":"2023-03-03","objectID":"/redis%E5%8D%87%E7%BA%A7_0_%E5%BC%80%E7%AF%87/:2:0","series":["Redis升级笔记"],"tags":["Redis升级"],"title":"Redis升级——开篇","uri":"/redis%E5%8D%87%E7%BA%A7_0_%E5%BC%80%E7%AF%87/#推进版本升级"},{"categories":["「算法第四版」"],"content":"「算法第四版」欧几里得算法求最大公因数","date":"2023-02-27","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」欧几里得算法求最大公因数","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/"},{"categories":["「算法第四版」"],"content":" 自然语言描述计算两个非负整数 p 和 q 的最大公约数：若 q 是 0，则最大公约数为 p。否则，将 p 除以 q 得到余数 r，p 和 q 的最大公约数即为 q 和 r 的最大公约数。 ","date":"2023-02-27","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」欧几里得算法求最大公因数","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/#自然语言描述"},{"categories":["「算法第四版」"],"content":" 递归写法 public class Euclid { public static int gcd(int p, int q) { if (q == 0) return p; int r = p % q; return gcd(q, r); } } ","date":"2023-02-27","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」欧几里得算法求最大公因数","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/#递归写法"},{"categories":["「算法第四版」"],"content":" 循环写法 public class Euclid { public static int gcd(int p, int q) { if (q == 0) return p; while (q != 0) { int r = p % q; p = q; q = r; } return p; } } ","date":"2023-02-27","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」欧几里得算法求最大公因数","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/#循环写法"},{"categories":["「算法第四版」"],"content":"「算法第四版」二分查找","date":"2023-02-26","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」二分查找","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["「算法第四版」"],"content":" 前提条件查找的数组是有序的。 ","date":"2023-02-26","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」二分查找","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#前提条件"},{"categories":["「算法第四版」"],"content":" 递归写法 public class BinarySearch { public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1); } public static int rank(int key, int[] a, int lo, int hi) { if (lo \u003e hi) return -1; int mid = lo + (hi - lo) / 2; if (key \u003c a[mid]) return rank(key, a, lo, hi - 1); else if (key \u003e a[mid]) return rank(key, a, lo + 1, hi); else return mid; } } ","date":"2023-02-26","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」二分查找","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#递归写法"},{"categories":["「算法第四版」"],"content":" 循环写法 public class BinarySearch { public static int rank(int key, int[] a) { int lo = 0; int hi = a.length - 1; while (lo \u003c hi) { int mid = lo + (hi - lo) / 2; if (key \u003c a[mid]) hi = lo - 1; else if (key \u003e a[mid]) lo = hi + 1; else return mid; } return -1; } } ","date":"2023-02-26","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」二分查找","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#循环写法"},{"categories":["「算法第四版」"],"content":" 二分查找 key 的最小索引 public class BinarySearch { public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1); } public static int rank(int[] array, int key, int lo, int hi) { while (lo \u003c= hi) { int mid = lo + ((hi - lo) \u003e\u003e 1); if (key \u003c= array[mid]) { hi = mid - 1; } else { lo = mid + 1; } } if (lo == array.length) return -1; return array[lo] == key ? lo : -1; } } ","date":"2023-02-26","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」二分查找","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#二分查找-key-的最小索引"},{"categories":["「算法第四版」"],"content":" 二分查找极小(大)值 public class BinarySearch { public static int partialMin(int[] array) { assert array != null \u0026\u0026 array.length \u003e 0; int lo = 0; int hi = array.length - 1; while (lo \u003c= hi) { int mid = lo + ((hi - lo) \u003e\u003e 1); if (mid == 0 || mid == array.length - 1) break; if (array[mid] \u003c array[mid - 1] \u0026\u0026 array[mid] \u003c array[mid + 1]) { return mid; } else if (array[mid - 1] \u003c= array[mid + 1]) { hi = mid - 1; } else { lo = mid + 1; } } return -1; } } ","date":"2023-02-26","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:5:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」二分查找","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#二分查找极小大值"},{"categories":["「算法第四版」"],"content":"「算法第四版」阅读开篇","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」阅读开篇","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/"},{"categories":["「算法第四版」"],"content":" 本系列文章作用2023 年计划将「算法第四版」认真阅读一遍，在博客中整理常用的算法，把书读薄，时常复习，提高编码水平。 习题仓库：https://github.com/Nanciico/algs4 加油！ ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」阅读开篇","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/#本系列文章作用"},{"categories":null,"content":" 关于我 姓名: Shuyang 职业: 后端程序员，负责 Redis 相关工作 ","date":"2022-10-13","objectID":"/about/:1:0","series":null,"tags":null,"title":"关于","uri":"/about/#关于我"}]