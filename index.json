[{"content":"ç°ç‰ˆæœ¬å­˜åœ¨çš„é—®é¢˜ ç›®å‰åœ¨ç”Ÿäº§ç¯å¢ƒä¸­éƒ¨ç½²çš„æ—§ç‰ˆæœ¬Rediså­˜åœ¨çš„é—®é¢˜ï¼š\nå¤§ key è¿‡æœŸåˆ é™¤å¼•å‘é›†ç¾¤èŠ‚ç‚¹é˜»å¡å¤±å»å“åº”ä¸å¯ç”¨ï¼› å†…å­˜ç¢ç‰‡é«˜ï¼Œå†…å­˜ä½¿ç”¨ç‡ä½ï¼› è¿ç»´æ—¶ï¼Œæ‰‹åŠ¨ä¸»ä»åˆ‡æ¢æ€»ä¼šäº§ç”Ÿå¤åˆ¶é£æš´é—®é¢˜ï¼Œä¸»ä»æ— æ³•åŒæ­¥ï¼› bgsave å†…å­˜æ¶ˆè€—è¾ƒé«˜ï¼Œæœ‰ OOM é£é™©ã€‚ æ¨è¿›ç‰ˆæœ¬å‡çº§ ç”±äºä»¥ä¸ŠåŸå› ï¼Œå¼€å§‹æ¨è¿› Redis ç‰ˆæœ¬å‡çº§ã€‚\nç‰ˆæœ¬å‡çº§å·¥ä½œæµç¨‹ï¼š\né€šè¿‡æ–‡æ¡£ä¸æºç ï¼Œè°ƒç ” Redis æ–°ç‰¹æ€§ï¼› å®¢æˆ·ç«¯å…¼å®¹æ€§æ”¹é€ ï¼› åŠŸèƒ½æµ‹è¯•ã€æ€§èƒ½æµ‹è¯•å’Œç¨³å®šæ€§æµ‹è¯•ï¼› å¼€å‘é…å¥—ç›‘æ§å’Œè¿ç»´å·¥å…·ï¼› æ¨è¿›ä¸Šçº¿ã€‚ ","permalink":"https://fullzsy.github.io/posts/tech/redis%E5%8D%87%E7%BA%A7_0_%E5%BC%80%E7%AF%87/","summary":"è®°å½•Rediså‡çº§æµç¨‹ã€‚","title":"Rediså‡çº§â€”â€”å¼€ç¯‡"},{"content":"è‡ª Redis 4 ç‰ˆæœ¬å¼•å…¥äº†å¼‚æ­¥åˆ é™¤æ–¹æ³• unlinkï¼Œå®˜æ–¹å¯¹è¯¥æ¥å£çš„è§£é‡Šï¼š\nâ€œThis command is very similar to DEL: it removes the specified keys. Just like DEL a key is ignored if it does not exist. However the command performs the actual memory reclaiming in a different thread, so it is not blocking, while DEL is. This is where the command name comes from: the command just unlinks the keys from the keyspace. The actual removal will happen later asynchronously.â€\nå¯çŸ¥ unlink ä¸ del ç”¨æ³•ç›¸åŒï¼Œåªä¸è¿‡å†…å­˜å›æ”¶åœ¨å¦ä¸€ä¸ªä¸åŒçº¿ç¨‹ä¸­ï¼Œå†…å­˜å›æ”¶æ“ä½œåœ¨ unlink æ–¹æ³•è°ƒç”¨ç»“æŸä¹‹åï¼Œå› æ­¤æ˜¯éé˜»å¡æ–¹æ³•ã€‚\næºç åˆ†æ å¼‚æ­¥åˆ é™¤æµç¨‹ åŒæ­¥åˆ é™¤ä¸å¼‚æ­¥åˆ é™¤çš„æ–¹æ³•å…¥å£åˆ†åˆ«ä¸º delCommand æ–¹æ³•ä¸ unlinkCommand æ–¹æ³•ã€‚\nvoid delCommand(client *c) { delGenericCommand(c,server.lazyfree_lazy_user_del); } void unlinkCommand(client *c) { delGenericCommand(c,1); } è¿™ä¸¤ä¸ªæ–¹æ³•éƒ½è°ƒç”¨ delGenericCommand æ–¹æ³•ï¼Œserver.lazyfree_lazy_user_del å¯é€šè¿‡é…ç½®æ–‡ä»¶é…ç½®ï¼Œé…ç½®åå¯ä»¥ä½¿ del å‘½ä»¤ä¸ unlink å‘½ä»¤å®Œå…¨ç›¸åŒã€‚\n/* This command implements DEL and LAZYDEL. */ void delGenericCommand(client *c, int lazy) { int numdel = 0, j; for (j = 1; j \u0026lt; c-\u0026gt;argc; j++) { expireIfNeeded(c-\u0026gt;db,c-\u0026gt;argv[j],0); // åˆ¤æ–­ä¼ å…¥çš„ lazy å€¼é€‰æ‹©å¼‚æ­¥åˆ é™¤æˆ–åŒæ­¥åˆ é™¤ int deleted = lazy ? dbAsyncDelete(c-\u0026gt;db,c-\u0026gt;argv[j]) : dbSyncDelete(c-\u0026gt;db,c-\u0026gt;argv[j]); if (deleted) { signalModifiedKey(c,c-\u0026gt;db,c-\u0026gt;argv[j]); notifyKeyspaceEvent(NOTIFY_GENERIC, \u0026#34;del\u0026#34;,c-\u0026gt;argv[j],c-\u0026gt;db-\u0026gt;id); server.dirty++; numdel++; } } addReplyLongLong(c,numdel); } delGenericCommand æ–¹æ³•åˆ¤æ–­ä¼ å…¥çš„ lazy å‚æ•°å€¼å†³å®šå¼‚æ­¥åˆ é™¤æˆ–è€…åŒæ­¥åˆ é™¤ã€‚\n/* Delete a key, value, and associated expiration entry if any, from the DB */ int dbSyncDelete(redisDb *db, robj *key) { return dbGenericDelete(db, key, 0); } /* Delete a key, value, and associated expiration entry if any, from the DB. If * the value consists of many allocations, it may be freed asynchronously. */ int dbAsyncDelete(redisDb *db, robj *key) { return dbGenericDelete(db, key, 1); } åŒæ­¥åˆ é™¤å’Œå¼‚æ­¥åˆ é™¤éƒ½æ˜¯è°ƒç”¨ dbGenericDelete æ–¹æ³•ï¼Œä»…ä¼ å…¥çš„ async å‚æ•°ä¸åŒã€‚\n/* Helper for sync and async delete. */ static int dbGenericDelete(redisDb *db, robj *key, int async) { /* Deleting an entry from the expires dict will not free the sds of * the key, because it is shared with the main dictionary. */ // åˆ é™¤ expires å­—å…¸ä¸­è¯¥ keyï¼Œä½†ä¸ä¼šåˆ é™¤ SDS ç»“æ„ï¼Œå› ä¸ºè¯¥ SDS åœ¨ dict å­—å…¸ä¸­è¢«å…±äº«ã€‚ if (dictSize(db-\u0026gt;expires) \u0026gt; 0) dictDelete(db-\u0026gt;expires,key-\u0026gt;ptr); // æ•°æ®åº“å­—å…¸ä¸­ç§»é™¤ keyï¼Œä¸é‡Šæ”¾å†…å­˜ã€‚ dictEntry *de = dictUnlink(db-\u0026gt;dict,key-\u0026gt;ptr); if (de) { robj *val = dictGetVal(de); /* Tells the module that the key has been unlinked from the database. */ moduleNotifyKeyUnlink(key,val,db-\u0026gt;id); /* We want to try to unblock any client using a blocking XREADGROUP */ if (val-\u0026gt;type == OBJ_STREAM) signalKeyAsReady(db,key,val-\u0026gt;type); if (async) { // å¼‚æ­¥é‡Šæ”¾å†…å­˜ freeObjAsync(key, val, db-\u0026gt;id); dictSetVal(db-\u0026gt;dict, de, NULL); } if (server.cluster_enabled) slotToKeyDelEntry(de, db); // é‡Šæ”¾å†…å­˜ dictFreeUnlinkedEntry(db-\u0026gt;dict,de); return 1; } else { return 0; } } /* You need to call this function to really free the entry after a call * to dictUnlink(). It\u0026#39;s safe to call this function with \u0026#39;he\u0026#39; = NULL. */ void dictFreeUnlinkedEntry(dict *d, dictEntry *he) { if (he == NULL) return; dictFreeKey(d, he); dictFreeVal(d, he); zfree(he); } dbGenericDelete æ–¹æ³•é¦–å…ˆå°† key åœ¨ expires å­—å…¸ä¸­åˆ é™¤å¹¶é‡Šæ”¾å†…å­˜ï¼Œå†åœ¨ dict å­—å…¸ä¸­ç§»é™¤è¯¥ keyï¼Œä½†æ­¤æ—¶ä¸é‡Šæ”¾å†…å­˜ã€‚ é€šè¿‡ async å‚æ•°åˆ¤æ–­æ˜¯å¦éœ€è¦å¼‚æ­¥é‡Šæ”¾å†…å­˜ï¼Œè‹¥éœ€è¦åˆ™ä¼šè°ƒç”¨ freeObjAsync æ–¹æ³•è¿›è¡Œå¼‚æ­¥é‡Šæ”¾å†…å­˜ï¼Œè‹¥ä¸éœ€è¦å¼‚æ­¥é‡Šæ”¾å†…å­˜ï¼Œåˆ™åœ¨ dictFreeUnlinkedEntry æ–¹æ³•ä¸­ç›´æ¥é‡Šæ”¾ã€‚ è‹¥è¿›å…¥ freeObjAsync æ–¹æ³•ä½†ä¸æ»¡è¶³å¼‚æ­¥é‡Šæ”¾æ¡ä»¶ï¼ˆåœ¨ freeObjAsync æ–¹æ³•ä¸­ï¼‰ï¼Œä¹Ÿä¼šåœ¨ dictFreeUnlinkedEntry æ–¹æ³•ä¸­ç›´æ¥é‡Šæ”¾ã€‚\n/* If there are enough allocations to free the value object asynchronously, it * may be put into a lazy free list instead of being freed synchronously. The * lazy free list will be reclaimed in a different bio.c thread. If the value is * composed of a few allocations, to free in a lazy way is actually just * slower... So under a certain limit we just free the object synchronously. */ #define LAZYFREE_THRESHOLD 64 /* Free an object, if the object is huge enough, free it in async way. */ void freeObjAsync(robj *key, robj *obj, int dbid) { // è®¡ç®—å¼‚æ­¥åˆ é™¤é˜ˆå€¼ size_t free_effort = lazyfreeGetFreeEffort(key,obj,dbid); /* Note that if the object is shared, to reclaim it now it is not * possible. This rarely happens, however sometimes the implementation * of parts of the Redis core may call incrRefCount() to protect * objects, and then call dbDelete(). */ if (free_effort \u0026gt; LAZYFREE_THRESHOLD \u0026amp;\u0026amp; obj-\u0026gt;refcount == 1) { atomicIncr(lazyfree_objects,1); // ä»»åŠ¡è¶…è¿‡å¼‚æ­¥åˆ é™¤é˜ˆå€¼ï¼Œåˆ›å»ºå¼‚æ­¥åˆ é™¤ä»»åŠ¡ bioCreateLazyFreeJob(lazyfreeFreeObject,1,obj); } else { decrRefCount(obj); } } é‡ç‚¹çœ‹ freeObjAsync æ–¹æ³•ï¼Œå…ˆè®¡ç®—è¯¥ key çš„å¼‚æ­¥åˆ é™¤é˜ˆå€¼ï¼Œè‹¥å¤§äºé˜ˆå€¼ 64ï¼Œåˆ™ä¸ºè¯¥ key åˆ›å»ºå¼‚æ­¥åˆ é™¤ä»»åŠ¡ã€‚\nvoid bioCreateLazyFreeJob(lazy_free_fn free_fn, int arg_count, ...) { va_list valist; /* Allocate memory for the job structure and all required * arguments */ bio_job *job = zmalloc(sizeof(*job) + sizeof(void *) * (arg_count)); job-\u0026gt;free_args.free_fn = free_fn; va_start(valist, arg_count); for (int i = 0; i \u0026lt; arg_count; i++) { job-\u0026gt;free_args.free_args[i] = va_arg(valist, void *); } va_end(valist); // æäº¤ä»»åŠ¡ bioSubmitJob(BIO_LAZY_FREE, job); } void bioSubmitJob(int type, bio_job *job) { // äº’æ–¥é” pthread_mutex_lock(\u0026amp;bio_mutex[type]); // æ·»åŠ ä»»åŠ¡è‡³æœ«å°¾ listAddNodeTail(bio_jobs[type],job); bio_pending[type]++; // å‘é€ä¿¡å·å”¤é†’é˜»å¡çº¿ç¨‹ pthread_cond_signal(\u0026amp;bio_newjob_cond[type]); pthread_mutex_unlock(\u0026amp;bio_mutex[type]); } bioCreateLazyFreeJob æ–¹æ³•åˆ›å»ºä»»åŠ¡å¹¶è°ƒç”¨ bioSubmitJob æ–¹æ³•æäº¤ä»»åŠ¡åˆ° job æ•°æ®ç»“æ„ä¸­ã€‚\nvoid *bioProcessBackgroundJobs(void *arg) { bio_job *job; unsigned long type = (unsigned long) arg; sigset_t sigset; /* Check that the type is within the right interval. */ if (type \u0026gt;= BIO_NUM_OPS) { serverLog(LL_WARNING, \u0026#34;Warning: bio thread started with wrong type %lu\u0026#34;,type); return NULL; } switch (type) { case BIO_CLOSE_FILE: redis_set_thread_title(\u0026#34;bio_close_file\u0026#34;); break; case BIO_AOF_FSYNC: redis_set_thread_title(\u0026#34;bio_aof_fsync\u0026#34;); break; case BIO_LAZY_FREE: redis_set_thread_title(\u0026#34;bio_lazy_free\u0026#34;); break; } redisSetCpuAffinity(server.bio_cpulist); makeThreadKillable(); pthread_mutex_lock(\u0026amp;bio_mutex[type]); /* Block SIGALRM so we are sure that only the main thread will * receive the watchdog signal. */ sigemptyset(\u0026amp;sigset); sigaddset(\u0026amp;sigset, SIGALRM); if (pthread_sigmask(SIG_BLOCK, \u0026amp;sigset, NULL)) serverLog(LL_WARNING, \u0026#34;Warning: can\u0026#39;t mask SIGALRM in bio.c thread: %s\u0026#34;, strerror(errno)); while(1) { listNode *ln; /* The loop always starts with the lock hold. */ if (listLength(bio_jobs[type]) == 0) { pthread_cond_wait(\u0026amp;bio_newjob_cond[type],\u0026amp;bio_mutex[type]); continue; } /* Pop the job from the queue. */ ln = listFirst(bio_jobs[type]); job = ln-\u0026gt;value; /* It is now possible to unlock the background system as we know have * a stand alone job structure to process.*/ pthread_mutex_unlock(\u0026amp;bio_mutex[type]); /* Process the job accordingly to its type. */ if (type == BIO_CLOSE_FILE) { if (job-\u0026gt;fd_args.need_fsync) { redis_fsync(job-\u0026gt;fd_args.fd); } close(job-\u0026gt;fd_args.fd); } else if (type == BIO_AOF_FSYNC) { /* The fd may be closed by main thread and reused for another * socket, pipe, or file. We just ignore these errno because * aof fsync did not really fail. */ if (redis_fsync(job-\u0026gt;fd_args.fd) == -1 \u0026amp;\u0026amp; errno != EBADF \u0026amp;\u0026amp; errno != EINVAL) { int last_status; atomicGet(server.aof_bio_fsync_status,last_status); atomicSet(server.aof_bio_fsync_status,C_ERR); atomicSet(server.aof_bio_fsync_errno,errno); if (last_status == C_OK) { serverLog(LL_WARNING, \u0026#34;Fail to fsync the AOF file: %s\u0026#34;,strerror(errno)); } } else { atomicSet(server.aof_bio_fsync_status,C_OK); } } else if (type == BIO_LAZY_FREE) { job-\u0026gt;free_args.free_fn(job-\u0026gt;free_args.free_args); } else { serverPanic(\u0026#34;Wrong job type in bioProcessBackgroundJobs().\u0026#34;); } zfree(job); /* Lock again before reiterating the loop, if there are no longer * jobs to process we\u0026#39;ll block again in pthread_cond_wait(). */ pthread_mutex_lock(\u0026amp;bio_mutex[type]); listDelNode(bio_jobs[type],ln); bio_pending[type]--; /* Unblock threads blocked on bioWaitStepOfType() if any. */ pthread_cond_broadcast(\u0026amp;bio_step_cond[type]); } } æ‰§è¡Œåå°ä»»åŠ¡æ–¹æ³• bioProcessBackgroundJobsï¼Œè¯¦ç»†è¿‡ç¨‹ä¸åœ¨è®¨è®ºçš„ä¸»é¢˜ä¸­ã€‚\nç»“è®ºï¼šå¼‚æ­¥åˆ é™¤èƒ½å¤Ÿè§£å†³ä¸»çº¿ç¨‹é˜»å¡é—®é¢˜ã€‚\næƒ°æ€§åˆ é™¤ä¸å¼‚æ­¥åˆ é™¤ Redis æƒ°æ€§åˆ é™¤ç­–ç•¥æ˜¯å¦é‡‡ç”¨å¼‚æ­¥åˆ é™¤ç­–ç•¥ï¼Ÿ\nåœ¨æƒ°æ€§åˆ é™¤ä¸­ï¼ŒRedis åœ¨æ“ä½œ Key æ—¶ä¼šå…ˆåˆ¤æ–­è¯¥ Key æ˜¯å¦è¿‡æœŸï¼Œè‹¥è¿‡æœŸåˆ™ä¼šåˆ é™¤è¯¥ Keyã€‚\n/* This function is called when we are going to perform some operation * in a given key, but such key may be already logically expired even if * it still exists in the database. The main way this function is called * is via lookupKey*() family of functions. * * The behavior of the function depends on the replication role of the * instance, because by default replicas do not delete expired keys. They * wait for DELs from the master for consistency matters. However even * replicas will try to have a coherent return value for the function, * so that read commands executed in the replica side will be able to * behave like if the key is expired even if still present (because the * master has yet to propagate the DEL). * * In masters as a side effect of finding a key which is expired, such * key will be evicted from the database. Also this may trigger the * propagation of a DEL/UNLINK command in AOF / replication stream. * * On replicas, this function does not delete expired keys by default, but * it still returns 1 if the key is logically expired. To force deletion * of logically expired keys even on replicas, use the EXPIRE_FORCE_DELETE_EXPIRED * flag. Note though that if the current client is executing * replicated commands from the master, keys are never considered expired. * * On the other hand, if you just want expiration check, but need to avoid * the actual key deletion and propagation of the deletion, use the * EXPIRE_AVOID_DELETE_EXPIRED flag. * * The return value of the function is 0 if the key is still valid, * otherwise the function returns 1 if the key is expired. */ int expireIfNeeded(redisDb *db, robj *key, int flags) { if (!keyIsExpired(db,key)) return 0; /* If we are running in the context of a replica, instead of * evicting the expired key from the database, we return ASAP: * the replica key expiration is controlled by the master that will * send us synthesized DEL operations for expired keys. The * exception is when write operations are performed on writable * replicas. * * Still we try to return the right information to the caller, * that is, 0 if we think the key should be still valid, 1 if * we think the key is expired at this time. * * When replicating commands from the master, keys are never considered * expired. */ if (server.masterhost != NULL) { if (server.current_client == server.master) return 0; if (!(flags \u0026amp; EXPIRE_FORCE_DELETE_EXPIRED)) return 1; } /* In some cases we\u0026#39;re explicitly instructed to return an indication of a * missing key without actually deleting it, even on masters. */ if (flags \u0026amp; EXPIRE_AVOID_DELETE_EXPIRED) return 1; /* If clients are paused, we keep the current dataset constant, * but return to the client what we believe is the right state. Typically, * at the end of the pause we will properly expire the key OR we will * have failed over and the new primary will send us the expire. */ if (checkClientPauseTimeoutAndReturnIfPaused()) return 1; /* Delete the key */ // åˆ é™¤ key deleteExpiredKeyAndPropagate(db,key); return 1; } expireIfNeeded æ–¹æ³•ä¼šè°ƒç”¨ deleteExpiredKeyAndPropagate æ–¹æ³•åˆ é™¤ keyã€‚\nåˆ é™¤ key æ—¶ä¼šè¯»å– server.lazyfree_lazy_expire é…ç½®å†³å®šåˆ é™¤ç­–ç•¥ã€‚server.lazyfree_lazy_expire å¯åœ¨é…ç½®æ–‡ä»¶ä¸­é…ç½®ï¼Œé…ç½®åæƒ°æ€§åˆ é™¤å°†é‡‡ç”¨å¼‚æ­¥åˆ é™¤ç­–ç•¥ã€‚\n/* Delete the specified expired key and propagate expire. */ void deleteExpiredKeyAndPropagate(redisDb *db, robj *keyobj) { mstime_t expire_latency; latencyStartMonitor(expire_latency); if (server.lazyfree_lazy_expire) // é‡‡ç”¨å¼‚æ­¥åˆ é™¤ç­–ç•¥ dbAsyncDelete(db,keyobj); else dbSyncDelete(db,keyobj); latencyEndMonitor(expire_latency); latencyAddSampleIfNeeded(\u0026#34;expire-del\u0026#34;,expire_latency); notifyKeyspaceEvent(NOTIFY_EXPIRED,\u0026#34;expired\u0026#34;,keyobj,db-\u0026gt;id); signalModifiedKey(NULL, db, keyobj); propagateDeletion(db,keyobj,server.lazyfree_lazy_expire); server.stat_expiredkeys++; } ç»“è®ºï¼šRedis æƒ°æ€§åˆ é™¤åœ¨é…ç½®åå¯é‡‡ç”¨å¼‚æ­¥åˆ é™¤ç­–ç•¥ã€‚\nå®šæ—¶åˆ é™¤ä¸å¼‚æ­¥åˆ é™¤ å®šæ—¶ä»»åŠ¡ serverCron æ–¹æ³•æœ€ç»ˆä¼šè°ƒç”¨ activeExpireCycleTryExpire æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä»ä¼šè°ƒç”¨ deleteExpiredKeyAndPropagate æ–¹æ³•ã€‚\n/* Helper function for the activeExpireCycle() function. * This function will try to expire the key that is stored in the hash table * entry \u0026#39;de\u0026#39; of the \u0026#39;expires\u0026#39; hash table of a Redis database. * * If the key is found to be expired, it is removed from the database and * 1 is returned. Otherwise no operation is performed and 0 is returned. * * When a key is expired, server.stat_expiredkeys is incremented. * * The parameter \u0026#39;now\u0026#39; is the current time in milliseconds as is passed * to the function to avoid too many gettimeofday() syscalls. */ int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) { long long t = dictGetSignedIntegerVal(de); if (now \u0026gt; t) { sds key = dictGetKey(de); robj *keyobj = createStringObject(key,sdslen(key)); // åˆ é™¤ key deleteExpiredKeyAndPropagate(db,keyobj); decrRefCount(keyobj); return 1; } else { return 0; } } ç»“è®ºï¼šRedis å®šæ—¶åˆ é™¤åœ¨é…ç½®åå¯é‡‡ç”¨å¼‚æ­¥åˆ é™¤ç­–ç•¥ã€‚\nç»“è®º å¼‚æ­¥åˆ é™¤ç­–ç•¥èƒ½å¤Ÿåœ¨åˆ é™¤å¤§ Key æ—¶é¿å…ä¸»çº¿ç¨‹é˜»å¡ï¼Œæƒ°æ€§åˆ é™¤ä¸å®šæ—¶åˆ é™¤åœ¨é…ç½®åå‡å¯é‡‡ç”¨å¼‚æ­¥åˆ é™¤ç­–ç•¥ï¼Œå› æ­¤å¼‚æ­¥åˆ é™¤èƒ½å¤Ÿè§£å†³å¤§ Key è¿‡æœŸå¼•èµ·çš„ä¸»çº¿ç¨‹é˜»å¡é—®é¢˜ã€‚\n","permalink":"https://fullzsy.github.io/posts/tech/redis%E5%8D%87%E7%BA%A7_1_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/","summary":"é€šè¿‡åˆ†æ Redis å¼‚æ­¥åˆ é™¤æºç ï¼Œåˆ¤æ–­å¼‚æ­¥åˆ é™¤èƒ½å¦è§£å†³å¤§ Key è¿‡æœŸé˜»å¡ä¸»çº¿ç¨‹çš„é—®é¢˜ã€‚","title":"Rediså¼‚æ­¥åˆ é™¤è§£å†³å¤§Keyè¿‡æœŸé˜»å¡é—®é¢˜å¯è¡Œæ€§åˆ†æ"},{"content":"å‰ææ¡ä»¶ æŸ¥æ‰¾çš„æ•°ç»„æ˜¯æœ‰åºçš„ã€‚\né€’å½’å†™æ³• public class BinarySearch { public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1); } public static int rank(int key, int[] a, int lo, int hi) { if (lo \u0026gt; hi) return -1; int mid = lo + (hi - lo) / 2; if (key \u0026lt; a[mid]) return rank(key, a, lo, hi - 1); else if (key \u0026gt; a[mid]) return rank(key, a, lo + 1, hi); else return mid; } } å¾ªç¯å†™æ³• public class BinarySearch { public static int rank(int key, int[] a) { int lo = 0; int hi = a.length - 1; while (lo \u0026lt; hi) { int mid = lo + (hi - lo) / 2; if (key \u0026lt; a[mid]) hi = lo - 1; else if (key \u0026gt; a[mid]) lo = hi + 1; else return mid; } return -1; } } ","permalink":"https://fullzsy.github.io/posts/read/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","summary":"ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹äºŒåˆ†æŸ¥æ‰¾","title":"ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹äºŒåˆ†æŸ¥æ‰¾"},{"content":"è‡ªç„¶è¯­è¨€æè¿° è®¡ç®—ä¸¤ä¸ªéè´Ÿæ•´æ•° p å’Œ q çš„æœ€å¤§å…¬çº¦æ•°ï¼šè‹¥ q æ˜¯ 0ï¼Œåˆ™æœ€å¤§å…¬çº¦æ•°ä¸º pã€‚å¦åˆ™ï¼Œå°† p é™¤ä»¥ q å¾—åˆ°ä½™æ•° rï¼Œp å’Œ q çš„æœ€å¤§å…¬çº¦æ•°å³ä¸º q å’Œ r çš„æœ€å¤§å…¬çº¦æ•°ã€‚\né€’å½’å†™æ³• public class Euclid { public static int gcd(int p, int q) { if (q == 0) return p; int r = p % q; return gcd(q, r); } } å¾ªç¯å†™æ³• public class Euclid { public static int gcd(int p, int q) { if (q == 0) return p; while (q != 0) { int r = p % q; p = q; q = r; } return p; } } ","permalink":"https://fullzsy.github.io/posts/read/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/","summary":"ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚æœ€å¤§å…¬å› æ•°","title":"ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚æœ€å¤§å…¬å› æ•°"},{"content":"æœ¬ç³»åˆ—æ–‡ç« ä½œç”¨ 2023 å¹´è®¡åˆ’å°†ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹è®¤çœŸé˜…è¯»ä¸€éï¼Œåœ¨åšå®¢ä¸­æ•´ç†å¸¸ç”¨çš„ç®—æ³•ï¼ŒæŠŠä¹¦è¯»è–„ï¼Œæ—¶å¸¸å¤ä¹ ï¼Œæé«˜ç¼–ç æ°´å¹³ã€‚\nä¹ é¢˜ä»“åº“ï¼šhttps://github.com/FullZSY/algs4\nåŠ æ²¹ï¼\n","permalink":"https://fullzsy.github.io/posts/read/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/","summary":"ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹é˜…è¯»æ€»ç»“","title":"ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹é˜…è¯»"},{"content":"å…³äºæˆ‘ å§“å: Shuyang èŒä¸š: åç«¯ç¨‹åºå‘˜ï¼Œè´Ÿè´£ Redis ç›¸å…³å·¥ä½œ ","permalink":"https://fullzsy.github.io/about/","summary":"å…³äºæˆ‘ å§“å: Shuyang èŒä¸š: åç«¯ç¨‹åºå‘˜ï¼Œè´Ÿè´£ Redis ç›¸å…³å·¥ä½œ ","title":"ğŸ™‹ğŸ»â€â™‚ï¸å…³äº"}]