[{"categories":["「汇编语言」"],"content":"「汇编语言」第一个完整的程序","date":"2023-08-06","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」第一个完整的程序","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/"},{"categories":["「汇编语言」"],"content":" 一个源程序从写出到执行的过程一个汇编语言程序从写出到最终执行的简要过程如下： 编写汇编源程序，生成源程序文件 对源程序进行编译连接，生成可执行文件 在操作系统中，执行可执行文件中的程序 汇编语言程序从写出到执行的过程 ","date":"2023-08-06","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/:1:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」第一个完整的程序","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/#一个源程序从写出到执行的过程"},{"categories":["「汇编语言」"],"content":" 一个源程序一段简单的汇编语言源程序： assume cs:codesg ; 将用作代码段的段 codesg 和 CPU 中的段寄存器 cs 联系起来 codesq segment ; 定义一个段，段的名称为 “codesg”，这个段从此开始 mov ax, 0123H mov bx, 0456H add ax, bx add ax, ax mov ax, 4c00H ; 程序返回 int 21H codesq ends ; 名称为 “codesg” 的段到此结束 end ","date":"2023-08-06","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/:2:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」第一个完整的程序","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/#一个源程序"},{"categories":["「汇编语言」"],"content":" 伪指令在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。 伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。 segment endssegment 和 ends 是一对成对使用的伪指令。功能是定义一个段，segment 说明一个段开始，ends 说明一个段结束。 一个汇编程序是由多个段组成的，这些段被用来存放代码、 数据或当作栈空问来使用。一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。 endend 是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。 assume编译程序可以将段寄存器和某一个具体的段相联系。 使用 assume 指令可以一段寄存器和程序中的某一个用 segment..ends 定义的段相关联。 ","date":"2023-08-06","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/:2:1","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」第一个完整的程序","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/#伪指令"},{"categories":["「汇编语言」"],"content":" 伪指令在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。 伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。 segment endssegment 和 ends 是一对成对使用的伪指令。功能是定义一个段，segment 说明一个段开始，ends 说明一个段结束。 一个汇编程序是由多个段组成的，这些段被用来存放代码、 数据或当作栈空问来使用。一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。 endend 是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。 assume编译程序可以将段寄存器和某一个具体的段相联系。 使用 assume 指令可以一段寄存器和程序中的某一个用 segment..ends 定义的段相关联。 ","date":"2023-08-06","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/:2:1","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」第一个完整的程序","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/#segment-ends"},{"categories":["「汇编语言」"],"content":" 伪指令在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。 伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。 segment endssegment 和 ends 是一对成对使用的伪指令。功能是定义一个段，segment 说明一个段开始，ends 说明一个段结束。 一个汇编程序是由多个段组成的，这些段被用来存放代码、 数据或当作栈空问来使用。一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。 endend 是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。 assume编译程序可以将段寄存器和某一个具体的段相联系。 使用 assume 指令可以一段寄存器和程序中的某一个用 segment..ends 定义的段相关联。 ","date":"2023-08-06","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/:2:1","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」第一个完整的程序","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/#end"},{"categories":["「汇编语言」"],"content":" 伪指令在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。 伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。 segment endssegment 和 ends 是一对成对使用的伪指令。功能是定义一个段，segment 说明一个段开始，ends 说明一个段结束。 一个汇编程序是由多个段组成的，这些段被用来存放代码、 数据或当作栈空问来使用。一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。 endend 是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。 assume编译程序可以将段寄存器和某一个具体的段相联系。 使用 assume 指令可以一段寄存器和程序中的某一个用 segment..ends 定义的段相关联。 ","date":"2023-08-06","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/:2:1","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」第一个完整的程序","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/#assume"},{"categories":["「汇编语言」"],"content":" 源程序中的“程序”源程序中最终由计算机执行、处理的指令或数据，称为程序。程序最先以汇编指令的形式存在源程序中，经编译、 连接后转变为机器码，存储在可执行文件中。 源程序经过编译连接之后称为机器吗 ","date":"2023-08-06","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/:2:2","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」第一个完整的程序","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/#源程序中的程序"},{"categories":["「汇编语言」"],"content":" 标号汇编源程序中，除了汇编指令和伪指令外，还有一些标号，比如 “codesg”。一个标号指代了一个地址。 “codesg” 这个标号是代码段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。 ","date":"2023-08-06","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/:2:3","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」第一个完整的程序","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/#标号"},{"categories":["「汇编语言」"],"content":" 程序返回一个程序 P2 在可执行文件中，则必须有一个正在运行的程序 P1，将 P2 从可执行文件中加载入内存后，将 CPU 的控制权交给 P2，P2 才能得以运行。P2 开始运行后，P1 暂停运行。 而当 P2 运行完毕后，应该将 CPU 的控制权交还给使它得以运行的程序 P1，此后， P1 继续运行。 一个程序结束后，将 CPU 的控制权交还给使它得以运行的程序，我们称这个过程为：程序返回。 总结一下与结束相关的指令： 目的 相关指令 指令性质 指令执行者 通知编译器一个段结束 段名 ends 伪 指 令 编译时，由编译器执行 通知编译器程序结束 end 伪 指 令 编译时，由编译器执行 程序返回 mov ax,4c00H int 21H 汇编指令 执行时，由 CPU 执行 ","date":"2023-08-06","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/:2:4","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」第一个完整的程序","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/#程序返回"},{"categories":["「汇编语言」"],"content":" 编译连接编译的作用是通过源程序文件生成包含机器代码的目标文件(.obj 文件)。 连接的作用如下： 当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行 文件; 程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件; 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件(.exe 文件)。 ","date":"2023-08-06","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/:3:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」第一个完整的程序","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/#编译连接"},{"categories":["「汇编语言」"],"content":" 执行DOS 中有一个程序 command.com，这个程序在 DOS 中称为命令解释器，也就是 DOS 系统的 shell。 如果用户要执行一个程序，则输入该程序的可执行文件的名称，command 首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置 CS:IP 指向程序的入口。此后，command 暂停运行，CPU 运行程序。程序运行结束后，返回到 command 中，command 再次显示由当前盘符和当前路径组成的提示符，等待用户的输入。 ","date":"2023-08-06","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/:4:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」第一个完整的程序","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/#执行"},{"categories":["「汇编语言」"],"content":" 程序的加载过程 EXE 文件中程序的加载过程 程序加载后，ds 中存放着程序所在内存区的段地址，这个内存区的偏移地址为 0，则程序所在的内存区的地址为 ds:0; 这个内存区的前 256 个字节中存放的是 PSP，DOS 用来和程序进行通信。从 256 字节处向后的空间存放的是程序。 ","date":"2023-08-06","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/:4:1","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」第一个完整的程序","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/#程序的加载过程"},{"categories":["「汇编语言」"],"content":" 汇编程序从写出到执行的过程到此，完成了一个汇编程序从写出到执行的全部过程。 汇编程序从写出到执行的过程 ","date":"2023-08-06","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/:5:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」第一个完整的程序","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_04_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F/#汇编程序从写出到执行的过程"},{"categories":["「算法第四版」"],"content":"优先队列","date":"2023-08-04","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」优先队列","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["「算法第四版」"],"content":" 基本优先队列","date":"2023-08-04","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」优先队列","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#基本优先队列"},{"categories":["「算法第四版」"],"content":" 优先队列 API优先队列最重要的操作是删除最大元素和插入元素。 泛型优先队列的 API public class MaxPQ\u003cKey extends Comparable\u003cKey\u003e\u003e MaxPQ() 创建一个优先队列 MaxPQ(int max) 创建一个初始容量为 max 的优先队列 MaxPQ(Key a) 用 a[] 中的元素创建一个优先队列 void insert(Key v) 向优先队列中插入一个元素 Key max() 返回最大元素 Key delMax() 删除并返回最大元素 boolean isEmpty() 返回队列是否为空 int size() 返回优先队列中的元素个数 ","date":"2023-08-04","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:1:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」优先队列","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#优先队列-api"},{"categories":["「算法第四版」"],"content":" 优先队列的基本实现数据结构二叉堆能够很好地实现优先队列的基本操作。 堆的定义与表示二叉堆：一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）。 堆有序：当一颗二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。 堆的表示 堆的算法优先队列由一个基于堆的完全二叉树表示，存储于数组 pq[1..N] 中，pq[0] 没有使用。 在 insert 中，将 n 加一并把新元素添加在数组最后，然后用 swim 保证堆有序。 在 delMax 中，从 pq[1] 中得到需要返回的元素，然后将 pq[N] 移动到 pq[1]，将 N 减一并用 sink 保证堆有序。 public class MaxPQ\u003cKey extends Comparable\u003cKey\u003e\u003e { private Key[] pq; // store items at indices 1 to n private int n; // number of items on priority queue public MaxPQ() { this(1); } public MaxPQ(int initCapacity) { pq = (Key[]) new Object[initCapacity + 1]; n = 0; } public MaxPQ(Key[] keys) { n = keys.length; pq = (Key[]) new Object[keys.length + 1]; for (int i = 0; i \u003c n; i++) pq[i + 1] = keys[i]; for (int k = n / 2; k \u003e= 1; k--) sink(k); } public void insert(Key x) { // double size of array if necessary if (n == pq.length - 1) resize(2 * pq.length); // add x, and percolate it up to maintain heap invariant pq[++n] = x; swim(n); } public Key max() { if (isEmpty()) throw new NoSuchElementException(\"Priority queue underflow\"); return pq[1]; } public Key delMax() { if (isEmpty()) throw new NoSuchElementException(\"Priority queue underflow\"); Key max = pq[1]; exch(1, n--); sink(1); pq[n + 1] = null; // to avoid loitering and help with garbage collection if ((n \u003e 0) \u0026\u0026 (n == (pq.length - 1) / 4)) resize(pq.length / 2); return max; } public boolean isEmpty() { return n == 0; } public int size() { return n; } private void resize(int capacity) { assert capacity \u003e n; Key[] temp = (Key[]) new Object[capacity]; for (int i = 1; i \u003c= n; i++) { temp[i] = pq[i]; } pq = temp; } /*************************************************************************** * Helper functions to restore the heap invariant. ***************************************************************************/ private void swim(int k) { while (k \u003e 1 \u0026\u0026 less(k / 2, k)) { exch(k / 2, k); k = k / 2; } } private void sink(int k) { while (2 * k \u003c= n) { int j = 2 * k; if (j \u003c n \u0026\u0026 less(j, j + 1)) j++; if (!less(k, j)) break; exch(k, j); k = j; } } /*************************************************************************** * Helper functions for compares and swaps. ***************************************************************************/ private boolean less(int v, int w) { return pq[v].compareTo(pq[w]) \u003c 0; } private void exch(int v, int w) { Key swap = pq[v]; pq[v] = pq[w]; pq[w] = swap; } } ","date":"2023-08-04","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:1:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」优先队列","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#优先队列的基本实现"},{"categories":["「算法第四版」"],"content":" 优先队列的基本实现数据结构二叉堆能够很好地实现优先队列的基本操作。 堆的定义与表示二叉堆：一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）。 堆有序：当一颗二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。 堆的表示 堆的算法优先队列由一个基于堆的完全二叉树表示，存储于数组 pq[1..N] 中，pq[0] 没有使用。 在 insert 中，将 n 加一并把新元素添加在数组最后，然后用 swim 保证堆有序。 在 delMax 中，从 pq[1] 中得到需要返回的元素，然后将 pq[N] 移动到 pq[1]，将 N 减一并用 sink 保证堆有序。 public class MaxPQ","date":"2023-08-04","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:1:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」优先队列","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#堆的定义与表示"},{"categories":["「算法第四版」"],"content":" 优先队列的基本实现数据结构二叉堆能够很好地实现优先队列的基本操作。 堆的定义与表示二叉堆：一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）。 堆有序：当一颗二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。 堆的表示 堆的算法优先队列由一个基于堆的完全二叉树表示，存储于数组 pq[1..N] 中，pq[0] 没有使用。 在 insert 中，将 n 加一并把新元素添加在数组最后，然后用 swim 保证堆有序。 在 delMax 中，从 pq[1] 中得到需要返回的元素，然后将 pq[N] 移动到 pq[1]，将 N 减一并用 sink 保证堆有序。 public class MaxPQ","date":"2023-08-04","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:1:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」优先队列","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#堆的算法"},{"categories":["「算法第四版」"],"content":" 优先队列的应用一个基本的优先队列应用是在庞大的输入中找出最大(最小)的元素。 public class TopM { public static void main(String[] args) { int m = Integer.parseInt(args[0]); MinPQ\u003cTransaction\u003e pq = new MinPQ\u003c\u003e(m + 1); while (StdIn.hasNextLine()) { // Create an entry from the next line and put on the PQ. String line = StdIn.readLine(); Transaction transaction = new Transaction(line); pq.insert(transaction); // remove minimum if m+1 entries on the PQ if (pq.size() \u003e m) pq.delMin(); } // top m entries are on the PQ // print entries on PQ in reverse order Stack\u003cTransaction\u003e stack = new Stack\u003c\u003e(); for (Transaction transaction : pq) stack.push(transaction); for (Transaction transaction : stack) StdOut.println(transaction); } } ","date":"2023-08-04","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:1:3","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」优先队列","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#优先队列的应用"},{"categories":["「算法第四版」"],"content":" 索引优先队列在很多应用中，允许用例引用已经进入优先队列中的元素是有必要的（允许用例访问在优先队列中的任意元素）。 理解这种数据结构的一个方法是：将它看成一个能够快速访问其中最小元素的数组。 ","date":"2023-08-04","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」优先队列","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#索引优先队列"},{"categories":["「算法第四版」"],"content":" 索引优先队列 API 泛型优先队列的 API public class IndexMinPQ\u003cItem extends Comparable\u003cItem\u003e\u003e IndexMinPQ(int maxN) 创建一个最大容量为 maxN 的优先队列 索引的取值范围为 0 至 maxN - 1 void insert(int k, Item item) 插入一个元素，将它和索引 k 相关联 void change(int k, Item item) 将索引 k 的元素设为 item boolean contains(int k) 是否存在索引为 k 的元素 void delete(int k) 删去索引 k 及其相关联的元素 Item min() 返回最小元素 int minIndex() 返回最小元素的索引 int delMin() 删除最小元素并返回它的索引 boolean isEmpty() 返回队列是否为空 int size() 返回优先队列中的元素个数 ","date":"2023-08-04","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」优先队列","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#索引优先队列-api"},{"categories":["「算法第四版」"],"content":" 索引优先队列的实现 public class IndexMinPQ\u003cKey extends Comparable\u003cKey\u003e\u003e { /** * keys: 所有元素存储在 keys 数组中，并与索引进行绑定 * pq : 索引二叉堆 * qp : 存储索引的索引，qp[i] 表示 keys[i] 元素对应的索引在 pq 的位置(索引) * 即对于索引为 i 的元素 pq[qp[i]] = i * * 为什么需要记录元素索引的索引？ * 在 deleteMin / changeKey 方法中变更任意元素 keys[i] * 可以直接通过 qp[i] 获取索引在二叉堆 pq 中的位置(索引的索引) */ private int maxN; // maximum number of elements on PQ private int n; // number of elements on PQ private int[] pq; // binary heap using 1-based indexing private int[] qp; // inverse of pq - qp[pq[i]] = pq[qp[i]] = i private Key[] keys; // keys[i] = priority of i public IndexMinPQ(int maxN) { if (maxN \u003c 0) throw new IllegalArgumentException(); this.maxN = maxN; n = 0; keys = (Key[]) new Comparable[maxN + 1]; pq = new int[maxN + 1]; qp = new int[maxN + 1]; for (int i = 0; i \u003c= maxN; i++) qp[i] = -1; } public void insert(int i, Key key) { validateIndex(i); if (contains(i)) throw new IllegalArgumentException(\"index is already in the priority queue\"); keys[i] = key; n++; pq[n] = i; // 将索引 i 加入到 pq[] 最后 qp[i] = n; swim(n); } public void changeKey(int i, Key key) { validateIndex(i); if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\"); keys[i] = key; swim(qp[i]); sink(qp[i]); } public boolean contains(int i) { validateIndex(i); return qp[i] != -1; } public void delete(int i) { validateIndex(i); if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\"); int index = qp[i]; exch(index, n--); swim(index); sink(index); keys[i] = null; qp[i] = -1; } public Key minKey() { if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\"); return keys[pq[1]]; } public int minIndex() { if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\"); return pq[1]; } public int delMin() { if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\"); int min = pq[1]; exch(1, n--); sink(1); assert min == pq[n + 1]; qp[min] = -1; // delete keys[min] = null; // to help with garbage collection pq[n + 1] = -1; // not needed return min; } public Key keyOf(int i) { validateIndex(i); if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\"); return keys[i]; } public boolean isEmpty() { return n == 0; } public int size() { return n; } private void validateIndex(int i) { if (i \u003c 0) throw new IllegalArgumentException(\"index is negative: \" + i); if (i \u003e= maxN) throw new IllegalArgumentException(\"index \u003e= capacity: \" + i); } /*************************************************************************** * Heap helper functions. ***************************************************************************/ private void swim(int k) { while (k \u003e 1 \u0026\u0026 greater(k / 2, k)) { exch(k, k / 2); k = k / 2; } } private void sink(int k) { while (2 * k \u003c= n) { int j = 2 * k; if (j \u003c n \u0026\u0026 greater(j, j + 1)) j++; if (!greater(k, j)) break; exch(k, j); k = j; } } /*************************************************************************** * General helper functions. ***************************************************************************/ private boolean greater(int v, int w) { return keys[pq[v]].compareTo(keys[pq[w]]) \u003e 0; } private void exch(int v, int w) { int swap = pq[v]; pq[v] = pq[w]; pq[w] = swap; // 索引 pq[v] 与 pq[w] 交换，此时 pq[v] 指向 keys[w], pq[w] 指向 keys[v] qp[pq[v]] = v; qp[pq[w]] = w; } } ","date":"2023-08-04","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」优先队列","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#索引优先队列的实现"},{"categories":["「算法第四版」"],"content":" 索引优先队列用例多向归并问题：将多个有序的输入流归并成一个有序的输出流。 使用优先队列解决多向归并问题，无论输入有多长都可以将其全部读入并排序。 public class Multiway { public static void merge(In[] streams) { // 每个输入流对应索引优先队列的一个索引 int N = streams.length; IndexMinPQ\u003cString\u003e pq = new IndexMinPQ\u003c\u003e(N); // 每个输入流的索引都关联一个元素（输入中的下一个字符串） for (int i = 0; i \u003c N; i++) if (!streams[i].isEmpty()) pq.insert(i, streams[i].readString()); // 删除并打印出队列中最小字符串 // 然后将该输入的下一个字符串添加到优先队列 while (!pq.isEmpty()) { StdOut.println(pq.min()); int i = pq.delMin(); if (!streams[i].isEmpty()) pq.insert(i, streams[i].readString()); } } public static void main(String[] args) { int N = args.length; In[] streams = new In[N]; for (int i = 0; i \u003c N; i++) streams[i] = new In(args[i]); merge(streams); } } ","date":"2023-08-04","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:3","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」优先队列","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#索引优先队列用例"},{"categories":["「算法第四版」"],"content":" 堆排序堆排序算法：堆排序算法分为两个阶段，堆的构造阶段和下沉排序阶段。 在堆的构造阶段，我们将原始数组重新组织安排进一个堆中。 在下沉排序阶段，我们从堆中按递减顺序取出所有元素并得到排序结果。 ","date":"2023-08-04","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」优先队列","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#堆排序"},{"categories":["「算法第四版」"],"content":" 堆的构造构造堆的一个高效方法是使用 sink 方法从右至左构造子堆。如果一个结点的两个子结点已经是堆了，那么在该结点上调用 sink 方法可以将它们变成一个堆。 开始时我们只需要扫描数组中的一半元素，因为我们可以提哦啊过大小为 1 的子堆。最后我们在位置 1 上调用 sink 方法，堆构造结束。 ","date":"2023-08-04","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」优先队列","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#堆的构造"},{"categories":["「算法第四版」"],"content":" 下沉排序我们将堆中的最大元素删除，然后放入堆缩小后数组中空出的位置，直至销毁堆，下沉排序完成。 public class Heap { public static void sort(Comparable[] pq) { int n = pq.length; // heapify phase for (int k = n/2; k \u003e= 1; k--) sink(pq, k, n); // sortdown phase int k = n; while (k \u003e 1) { exch(pq, 1, k--); sink(pq, 1, k); } } } ","date":"2023-08-04","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」优先队列","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#下沉排序"},{"categories":["「算法第四版」"],"content":" 先下沉后上浮（Floyd 优化）大多数在下沉排序期间重新插入堆的元素会下沉到堆底。 通过先下沉后上浮，我们正好可以通过免去检查元素是否到达正确的位置来节省时间。在下沉过程中总是直接提升较大的子结点直至到达堆底。然后再使元素上浮到正确的位置。 这种方法可以将比较次数减少一半，接近归并排序所需的比较次数。 public class FloydHeap { public static void sort(Comparable[] pq) { int n = pq.length; // heapify phase for (int k = n / 2; k \u003e= 1; k--) sink(pq, k, n); // sortdown phase int k = n; while (k \u003e 1) { exch(pq, 1, k--); sinkThenSwim(pq, 1, k); } } private static void sink(Comparable[] pq, int k, int n) { while (2 * k \u003c= n) { int j = 2 * k; if (j \u003c n \u0026\u0026 less(pq, j, j + 1)) j++; if (!less(pq, k, j)) break; exch(pq, k, j); k = j; } } private static void swim(Comparable[] pq, int k) { while (k \u003e 1 \u0026\u0026 less(pq, k / 2, k)) { exch(pq, k, k / 2); k /= 2; } } private static void sinkThenSwim(Comparable[] pq, int k, int n) { while (2 * k \u003c= n) { int j = 2 * k; if (j \u003c n \u0026\u0026 less(pq, j, j + 1)) j++; // 免去检查元素是否到达正确位置 // if (!less(pq, k, j)) break; exch(pq, k, j); k = j; } // swim 到正确位置 swim(pq, k); } } ","date":"2023-08-04","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:3:3","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」优先队列","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_09_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#先下沉后上浮floyd-优化"},{"categories":["「汇编语言」"],"content":"「汇编语言」寄存器(内存访问)","date":"2023-08-03","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器(内存访问)","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/"},{"categories":["「汇编语言」"],"content":" 内存中字的存储CPU 中，用 16 位寄存器来存储一个字。高 8 位存放高位字节，低 8 位存放低位字节。 字单元：即存放一个字型数据(16 位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。 ","date":"2023-08-03","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/:1:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器(内存访问)","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/#内存中字的存储"},{"categories":["「汇编语言」"],"content":" DS 和 [address]8086CPU 中有一个 DS 寄存器，通常用来存放要访问数据的段地址。 比如我们需要读取 10000H 单元的内容，并将数据读到 al 中。代码如下： ; 8086CPU 不支持将数据直接送入段寄存器的操作（硬件设计问题） ; 需要使用一个寄存器进行中转 mov bx,1000H mov ds,bx ; 完成数据从 1000:0 单元到 al 的传送 ; 指令执行时，8086CPU 自动取 ds 中的数据为内存单元的段地址 mov al,[0] ","date":"2023-08-03","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/:2:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器(内存访问)","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/#ds-和-address"},{"categories":["「汇编语言」"],"content":" 字的传送只要在 mov 指令中给出 16 位的寄存器就可以进行 16 位数据的传送： mov bx,1000H mov ds,bx mov ax,[0] ; 1000:0 处的字型数据送入 ax mov [0],cx ; cx 中的 16 位数据送到 1000:0 处 ","date":"2023-08-03","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/:3:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器(内存访问)","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/#字的传送"},{"categories":["「汇编语言」"],"content":" mov、add、sub 指令mov、add、sub 指令可以有以下几种形式（以 mov 指令举例）： 指令形式 指令案例 mov 寄存器，数据 mov ax,8 mov 寄存器，寄存器 mov ax,bx mov 寄存器，内存单元 mov ax,[0] mov 内存单元，寄存器 mov [0],ax mov 段寄存器，寄存器 mov ds,ax mov 寄存器，段寄存器 mov ax,ds mov 段寄存器，内存单元 mov cs,[0] mov 内存单元，段寄存器 mov [0],cs ","date":"2023-08-03","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/:4:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器(内存访问)","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/#movaddsub-指令"},{"categories":["「汇编语言」"],"content":" 数据段我们可以将一组长度为 N( ≤ 64 KB )、地址连续、起始地址为 16 的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。 将一段内存当作数据段，也是我们在编程时的一种安排，与代码段类似。 ","date":"2023-08-03","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/:5:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器(内存访问)","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/#数据段"},{"categories":["「汇编语言」"],"content":" CPU 提供的栈机制栈是一种具有特殊的访问方式的存储空间。最后进入这个空间的数据，最先出去。 8086CPU 提供相关的指令来以栈的方式访问内存空间。在基于 8086CPU 编程的时候，可以将一段内存当作栈来使用。 8086CPU 提供入栈和出栈指令，最基本的两个是 PUSH(入栈) 和 POP(出栈)。8086CPU 的入栈和出栈操作以字为单位进行的。 8086CPU 中，有两个寄存器，段寄存器 SS 和寄存器 SP，栈顶的段地址存放 在 SS 中，偏移地址存放在 SP 中。任意时刻，SS:SP 指向栈顶元素。push 指令和 pop 指令执行时，CPU 从 SS 和 SP 中得到栈顶的地址。 ","date":"2023-08-03","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/:6:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器(内存访问)","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/#cpu-提供的栈机制"},{"categories":["「汇编语言」"],"content":" PUSH 操作push ax 的执行，由以下两步完成： SP = SP - 2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶； 将 ax 中的内容送入 SS:SP 指向的内存单元处，SS:SP 此时指向新栈顶。 PUSH 指令执行过程 ","date":"2023-08-03","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/:6:1","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器(内存访问)","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/#push-操作"},{"categories":["「汇编语言」"],"content":" POP 操作pop ax 的执行过程和 push ax 相反，由以下两步完成： 将 SS:SP 指向的内存单元处的数据送入 ax 中； SP = SP + 2，SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。 POP 指令执行过程 ","date":"2023-08-03","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/:6:2","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器(内存访问)","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/#pop-操作"},{"categories":["「汇编语言」"],"content":" 栈空时 SS:SP 的指向任意时刻，SS:SP 指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以 SS:SP 只能指向栈的最底部单元下面的单元，该单元的偏移地为栈最底部的字单元的偏移地址 + 2。 栈空的状态 ","date":"2023-08-03","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/:6:3","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器(内存访问)","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/#栈空时-sssp-的指向"},{"categories":["「汇编语言」"],"content":" 栈顶超界问题当栈满的时候 再使用 push 指令入栈，或栈空的时候再使用 pop 指令出栈，都将发生栈顶超界问题。 8086CPU 不保证我们对栈的操作不会超界，在编程的时候要自己操心栈顶超界的问题。 ","date":"2023-08-03","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/:6:4","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器(内存访问)","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/#栈顶超界问题"},{"categories":["「汇编语言」"],"content":" PUSH、POP 指令 指令形式 指令案例 指令说明 push 寄存器 push ax 将一个奇存器中的数据入栈 pop 寄存器 pop ax 出栈，用一个寄存器接收出栈的数据 push 段寄存器 push ds 将一个段寄存器中的数据入栈 pop 段寄存器 pop cs 出栈，用一个段寄存器接收出栈的数据 push 内存单元 push [0] 将一个内存字单元处的字入栈(注意:栈操作都是以字为单位) pop 内存单元 pop [0] 出栈，用 一个内存字单元按收出栈的数据 push、pop 实质上就是一种内存传送指令，可以在寄存器和内存之间或内存和内存之间传送数据，与 mov 指令不同的是，push 和 pop 指令访问的内存单元的地址不是在指令中给出的，而是由 SS:SP 指出的。 CPU 执行 mov 指令只需一步操作，就是传送；而执行 push、pop 指令需要两步操作： 执行push时，CPU 的两步操作是：先改变 SP，后向 SS:SP 处传送 执行 pop 时，CPU 的两步操作是：先读取 SS:SP 处的数据，后改变SP 提供：SS、SP 指示栈顶；改变 SP 后写内存的入栈指令；读内存后改变 SP 的出栈指令。这就是 8086CPU 提供的栈操作机制。 ","date":"2023-08-03","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/:7:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器(内存访问)","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/#pushpop-指令"},{"categories":["「汇编语言」"],"content":" 段的综述我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排： 我们可以用一个段存放数据，将它定义为“数据段”； 我们可以用一个段存放代码，将它定义为“代码段”； 我们可以用一个段当作栈，将它定义为“栈段”。 对于数据段，将它的段地址放在 DS 中，用 mov、add、sub 等访问内存单元的指令时，CPU 就将我们定义的数据段中的内容当作数据来访问。 对于代码段，将它的段地址放在 CS 中，将段中第一条指令的偏移地址放在 IP 中，这样 CPU 就将执行我们定义的代码段中的指令。 对于栈段，将它的段地址放在 SS 中，将栈顶单元的偏移地址放在 SP 中，这样 CPU 在需要进行栈操作的时候，比如执行 push、pop 指令等，就将我们定义的栈段当作栈空间来用。 一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于CPU中寄存器的设置，即 CS、IP，SS、SP，DS 的指向。 ","date":"2023-08-03","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/:8:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器(内存访问)","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_03_%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/#段的综述"},{"categories":["Redis"],"content":"阅读 Redis 事件驱动框架代码，理解 Redis 是如何处理客户端请求的。","date":"2023-07-27","objectID":"/redis_01_%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/","series":["Redis源码阅读"],"tags":["Redis"],"title":"Redis 事件驱动框架","uri":"/redis_01_%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/"},{"categories":["Redis"],"content":" Redis 事件循环的主要功能 接受新的客户端连接 响应客户端连接命令 ","date":"2023-07-27","objectID":"/redis_01_%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/:1:0","series":["Redis源码阅读"],"tags":["Redis"],"title":"Redis 事件驱动框架","uri":"/redis_01_%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/#redis-事件循环的主要功能"},{"categories":["Redis"],"content":" 事件循环的初始化Redis 启动时会创建事件循环数据结构。 // src/server.c void initServer(void) { // ... server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR); if (server.el == NULL) { serverLog(LL_WARNING, \"Failed creating the event loop. Error message: '%s'\", strerror(errno)); exit(1); } // ... } aeCreateEventLoop 初始化并返回 aeEventLoop 数据结构。 aeEventLoop 数据结构中两个最重要的域：aeFileEvent *events 和 aeFiredEvent *fired。 // src/ae.h /* State of an event based program */ typedef struct aeEventLoop { int maxfd; /* highest file descriptor currently registered */ int setsize; /* max number of file descriptors tracked */ long long timeEventNextId; aeFileEvent *events; /* Registered events */ aeFiredEvent *fired; /* Fired events */ aeTimeEvent *timeEventHead; int stop; void *apidata; /* This is used for polling API specific data */ aeBeforeSleepProc *beforesleep; aeBeforeSleepProc *aftersleep; int flags; } aeEventLoop; ","date":"2023-07-27","objectID":"/redis_01_%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/:2:0","series":["Redis源码阅读"],"tags":["Redis"],"title":"Redis 事件驱动框架","uri":"/redis_01_%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/#事件循环的初始化"},{"categories":["Redis"],"content":" 事件处理器是如何注册的？事件循环有两个主要事件需要处理： 新的连接建立并可用 现有连接进入可读状态 事件循环初始化后，会在事件循环中注册一个 aeFileProc *accept_handler，该事件处理器会在新的连接建立时执行。 // src/server.c /* Create an event handler for accepting new connections in TCP or TLS domain sockets. * This works atomically for all socket fds */ int createSocketAcceptHandler(connListener *sfd, aeFileProc *accept_handler) { int j; for (j = 0; j \u003c sfd-\u003ecount; j++) { if (aeCreateFileEvent(server.el, sfd-\u003efd[j], AE_READABLE, accept_handler,sfd) == AE_ERR) { /* Rollback */ for (j = j-1; j \u003e= 0; j--) aeDeleteFileEvent(server.el, sfd-\u003efd[j], AE_READABLE); return C_ERR; } } return C_OK; } 在连接已经建立后，会为连接设置一个读事件处理器。 // src/connection.h /* Register a read handler, to be called when the connection is readable. * If NULL, the existing handler is removed. */ static inline int connSetReadHandler(connection *conn, ConnectionCallbackFunc func) { return conn-\u003etype-\u003eset_read_handler(conn, func); } ","date":"2023-07-27","objectID":"/redis_01_%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/:3:0","series":["Redis源码阅读"],"tags":["Redis"],"title":"Redis 事件驱动框架","uri":"/redis_01_%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/#事件处理器是如何注册的"},{"categories":["Redis"],"content":" 如何触发事件处理器？Redis 使用操作系统的多路复用 IO 来等待事件。 // src/ae.h /* Include the best multiplexing layer supported by this system. * The following should be ordered by performances, descending. */ #ifdef HAVE_EVPORT #include \"ae_evport.c\" #else #ifdef HAVE_EPOLL #include \"ae_epoll.c\" #else #ifdef HAVE_KQUEUE #include \"ae_kqueue.c\" #else #include \"ae_select.c\" #endif #endif #endif 事件循环启动，会一直进行循环并执行已经就绪的事件。 // src.ae.c void aeMain(aeEventLoop *eventLoop) { eventLoop-\u003estop = 0; while (!eventLoop-\u003estop) { aeProcessEvents(eventLoop, AE_ALL_EVENTS| AE_CALL_BEFORE_SLEEP| AE_CALL_AFTER_SLEEP); } } 当事件已就绪，会被放置在 aeFiredEvent *fired 域。 // src/ae.h /* State of an event based program */ typedef struct aeEventLoop { // ... aeFileEvent *events; /* Registered events */ aeFiredEvent *fired; /* Fired events */ // ... } aeEventLoop; aeProcessEvents 从 aeFiredEvent *fired 域中读取事件。 // src/ae.c /* Process every pending time event, then every pending file event * (that may be registered by time event callbacks just processed). * Without special flags the function sleeps until some file event * fires, or when the next time event occurs (if any). * * If flags is 0, the function does nothing and returns. * if flags has AE_ALL_EVENTS set, all the kind of events are processed. * if flags has AE_FILE_EVENTS set, file events are processed. * if flags has AE_TIME_EVENTS set, time events are processed. * if flags has AE_DONT_WAIT set, the function returns ASAP once all * the events that can be handled without a wait are processed. * if flags has AE_CALL_AFTER_SLEEP set, the aftersleep callback is called. * if flags has AE_CALL_BEFORE_SLEEP set, the beforesleep callback is called. * * The function returns the number of events processed. */ int aeProcessEvents(aeEventLoop *eventLoop, int flags) { // ... /* Call the multiplexing API, will return only on timeout or when * some event fires. */ numevents = aeApiPoll(eventLoop, tvp); // ... for (j = 0; j \u003c numevents; j++) { int fd = eventLoop-\u003efired[j].fd; aeFileEvent *fe = \u0026eventLoop-\u003eevents[fd]; int mask = eventLoop-\u003efired[j].mask; int fired = 0; /* Number of events fired for current fd. */ /* Normally we execute the readable event first, and the writable * event later. This is useful as sometimes we may be able * to serve the reply of a query immediately after processing the * query. * * However if AE_BARRIER is set in the mask, our application is * asking us to do the reverse: never fire the writable event * after the readable. In such a case, we invert the calls. * This is useful when, for instance, we want to do things * in the beforeSleep() hook, like fsyncing a file to disk, * before replying to a client. */ int invert = fe-\u003emask \u0026 AE_BARRIER; /* Note the \"fe-\u003emask \u0026 mask \u0026 ...\" code: maybe an already * processed event removed an element that fired and we still * didn't processed, so we check if the event is still valid. * * Fire the readable event if the call sequence is not * inverted. */ if (!invert \u0026\u0026 fe-\u003emask \u0026 mask \u0026 AE_READABLE) { fe-\u003erfileProc(eventLoop,fd,fe-\u003eclientData,mask); fired++; fe = \u0026eventLoop-\u003eevents[fd]; /* Refresh in case of resize. */ } /* Fire the writable event. */ if (fe-\u003emask \u0026 mask \u0026 AE_WRITABLE) { if (!fired || fe-\u003ewfileProc != fe-\u003erfileProc) { fe-\u003ewfileProc(eventLoop,fd,fe-\u003eclientData,mask); fired++; } } /* If we have to invert the call, fire the readable event now * after the writable one. */ if (invert) { fe = \u0026eventLoop-\u003eevents[fd]; /* Refresh in case of resize. */ if ((fe-\u003emask \u0026 mask \u0026 AE_READABLE) \u0026\u0026 (!fired || fe-\u003ewfileProc != fe-\u003erfileProc)) { fe-\u003erfileProc(eventLoop,fd,fe-\u003eclientData,mask); fired++; } } } // ... } fe-\u003erfileProc 会调用在 aeCreateFileEvent 注册的事件处理器。 // src/ae.c int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask, aeFileProc *proc, void *clientData) { // ... aeFileEvent *fe = \u0026eventLoop-\u003eevents[fd]; // ... if (mask \u0026 AE_READABLE) fe-\u003erfileProc = proc; if (mask \u0026 AE_WRITABLE) fe-\u003ewfileProc = proc; // ... } 事件循环会一直循环执行： 等待事件就绪 执行 fired 事件的处理器 重复… ","date":"2023-07-27","objectID":"/redis_01_%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/:4:0","series":["Redis源码阅读"],"tags":["Redis"],"title":"Redis 事件驱动框架","uri":"/redis_01_%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/#如何触发事件处理器"},{"categories":["Redis"],"content":"阅读 Redis 代码，学习代码设计。","date":"2023-07-26","objectID":"/redis_00_%E5%BC%80%E7%AF%87/","series":["Redis源码阅读"],"tags":["Redis"],"title":"Redis 代码阅读开篇","uri":"/redis_00_%E5%BC%80%E7%AF%87/"},{"categories":["Redis"],"content":" 为什么要阅读 Redis 源码 更加深刻地理解 Redis 以及在使用 Redis 出现故障时能够更好地定位问题； 提升系统设计能力与编程水平。 ","date":"2023-07-26","objectID":"/redis_00_%E5%BC%80%E7%AF%87/:1:0","series":["Redis源码阅读"],"tags":["Redis"],"title":"Redis 代码阅读开篇","uri":"/redis_00_%E5%BC%80%E7%AF%87/#为什么要阅读-redis-源码"},{"categories":["「汇编语言」"],"content":"「汇编语言」寄存器","date":"2023-07-16","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/"},{"categories":["「汇编语言」"],"content":"CPU 由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。内部总线实现 CPU 内部各个器件之间的联系，外部总线实现 CPU 和主板上其他器件的联系。 在 CPU 中： 运算器进行信息处理； 寄存器进行信息存储； 控制器控制各种器件进行工作； 内部总线连接各种器件，在它们之间进行数据的传送。 ","date":"2023-07-16","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/:0:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/#"},{"categories":["「汇编语言」"],"content":" 通用寄存器8086CPU 的所有寄存器都是 16 位的，可以存放两个字节。AX、BX、CX、DX 这 4 个寄存器通常用来存放一般性的数据，被称为通用寄存器。 8086CPU 的 AX、BX、CX 、DX 这 4 个寄存器都可分为两个可独立使用的 8 位寄存器来使用。 ","date":"2023-07-16","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/:1:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/#通用寄存器"},{"categories":["「汇编语言」"],"content":" 字在寄存器中的存储字节：记为 byte，一个字节由 8 个 bit 组成，可以存在 8 位寄存器中。 字：记为 word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节。 AX 寄存器： 高位字节 AH 低位字节 AL 0 1 0 0 1 1 1 0 | 0 0 1 0 0 0 0 0 ","date":"2023-07-16","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/:2:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/#字在寄存器中的存储"},{"categories":["「汇编语言」"],"content":" 几条汇编指令 汇编指令 控制 CP U 完成的操作 用高级语言的语法描述 mov ax,18 将 18 送入寄存器 AX AX = 18 mov ah,78 将 78 送入寄存器 AH AH = 78 add ax,8 将寄存器 AX 中的数值加上 8 AX = AX + 8 mov ax,bx 将寄存器 BX 中的数据送入寄存器 AX AX = BX add ax,bx 将 AX 和 BX 中的数值相加，结果存在 AX 中 AX = AX + BX ","date":"2023-07-16","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/:3:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/#几条汇编指令"},{"categories":["「汇编语言」"],"content":" 8086CPU 给出物理地址的方法","date":"2023-07-16","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/:4:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/#8086cpu-给出物理地址的方法"},{"categories":["「汇编语言」"],"content":" 物理地址的概念CPU 访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。 CPU 通过地址总线送入存储器的，必须是一个内存单元的物理地址。在 CPU 向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的 CPU 可以有不同的形成物理地址的方式。 ","date":"2023-07-16","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/:4:1","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/#物理地址的概念"},{"categories":["「汇编语言」"],"content":" 8086CPU 的结构8086CPU 是 16 位结构的 CPU： 运算器一次最多可以处理 16 位的数据； 寄存器的最大宽度为 16 位； 寄存器和运算器之间的通路为 16 位。 内存单元的地址在送上地址总线之前，必须在 CPU 中处理、传输、暂时存放，对于 16 位 CPU，能一次性处理、传输、暂时存储 16 位的地址。 8086CPU 有 20 位地址总线，可以传送 20 位地址，达到 1MB 寻址能力。 ","date":"2023-07-16","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/:4:2","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/#8086cpu-的结构"},{"categories":["「汇编语言」"],"content":" 8086CPU 生成物理地址的过程8086CPU 采用一种在内部用两个 16 位地址合成的方法来形成一个 20 位的物理地址: CPU 中的相关部件提供两个 16 位的地址，一个称为段地址，另一个称为偏移地址； 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件； 地址加法器将两个 16 位地址合成为一个 20 位的物理地址； 地址加法器通过内部总线将 20 位物理地址送入输入输出控制电路； 输入输出控制电路将 20 位物理地址送上地址总线； 20 位物理地址被地址总线传送到存储器。 8086CPU 相关部件的逻辑结构 地址加法器采用 物理地址 = 段地址 × 16 + 偏移地址 的方法用段地址和偏移地址合成物理地址。 “段地址 × 16 + 偏移地址 = 物理地址” 的本质含义是：CPU 在访问内存时，用一个基础地址(段地址 × 16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。 内存并没有分段，段的划分来自于 CPU，由于 8086CPU 用 “基础地址(段地址 x 16) + 偏移地址 = 物理地址” 的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。 “基础地址 = 段地址 x 16”，因此段的起始地址也一定 16 的倍数；偏移地址为 16 位 ，16 位地址的寻址能力为 64KB ，所以一个段的长度最大为 64KB。 ","date":"2023-07-16","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/:4:3","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/#8086cpu-生成物理地址的过程"},{"categories":["「汇编语言」"],"content":" CS 和 IP段地址在 8086CPU 的段寄存器中存放。8086CPU 有 4 个段寄存器：CS、DS、SS、ES。 CS 和 IP 是8086CPU 中两个最关键的寄存器，它们指示了 CPU 当前要读取指令的地址。CS 为代码段寄存器，IP 为指令指针寄存器。 8086 机中，任意时刻，CPU 将 CS:IP 指向的内容当作指令执行。 8086PC 读取和执行指令的相关部件 8086CPU 读取、执行一条指令的详细过程： CS、IP 中的内容送入地址加法器，地址加法器计算物理地址； 地址加法器将物理地址送入输入输出控制电路； 输入输出控制电路将物理地址送上地址总线； 从物理地址对应的内存单元中获取机器指令，将机器指令通过数据总线被送入 CPU； 输入输出控制电路将机器指令送入指令缓冲器； 读取一条指令后，IP 中的值自动増加，值为所读取指令的长度，以使 CPU 可以读取下一条指令； 执行控制器执行指令。转到步骤 1，重复这个过程。 8086CPU 读取、执行一条指令的简要过程描述： 从 CS:IP 指向的内存单元读取指令，读取的指令进入指令缓冲器； IP = IP + 所读取指令的长度，从而指向下一条指令； 操作执行器执行指令。转到步骤 1，重复这个过程。 在 8086CPU 加电启动或复位后(即 CPU 刚开始工作时) CS 和 IP 被设置为 CS=FFFFH，IP=0000H，即在 8086PC 机刚启动时，CPU 从内存 FFFFOH 单元中读取指令执行，FFFFOH 单元中的指令是 8086PC 机开机后执行的第一条指令。 在内存中，指令和数据没有任何区别，都是二进制信息，CPU 在工作的时候把有的信息看作指令，有的信息看作数据。CPU 将 CS、IP 中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。 ","date":"2023-07-16","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/:5:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/#cs-和-ip"},{"categories":["「汇编语言」"],"content":" 修改 CS、IP 的指令程序员可以通过改变 CS、IP 中的内容来控制 CPU 执行目标指令。 mov 指令不能用于设置 CS、IP 的值，mov 指令被称为传送指令。 jmp 指令可以用于设置 CS、IP 的值。能够改变 CS、IP 的 内容的指令被统称为转移指令。 jmp 指令用法 jmp 指令案例 jmp 指令功能 jmp 段地址:偏移地址 jmp 2AE3:3 执行后：CS=2AE3H，IP=0003H 同时修改 CS、IP 的内容 ｜ jmp 某一合法奇存器 jmp ax 执行后：IP = AX 用寄存器中的值修改 IP ","date":"2023-07-16","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/:6:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/#修改-csip-的指令"},{"categories":["「汇编语言」"],"content":" 代码段对于 8086PC 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N（N ≤ 64KB）的一组代码，存在一组地址连续、起始地址为 16 的 倍数的内存单元中。我们可以认为，这段内存是用来存放代码的，从而定义了一个代码段。 将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。 ","date":"2023-07-16","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/:7:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」寄存器","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_02_%E5%AF%84%E5%AD%98%E5%99%A8/#代码段"},{"categories":["「汇编语言」"],"content":"「汇编语言」基础知识","date":"2023-07-10","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」基础知识","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["「汇编语言」"],"content":"汇编语言是直接在硬件之上工作的编程语言，需要了解硬件系统的结构，才能有效地应用汇编语言对其编程。 ","date":"2023-07-10","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」基础知识","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#"},{"categories":["「汇编语言」"],"content":" 机器语言机器语言是机器指令的集合，每一种微处理器由于硬件设计和内部结构的不同，都有自己的机器指令集。 机器语言由 0、1 表示高低电平，有不易阅读、不易查错、难于辨别和查错等缺点。 ","date":"2023-07-10","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」基础知识","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#机器语言"},{"categories":["「汇编语言」"],"content":" 汇编语言汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。 将汇编指令转换为机器指令的翻译程序，称为编译器。 flowchart LR AI(Assembly Instructions) MC(Machine Code) Programer --\u003e|write| AI --\u003e Compiler --\u003e MC --\u003e|run| Computer 汇编语言由以下三类指令组成： 汇编指令：机器码的助记符，有对应机器码。 伪指令：没有对应机器码，由编译器执行，计算机不执行。 其他符号：如 +、-、*、/ 等，由编译器识别，没有对应机器码。 ","date":"2023-07-10","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」基础知识","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#汇编语言"},{"categories":["「汇编语言」"],"content":" CPU 对存储器的读写","date":"2023-07-10","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」基础知识","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#cpu-对存储器的读写"},{"categories":["「汇编语言」"],"content":" 存储器、指令、数据和存储单元存储器，即内存，存放指令和数据。 指令和数据在内存或磁盘上没有任何区别，都是二进制信息。指令和数据是应用上的概念。对于同一个二进制信息，CPU 在工作时既可以将其看作指令，也可以将其看作信息。 存储单元，存储器被划分为若干个存储单元，从 0 开始顺序编号。一个存储单元可以存储一个 Byte (8 bit) 。 微机存储器的容量以字节为最小单元来计算。 1KB = 1024B ； 1MB = 1024KB ； 1GB = 1024MB ； 1TB = 1024GB 。 磁盘的容量单位同内存一样。 ","date":"2023-07-10","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:1","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」基础知识","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#存储器指令数据和存储单元"},{"categories":["「汇编语言」"],"content":" CPU 对存储器读写的流程CPU 想要进行数据的读写，必须和外部器件（芯片）进行以下三类信息交互： 地址信息：存储单元的地址； 控制信息：器件的选择，读或写的命令； 数据信息：读或写的数据。 电子计算机处理、传输的信息都是电信号，通过导线传送。连接 CPU 和其他芯片的导线称为总线，CPU 通过总线传送信息。 总线从逻辑上分为三类：地址总线、控制总线和数据总线。 CPU 从内存中读取数据的过程 CPU 从 3 号存储单元读取数据的过程： CPU 通过地址总线将地址信息 3 发出。 CPU 通过控制总线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。 存储器将 3 号单元中的数据 8 通过数据总线送入 CPU。 CPU 向 3 号单元写入数据 26 的过程： CPU 通过地址线将地址信息 3 发出。 CPU 通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入数据。 CPU 通过数据线将数据 26 送入内存的 3 号单元中。 用汇编指令表示 CPU 从 3 号存储单元读取数据：MOV AX,[3]。含义为传送 3 号单元的内容入 AX 寄存器。 寄存器是 CPU 中可以存储数据的器件，一个 CPU 中有多个寄存器。 AX 是其中一个寄存器的代号。 ","date":"2023-07-10","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:2","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」基础知识","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#cpu-对存储器读写的流程"},{"categories":["「汇编语言」"],"content":" 地址总线、数据总线和控制总线CPU 通过地址总线来指定存储器单元。一个 CPU 有 N 根地址线，则可以说这个 CPU 的地址总线宽度为 N，这样的 CPU 最多可以寻找 2^N 个内存单元。 CPU 与内存或其他器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了 CPU 与其他器件进行数据传送时的一次数据传送量。8 根数据总线一次可传送一个 8 位二进制数据 (即一个字节)。 CPU 对外部器件的控制是通过控制总线来进行的。控制总线是一些不同控制线的集合。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。 ","date":"2023-07-10","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:3","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」基础知识","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#地址总线数据总线和控制总线"},{"categories":["「汇编语言」"],"content":" 主板、接口卡和存储器芯片","date":"2023-07-10","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:4:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」基础知识","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#主板接口卡和存储器芯片"},{"categories":["「汇编语言」"],"content":" 主板和接口卡主板上有核心器件和一些主要器件，这些器件通过总线(地址总线、数据总线、控制总线)相连。这些器件有 CPU、存储器、外围芯片组、扩展插槽等。扩展插槽上一般插有 RAM 内存条和各类接口卡。 CPU 对外部设备都不能直接控制，如显示器、音箱、打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡。扩展插槽通过总线和 CPU 相连，所以接口卡也通过总线同 CPU 相连。CPU 可以直接控制这些接口卡，从而实现 CPU 对外设的间接控制。 CPU 通过总线向接口卡发送命令，接口卡根据 CPU 的命令控制外设进行工作。 ","date":"2023-07-10","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:4:1","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」基础知识","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#主板和接口卡"},{"categories":["「汇编语言」"],"content":" 存储器芯片存储器从读写属性上看分为两类：随机存储器(RAM)和只读存储器(ROM)。随机存储器可读可写，但必须带电存储，关机后存储的内容丢失：只读存储器只能读取不能写入，关机后其中的内容不丢失。 存储器从功能上分为以下 3 类： 随机存储器：用于存放供 CPU 使用的绝大部分程序和数据，一般由两个位置上的 RAM 组成，装在主板上的 RAM 和插在扩展插槽上的 RAM。 装有 BIOS 的 ROM：在主板和某些接口卡上插有存储相应 BIOS 的 ROM。例如，主板上的 ROM 中存储着主板的 BIOS(通常称为系统 BIOS)。显卡上的 ROM 中存储着显卡的 BIOS。 接口卡上的 RAM：某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有 RAM。显示卡上的 RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。 PC 机中各类存储器的逻辑连接 ","date":"2023-07-10","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:4:2","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」基础知识","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#存储器芯片"},{"categories":["「汇编语言」"],"content":" 内存地址空间一个 CPU 的地址总线宽度为10，那么可以寻址 1024 个内存单元，这 1024 个可寻到的内存单元就构成这个 CPU 的内存地址空间。内存地址空间的大小受 CPU 地址总线宽度的限制。 所有的存储器（包括主存储器、各类接口卡的存储器等）都和 CPU 的总线相连，CPU 对它们进行读或写的时候都通过控制线发出内存读写命令。CPU 在操控它们的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。 所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU 在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。 将各类存储器看作一个逻辑存储器 ","date":"2023-07-10","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:5:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」基础知识","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#内存地址空间"},{"categories":["「汇编语言」"],"content":"「汇编语言」阅读开篇","date":"2023-07-09","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」阅读开篇","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/"},{"categories":["「汇编语言」"],"content":" 前言本系列文章记录学习《汇编语言》——王爽 的知识点，为接下来系统学习操作系统打下基础。 ","date":"2023-07-09","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/:1:0","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」阅读开篇","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/#前言"},{"categories":["「汇编语言」"],"content":" 学习汇编的目的 充分获得底层编程的体验； 深刻理解机器运行程序的机理。 ","date":"2023-07-09","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/:1:1","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」阅读开篇","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/#学习汇编的目的"},{"categories":["「汇编语言」"],"content":" 学习汇编语言的重心通过学习关键指令来深入理解机器工作的基本原理，培养底层编程意识和思想。 ","date":"2023-07-09","objectID":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/:1:2","series":["「汇编语言」阅读笔记"],"tags":["「汇编语言」"],"title":"「汇编语言」阅读开篇","uri":"/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/#学习汇编语言的重心"},{"categories":["「算法第四版」"],"content":"快速排序","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"categories":["「算法第四版」"],"content":" 快速排序的优点 实现简单，适用于各种不同的输入数据，且在一般应用中比其他排序算法都要快的多； 原地排序，只需要很小的辅助栈的额外空间； 将长度为 N 的数组排序所需的时间和 N * lgN 成正比。 快速排序的缺点是非常脆弱，在实现时要非常小心才能避免低劣的性能。 ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序的优点"},{"categories":["「算法第四版」"],"content":" 快速排序基本算法 public class Quick { /** * Rearranges the array in ascending order, using the natural order. * * @param a the array to be sorted */ public static void sort(Comparable[] a) { StdRandom.shuffle(a); sort(a, 0, a.length - 1); } // quicksort the subarray from a[lo] to a[hi] private static void sort(Comparable[] a, int lo, int hi) { if (hi \u003c= lo) return; int j = partition(a, lo, hi); sort(a, lo, j - 1); sort(a, j + 1, hi); } // partition the subarray a[lo..hi] so that a[lo..j-1] \u003c= a[j] \u003c= a[j+1..hi] // and return the index j. private static int partition(Comparable[] a, int lo, int hi) { int i = lo; int j = hi + 1; Comparable v = a[lo]; while (true) { // find item on lo to swap while (less(a[++i], v)) { if (i == hi) break; } // find item on hi to swap while (less(v, a[--j])) { if (j == lo) break; // redundant since a[lo] acts as sentinel } // check if pointers cross if (i \u003e= j) break; exch(a, i, j); } // put partitioning item v at a[j] exch(a, lo, j); // now, a[lo .. j-1] \u003c= a[j] \u003c= a[j+1 .. hi] return j; } // is v \u003c w ? private static boolean less(Comparable v, Comparable w) { if (v == w) return false; // optimization when reference equals return v.compareTo(w) \u003c 0; } // exchange a[i] and a[j] private static void exch(Object[] a, int i, int j) { Object swap = a[i]; a[i] = a[j]; a[j] = swap; } } 快速排序是一种分治的排序算法。它将一个数组切分成两个子数组，将两部分独立地排序。其与归并排序是互补的。 由于切分过程总是能排定一个元素，用归纳法可以证明递归能够正确地将数组排序：如果左子数组和右子数组都是有序的，那么由左子数组、切分元素和右子数组组成的结果数组也一定是有序的。 ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序基本算法"},{"categories":["「算法第四版」"],"content":" 快速排序的性能特点由于快速排序切分方法的内循环简洁短小，相比归并排序与希尔排序，其内循环中很少移动数据，因此快速排序性能一般比其他的排序算法性能高。 快速排序的另一个特点是比较次数很少，快速排序的最好情况是每次都正好能将数组对半分。 ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序的性能特点"},{"categories":["「算法第四版」"],"content":" 快速排序的算法改进 切换到插入排序。对于小数组，快速排序比插入排序慢。因为快速排序的 sort 递归方法在小数组中也会调用自己。 三取样切分。能够使得快速排序的切分效果更好，但代价是需要计算中位数。同时可以将取样元素放在数组末尾作为“哨兵”来去掉切分方法的边界测试。 熵最优排序。一个元素全部重复的子数组不需要继续排序，但是快速排序的基础算法还会继续将它切分为更小的数组。在含有大量重复元素的数组的情况下，快速排序会使元素全部重复的子数组经常出现，这部分的优化能够将当前线性对数级的性能提高到线性级别。 ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:4:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序的算法改进"},{"categories":["「算法第四版」"],"content":" 快速排序的哨兵 public class QuickSentinel { public static void sort(Comparable[] a) { if (a == null || a.length \u003c 2) return; // 将数组的最大元素放在最右边作为哨兵，除非和相等的元素交换，否则该元素永远不会移动 int maxIndex = 0; for (int i = 1; i \u003c a.length; i++) { if (less(a[maxIndex], a[i])) { maxIndex = i; } } exch(a, maxIndex, a.length - 1); sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { if (lo \u003e= hi) return; int mid = partition(a, lo, hi); sort(a, lo, mid - 1); sort(a, mid + 1, hi); } private static int partition(Comparable[] a, int lo, int hi) { int i = lo, j = hi + 1; Comparable pivot = a[lo]; while (true) { while (less(a[++i], pivot)) { // 切分元素本身就是哨兵 } while (less(pivot, a[--j])) { // 右侧哨兵取消边界检查 } if (i \u003e= j) break; exch(a, i, j); } exch(a, lo, j); return j; } } ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:4:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序的哨兵"},{"categories":["「算法第四版」"],"content":" 快速排序的非递归实现 class QuickNoRecursive { public static void sort(Comparable[] a) { if (a == null || a.length \u003c 2) return; Stack\u003cInteger\u003e stack = new Stack\u003c\u003e(); stack.push(0); stack.push(a.length - 1); sort(a, stack); } // 使用栈来模拟递归栈 private static void sort(Comparable[] a, Stack\u003cInteger\u003e stack) { while (!stack.isEmpty()) { int hi = stack.pop(); int lo = stack.pop(); if (lo \u003e= hi) continue; int mid = partition(a, lo, hi); // 先将较小的子数组压入栈，可以保证栈最多只会有 lgN 个元素 if (hi - mid \u003e mid - lo) { stack.push(mid + 1); stack.push(hi); stack.push(lo); stack.push(mid - 1); } else { stack.push(lo); stack.push(mid - 1); stack.push(mid + 1); stack.push(hi); } } } private static int partition(Comparable[] a, int lo, int hi) { int i = lo; int j = hi + 1; Comparable v = a[lo]; while (true) { while (less(a[++i], v)) { if (i == hi) break; } while (less(v, a[--j])) { if (j == lo) break; } if (i \u003e= j) break; exch(a, i, j); } exch(a, lo, j); return j; } } ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:4:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序的非递归实现"},{"categories":["「算法第四版」"],"content":" 快速排序优化代码的实现 public class Quick { // cutoff to insertion sort, must be \u003e= 1 private static final int INSERTION_SORT_CUTOFF = 8; /** * Rearranges the array in ascending order, using the natural order. * @param a the array to be sorted */ public static void sort(Comparable[] a) { // StdRandom.shuffle(a); sort(a, 0, a.length - 1); } // quicksort the subarray from a[lo] to a[hi] private static void sort(Comparable[] a, int lo, int hi) { if (hi \u003c= lo) return; // cutoff to insertion sort (Insertion.sort() uses half-open intervals) int n = hi - lo + 1; if (n \u003c= INSERTION_SORT_CUTOFF) { Insertion.sort(a, lo, hi + 1); return; } int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); } // partition the subarray a[lo..hi] so that a[lo..j-1] \u003c= a[j] \u003c= a[j+1..hi] // and return the index j. private static int partition(Comparable[] a, int lo, int hi) { int n = hi - lo + 1; int m = median3(a, lo, lo + n/2, hi); // 取样确定切分元素 exch(a, m, lo); int i = lo; int j = hi + 1; Comparable v = a[lo]; // 切分元素为最大、最小的情况，直接返回 // a[lo] is unique largest element while (less(a[++i], v)) { if (i == hi) { exch(a, lo, hi); return hi; } } // a[lo] is unique smallest element while (less(v, a[--j])) { if (j == lo + 1) return lo; } // the main loop while (i \u003c j) { exch(a, i, j); while (less(a[++i], v)) ; while (less(v, a[--j])) ; } // put partitioning item v at a[j] exch(a, lo, j); // now, a[lo .. j-1] \u003c= a[j] \u003c= a[j+1 .. hi] return j; } // return the index of the median element among a[i], a[j], and a[k] private static int median3(Comparable[] a, int i, int j, int k) { return (less(a[i], a[j]) ? (less(a[j], a[k]) ? j : less(a[i], a[k]) ? k : i) : (less(a[k], a[j]) ? j : less(a[k], a[i]) ? k : i)); } // is v \u003c w ? private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u003c 0; } // exchange a[i] and a[j] private static void exch(Object[] a, int i, int j) { Object swap = a[i]; a[i] = a[j]; a[j] = swap; } } 上述代码是对二向切分的快速排序的优化版本： 每次排序抽样三个元素，并以三个元素的中位数作为切分元素，优化切分效果； 使用插入排序提升小数组的排序速度； 对于切分元素 lo 是最大（最小）情况进行优化。 ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:4:3","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速排序优化代码的实现"},{"categories":["「算法第四版」"],"content":" 三向切分的快速排序三向切分的快速排序适用于大量重复主键的随机数组。通过统计待排序数组的香农信息量，可以得出三向切分的快速排序所需要的比较次数的上下界。 三向切分的快速排序是信息量最优的。因为对于包含大量重复元素的数组，它将排序时间从线性对数级降低到了线性级别。三向切分的最坏情况正是所有主键均不相同。 ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:5:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#三向切分的快速排序"},{"categories":["「算法第四版」"],"content":" Dijkstra 三向切分的快速排序 public class Quick3way { /** * Rearranges the array in ascending order, using the natural order. * * @param a the array to be sorted */ public static void sort(Comparable[] a) { StdRandom.shuffle(a); sort(a, 0, a.length - 1); } // quicksort the subarray a[lo .. hi] using 3-way partitioning private static void sort(Comparable[] a, int lo, int hi) { if (hi \u003c= lo) return; int lt = lo, gt = hi; Comparable v = a[lo]; int i = lo + 1; while (i \u003c= gt) { // 从左到右遍历数组一次 int cmp = a[i].compareTo(v); // 使用 compareTo 比较元素，而非 less 方法 if (cmp \u003c 0) exch(a, lt++, i++); else if (cmp \u003e 0) exch(a, i, gt--); else i++; } // a[lo..lt-1] \u003c v = a[lt..gt] \u003c a[gt+1..hi]. sort(a, lo, lt - 1); sort(a, gt + 1, hi); } } 三向切分示意图 从左到右遍历数组一次，维护一个指针 lt 使得 a[lo..lt-1] 中的元素都小于 v，一个指针 gt 使得 a[gt+1..hi] 中的元素都大于 v，，一个指针 i 使得 a[lt..i-1] 中的元素都等于 v,a[i..gt] 中的元素都还未确定。 a[i] 小于 v，将 a[lt] 和 a[i] 交换，将 lt 和 i 加一; a[i] 大于 v，将 a[gt] 和 a[i] 交换，将 gt 减一; a[j] 等于 v，将 i 加一。 在数组中重复元素不多的普通情况下它比标准的二分法多使用了很多次交换。J.Bently 和 D.Mcllrov 的快速排序方法，使得三向切分的快速排序比归并排序和其他排序方法在包括重复元素很多的实际应用中更快。 ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:5:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#dijkstra-三向切分的快速排序"},{"categories":["「算法第四版」"],"content":" 快速三向切分（J.Bently, D.Mcllrov） public class QuickBentleyMcIlroy { // cutoff to insertion sort, must be \u003e= 1 private static final int INSERTION_SORT_CUTOFF = 8; // cutoff to median-of-3 partitioning private static final int MEDIAN_OF_3_CUTOFF = 40; /** * Rearranges the array in ascending order, using the natural order. * @param a the array to be sorted */ public static void sort(Comparable[] a) { sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { int n = hi - lo + 1; // cutoff to insertion sort if (n \u003c= INSERTION_SORT_CUTOFF) { insertionSort(a, lo, hi); return; } // use median-of-3 as partitioning element else if (n \u003c= MEDIAN_OF_3_CUTOFF) { int m = median3(a, lo, lo + n/2, hi); exch(a, m, lo); } // use Tukey ninther as partitioning element else { int eps = n/8; int mid = lo + n/2; int m1 = median3(a, lo, lo + eps, lo + eps + eps); int m2 = median3(a, mid - eps, mid, mid + eps); int m3 = median3(a, hi - eps - eps, hi - eps, hi); int ninther = median3(a, m1, m2, m3); exch(a, ninther, lo); } // Bentley-McIlroy 3-way partitioning int i = lo, j = hi+1; int p = lo, q = hi+1; Comparable v = a[lo]; while (true) { while (less(a[++i], v)) if (i == hi) break; while (less(v, a[--j])) if (j == lo) break; // pointers cross if (i == j \u0026\u0026 eq(a[i], v)) exch(a, ++p, i); if (i \u003e= j) break; exch(a, i, j); if (eq(a[i], v)) exch(a, ++p, i); if (eq(a[j], v)) exch(a, --q, j); } i = j + 1; for (int k = lo; k \u003c= p; k++) exch(a, k, j--); for (int k = hi; k \u003e= q; k--) exch(a, k, i++); sort(a, lo, j); sort(a, i, hi); } // sort from a[lo] to a[hi] using insertion sort private static void insertionSort(Comparable[] a, int lo, int hi) { for (int i = lo; i \u003c= hi; i++) for (int j = i; j \u003e lo \u0026\u0026 less(a[j], a[j-1]); j--) exch(a, j, j-1); } // return the index of the median element among a[i], a[j], and a[k] private static int median3(Comparable[] a, int i, int j, int k) { return (less(a[i], a[j]) ? (less(a[j], a[k]) ? j : less(a[i], a[k]) ? k : i) : (less(a[k], a[j]) ? j : less(a[k], a[i]) ? k : i)); } // is v \u003c w ? private static boolean less(Comparable v, Comparable w) { if (v == w) return false; // optimization when reference equal return v.compareTo(w) \u003c 0; } // does v == w ? private static boolean eq(Comparable v, Comparable w) { if (v == w) return true; // optimization when reference equal return v.compareTo(w) == 0; } // exchange a[i] and a[j] private static void exch(Object[] a, int i, int j) { Object swap = a[i]; a[i] = a[j]; a[j] = swap; } } Bently McIlroy 三向切分 上述代码的基本思想是：将重复元素放置于子数组两端的方式实现的信息量最优的排序算法。 使用两个索引 p 和 q，使得 a[lo..p-1] 和 a[q+1..hi] 的元素都和 a[lo] 相等。 使用另外两个索引 i 和 j，使得 a[p..i-1] 小于 a[lo]，a[j+i..q]大于 a[lo]。 在内循环中加入代码，在 a[i] 和 v 相当时将其与 a[p] 交换(并将 p 加 1 )，在 a[j] 和 v 相等且 a[i] 和 a[j] 尚未和 v 进行比较之前将其与 a[q] 交换。 使用 Tukey’s ninther 方法来找出切分元素，选择三组，每组三个元素，分别取三组元素的中位数，然后取三个中位数的中位数作为切分元素，且在排序小数组时切换到插入排序。 ","date":"2023-07-08","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:5:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」快速排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#快速三向切分jbently-dmcllrov"},{"categories":["Redis","分布式锁"],"content":"记录在分布式锁开发中的两个编码规范","date":"2023-06-25","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_03_%E4%B8%A4%E4%B8%AA%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"两个编码规范","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_03_%E4%B8%A4%E4%B8%AA%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"categories":["Redis","分布式锁"],"content":" 不要生吞异常Unlock 发送请求，如果发生 Socket 异常导致逻辑上解锁但实际上未解锁，是否需要将异常抛出？ 若不处理异常，Redis 中的 Key 会在设定的 30s 后过期，过期后可以将其与解锁看做等效，因此可以不处理异常； 若需要处理异常，则将该异常抛出，用户在使用 Unlock 时需要处理该异常。 原则：不要在代码中假设某种异常不会发生，或者忽略某中异常是无所谓的。 如果不将异常抛出或没有输出到日志，程序在出现莫名其妙的异常后会难以定位问题。因此不要忽略异常。 ","date":"2023-06-25","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_03_%E4%B8%A4%E4%B8%AA%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/:1:0","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"两个编码规范","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_03_%E4%B8%A4%E4%B8%AA%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/#不要生吞异常"},{"categories":["Redis","分布式锁"],"content":" 区分“判断”与“校验”在代码中，如果只有满足某种条件才能继续向后执行，应该使用校验。如果对于某个条件需要执行不同的分支，应该使用判断。 不要用判断取代校验，这会导致忽略某些异常。 // 校验，正确的用法 internal void Unlock(string name) { if (!(_lockEntries.TryGetValue(name, out var entry) \u0026\u0026 entry.IsEntered())) { throw new ExitLocalLockException(\"Exit local lock occurs an exception, \" + \"the local lock is missing or the local lock is not held by the current thread. \" + $\"LockName: [{name}]\"); } entry.Exit(); entry.DecRef(); } // 判断，会忽略异常。 internal void Unlock(string name) { if (_lockEntries.TryGetValue(name, out var entry) \u0026\u0026 entry.IsEntered()) { entry.Exit(); entry.DecRef(); } } ","date":"2023-06-25","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_03_%E4%B8%A4%E4%B8%AA%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/:2:0","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"两个编码规范","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_03_%E4%B8%A4%E4%B8%AA%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/#区分判断与校验"},{"categories":["Redis","分布式锁"],"content":"针对分布式锁续约设计的阻塞优先队列","date":"2023-06-24","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_02_%E9%98%BB%E5%A1%9E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"阻塞优先队列","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_02_%E9%98%BB%E5%A1%9E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["Redis","分布式锁"],"content":" 使用阻塞优先队列的原因续约线程从阻塞优先队列中获取分布式锁对象进行续约。 如果阻塞优先队列为空，线程应该等待阻塞优先队列有数据后再来获取数据； 如果阻塞优先队列不为空，但未到分布式锁的续约时间，则线程需要等待分布式锁能够续约后再来获取数据； 如果阻塞优先队列不为空，且已经到了分布式锁的续约时间，此时线程应从阻塞优先队列中获取数据并进行续约操作。 因此在本场景下，线程有两个时机是需要阻塞的。 ","date":"2023-06-24","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_02_%E9%98%BB%E5%A1%9E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:1:0","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"阻塞优先队列","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_02_%E9%98%BB%E5%A1%9E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#使用阻塞优先队列的原因"},{"categories":["Redis","分布式锁"],"content":" 阻塞优先队列的实现 public class LockPriorityBlockingQueue\u003cT\u003e where T : LockBase { private int _capacity; private int _size; private T[] _heap; private readonly object _locker = new object(); public LockPriorityBlockingQueue() { _capacity = 10; _size = 0; _heap = new T[_capacity + 1]; } public void Offer(T item) { Monitor.Enter(_locker); GrowIfNecessary(); try { Insert(item); Monitor.Pulse(_locker); } finally { Monitor.Exit(_locker); } } public T Poll() { Monitor.Enter(_locker); T item; try { var waitTime = Timeout.Infinite; while ((item = Peek()) == null || (waitTime = item.NextRenewTime) \u003e 0) { Monitor.Wait(_locker, waitTime); waitTime = Timeout.Infinite; } item = Delete(); } finally { Monitor.Exit(_locker); } return item; } } 其中 Insert、Delete、Peek 等方法为优先队列的基本操作。 ","date":"2023-06-24","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_02_%E9%98%BB%E5%A1%9E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:2:0","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"阻塞优先队列","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_02_%E9%98%BB%E5%A1%9E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#阻塞优先队列的实现"},{"categories":["Redis","分布式锁"],"content":"使用引用计数算法管理本地锁生命周期。","date":"2023-06-23","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_01_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"引用计数算法","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_01_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"},{"categories":["Redis","分布式锁"],"content":" 什么是引用计数 In computer science, reference counting is a programming technique of storing the number of references, pointers, or handles to a resource, such as an object, a block of memory, disk space, and others. In garbage collection algorithms, reference counts may be used to deallocate objects that are no longer needed. 对于一个实现了引用计数的对象，引用计数算法能够跟踪有多少引用处于活动状态。当引用的数量降至 0，我们可以安全的释放该对象的内存。 引用计数也是实现基本的垃圾回收算法的方式。 如果一个对象在多线程环境中需要安全关闭，可以考虑使用引用计数算法。 ","date":"2023-06-23","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_01_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/:1:0","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"引用计数算法","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_01_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/#什么是引用计数"},{"categories":["Redis","分布式锁"],"content":" 引用计数算法的实现ElasticSearch 代码中实现了基本的的引用计数算法。 public abstract class AbstractRefCounted implements RefCounted { private final AtomicInteger refCount = new AtomicInteger(1); private final String name; public AbstractRefCounted(String name) { this.name = name; } @Override public final void incRef() { if (tryIncRef() == false) { alreadyClosed(); } } @Override public final boolean tryIncRef() { do { int i = refCount.get(); if (i \u003e 0) { if (refCount.compareAndSet(i, i + 1)) { return true; } } else { return false; } } while (true); } @Override public final boolean decRef() { int i = refCount.decrementAndGet(); assert i \u003e= 0; if (i == 0) { try { closeInternal(); } catch (Exception e) { throw e; } return true; } return false; } protected void alreadyClosed() { throw new IllegalStateException(name + \" is already closed can't increment refCount current count [\" + refCount.get() + \"]\"); } /** * Returns the current reference count. */ public int refCount() { return this.refCount.get(); } /** gets the name of this instance */ public String getName() { return name; } /** * Method that is invoked once the reference count reaches zero. * */ protected abstract void closeInternal(); } ","date":"2023-06-23","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_01_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/:2:0","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"引用计数算法","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_01_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/#引用计数算法的实现"},{"categories":["Redis","分布式锁"],"content":" 分布式锁设计中如何使用引用计数在分布式锁的设计中，本地锁生命周期通过引用计数进行管理，保证本地锁的安全关闭。 ","date":"2023-06-23","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_01_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/:3:0","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"引用计数算法","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_01_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/#分布式锁设计中如何使用引用计数"},{"categories":["Redis","分布式锁"],"content":" 如何获取本地锁对象 如果能够从字典中获取本地锁对象则直接返回该对象； 如果字典中没有本地锁对象，创建一个本地锁对象并加入到字典中，返回该对象； 如果上述两个操作都失败了，则重试，直到成功获取本地锁对象。 private LockEntry GetLockEntry(string name) { while (true) { if (_lockEntries.TryGetValue(name, out var entry)) { if (entry.TryIncRef()) { return entry; } } var newEntry = new LockEntry(name); if (_lockEntries.TryAdd(name, newEntry)) { return newEntry; } } } ","date":"2023-06-23","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_01_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/:3:1","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"引用计数算法","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_01_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/#如何获取本地锁对象"},{"categories":["Redis","分布式锁"],"content":" 如何安全关闭本地锁对象只需要实现 CloseInternal() 方法，在引用计数降至 0 时，从字典中将该对象移除就可以了。 internal class LockEntry : AbstractRefCounted { internal LockEntry(string name) : base(name) { } protected override void CloseInternal() { LocalLockManager.Instance.Remove(Name); } } ","date":"2023-06-23","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_01_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/:3:2","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"引用计数算法","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_01_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/#如何安全关闭本地锁对象"},{"categories":["Redis","分布式锁"],"content":"记录基于Redis的分布式锁设计流程。","date":"2023-06-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_00_%E8%AE%BE%E8%AE%A1/","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"Redis分布式锁设计","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_00_%E8%AE%BE%E8%AE%A1/"},{"categories":["Redis","分布式锁"],"content":" Redis键值存储设计采用Hash结构作为分布式锁的存储结构。 KEY存储分布式锁名LockName； FIELD存储分布式锁GUID:ThreadId；（每个分布式锁对象会生成一个GUID，ThreadId为Lock操作时当前线程Id。） VALUE存储分布式锁的重入次数。 ","date":"2023-06-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_00_%E8%AE%BE%E8%AE%A1/:1:0","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"Redis分布式锁设计","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_00_%E8%AE%BE%E8%AE%A1/#redis键值存储设计"},{"categories":["Redis","分布式锁"],"content":" 请求量优化设计应用尝试获取分布式锁失败时，需要重试争抢锁，直到成功获取分布式锁。在重试争抢分布式锁期间会产生不必要的请求，需要优化这部分请求，降低Redis服务器压力。 在单应用多线程争抢同一把分布式锁锁的场景下，使用本地锁保证该应用在同一时刻只有一个线程重试争抢分布式锁。 flowchart LR A([Start]) --\u003e B(Try to get distributed lock) B --\u003e C{Succeed to get distributed lock?} C --\u003e|Yes| D([End]) C --\u003e|No| F(Try to get local lock) subgraph Retry direction LR F --\u003e G(Try to get distributed lock) G --\u003e H{Succeed to get distributed lock?} H --\u003e|No| G H --\u003e|Yes| I(Release local lock) end I --\u003e D ","date":"2023-06-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_00_%E8%AE%BE%E8%AE%A1/:2:0","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"Redis分布式锁设计","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_00_%E8%AE%BE%E8%AE%A1/#请求量优化设计"},{"categories":["Redis","分布式锁"],"content":" 本地锁管理设计使用本地锁管理分布式锁，此时引出了本地锁管理的问题。 所有的本地锁存放在一个 ConcurrentDictionary 中。当线程需要重试以获取分布式锁时，需要先获取本地锁对象（获取不到锁对象则需要创建本地锁对象）并持有本地锁。线程重试获取分布式锁成功后需要释放本地锁，且如果此时没有线程等待本地锁对象，则需要将本地锁对象从字典中删除。 本地锁生命周期通过引用计数进行管理，保证本地锁的安全关闭。 ","date":"2023-06-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_00_%E8%AE%BE%E8%AE%A1/:2:1","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"Redis分布式锁设计","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_00_%E8%AE%BE%E8%AE%A1/#本地锁管理设计"},{"categories":["Redis","分布式锁"],"content":" 分布式锁续约设计如果每个成功获取分布式锁的线程都新开一个守护线程进行锁续约，则会导致应用新开大量的线程造成资源浪费。因此需要统一管理需要续约的分布式锁。 分布式锁默认30s过期，每10s续约一次（过期时间的 1/3，这样每个分布式锁能够容忍续约失败一次）。 固定开 2-3 个线程对所有的分布式锁进行续约，使用阻塞优先队列管理需要续约的分布式锁对象。 续约线程从阻塞优先队列获取分布式锁对象； 如果分布式锁对象已经 Unlock，则不续约该锁； 如果分布式锁对象在续约过程中发生异常，放回阻塞优先队列，该分布式锁默认会在10s后再次续约； 如果分布式锁对象续约成功，放回阻塞优先队列，该分布式锁默认会在10s后再次续约； 如果分布式锁对象续约失败且未 Unlock。即在续约时分布式锁不存在，判定分布式锁已经失效。停止续约该分布式锁，并使用Cancel机制通知用户线程分布式锁已失效，用户线程可以调用 RenewFailed 方法判断分布式锁是否失效。 flowchart LR A(Lock) A --\u003e Q[/PriorityBlockingQueue\\] Q --\u003e|Poll| T((Renew Threads)) T --\u003e|Succeed to renew renew occured an exception Offer| Q T --\u003e B(Already unlocked) T --\u003e C(Lock has already lost) ","date":"2023-06-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_00_%E8%AE%BE%E8%AE%A1/:3:0","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"Redis分布式锁设计","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_00_%E8%AE%BE%E8%AE%A1/#分布式锁续约设计"},{"categories":["Redis","分布式锁"],"content":" 分布式锁失效场景由于分布式锁使用单点锁实现，并且由于 Redis 本身的局限性，导致有如下锁失效场景： 异步复制：在锁未同步到从节点时主节点宕机，此时客户端认为拿到锁，但主从切换后锁已丢失； 缓存淘汰LRU/LFU有淘汰锁的可能性； 同一把锁连续两次续约失败且期间并未解锁，锁会因过期而导致失效。 其中，异步复制导致的锁失效问题，可以使用 WAIT 命令解决，但本设计不实现。 ","date":"2023-06-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_00_%E8%AE%BE%E8%AE%A1/:4:0","series":["Redis分布式锁"],"tags":["Redis","分布式锁"],"title":"Redis分布式锁设计","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_00_%E8%AE%BE%E8%AE%A1/#分布式锁失效场景"},{"categories":["「算法第四版」"],"content":"归并排序","date":"2023-05-21","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」归并排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"categories":["「算法第四版」"],"content":" 自顶向下的归并排序 public class Merge { public static void sort(Comparable[] a) { Comparable[] aux = new Comparable[a.length]; sort(a, aux, 0, a.length - 1); } // mergesort a[lo..hi] using auxiliary array aux[lo..hi] private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) { if (hi \u003c= lo) return; int mid = lo + (hi - lo) / 2; sort(a, aux, lo, mid); sort(a, aux, mid + 1, hi); merge(a, aux, lo, mid, hi); } // stably merge a[lo .. mid] with a[mid+1 ..hi] using aux[lo .. hi] private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) { // copy to aux[] for (int k = lo; k \u003c= hi; k++) { aux[k] = a[k]; } // merge back to a[] int i = lo, j = mid + 1; for (int k = lo; k \u003c= hi; k++) { if (i \u003e mid) a[k] = aux[j++]; else if (j \u003e hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; // to ensure stability else a[k] = aux[i++]; } } } ","date":"2023-05-21","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」归并排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#自顶向下的归并排序"},{"categories":["「算法第四版」"],"content":" 自顶向下归并排序索引 public class Merge { // Returns a permutation that gives the elements in the array in ascending order. public static int[] indexSort(Comparable[] a) { int n = a.length; int[] index = new int[n]; for (int i = 0; i \u003c n; i++) index[i] = i; int[] aux = new int[n]; sort(a, index, aux, 0, n - 1); return index; } // mergesort a[lo..hi] using auxiliary array aux[lo..hi] private static void sort(Comparable[] a, int[] index, int[] aux, int lo, int hi) { if (hi \u003c= lo) return; int mid = lo + (hi - lo) / 2; sort(a, index, aux, lo, mid); sort(a, index, aux, mid + 1, hi); merge(a, index, aux, lo, mid, hi); } // stably merge a[lo .. mid] with a[mid+1 .. hi] using aux[lo .. hi] private static void merge(Comparable[] a, int[] index, int[] aux, int lo, int mid, int hi) { // copy to aux[] for (int k = lo; k \u003c= hi; k++) { aux[k] = index[k]; } // merge back to a[] int i = lo, j = mid + 1; for (int k = lo; k \u003c= hi; k++) { if (i \u003e mid) index[k] = aux[j++]; else if (j \u003e hi) index[k] = aux[i++]; else if (less(a[aux[j]], a[aux[i]])) index[k] = aux[j++]; else index[k] = aux[i++]; } } } ","date":"2023-05-21","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:1:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」归并排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#自顶向下归并排序索引"},{"categories":["「算法第四版」"],"content":" 自顶向下归并排序的优化 对小规模子数组使用插入排序。使用插入排序处理小规模的子数组（比如长度小于 15），一般可以将归并排序的运行时间缩短 10% ~ 15%； 测试数组是否已经有序。添加判断条件若 a[mid] \u003c= a[mid + 1]，则此时数组已经是有序的，可以跳过 merge 方法； 不将元素复制到辅助数组。节省将数组复制到用于归并的辅助数组所用的时间。需要调用两种排序方法，一种将数据从输入数组排序到辅助数组，一种将数组从辅助数组排序到输入数组。在递归调用的每个层次交换输入数组和辅助数组的角色。 public class Merge { private static final int CUTOFF = 7; // cutoff to insertion sort public static void sort(Comparable[] a) { Comparable[] aux = a.clone(); sort(aux, a, 0, a.length - 1); } private static void sort(Comparable[] src, Comparable[] dst, int lo, int hi) { // 1. 对小规模子数组使用插入排序 if (hi \u003c= lo + CUTOFF) { insertionSort(dst, lo, hi); return; } int mid = lo + (hi - lo) / 2; sort(dst, src, lo, mid); // 递归调用的每个层次交换输入数组和辅助数组的角色 sort(dst, src, mid + 1, hi); // sort 方法每次递归的结果为：传入的参数 dst 有序 // 2. 测试数组是否有序以跳过 merge 方法 // using System.arraycopy() is a bit faster than loop if (!less(src[mid + 1], src[mid])) { System.arraycopy(src, lo, dst, lo, hi - lo + 1); return; } merge(src, dst, lo, mid, hi); } private static void merge(Comparable[] src, Comparable[] dst, int lo, int mid, int hi) { // 3. 不将元素复制到辅助数组 int i = lo, j = mid + 1; for (int k = lo; k \u003c= hi; k++) { if (i \u003e mid) dst[k] = src[j++]; else if (j \u003e hi) dst[k] = src[i++]; else if (less(src[j], src[i])) dst[k] = src[j++]; // to ensure stability else dst[k] = src[i++]; } } // sort from a[lo] to a[hi] using insertion sort private static void insertionSort(Comparable[] a, int lo, int hi) { for (int i = lo; i \u003c= hi; i++) for (int j = i; j \u003e lo \u0026\u0026 less(a[j], a[j - 1]); j--) exch(a, j, j - 1); } } ","date":"2023-05-21","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:1:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」归并排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#自顶向下归并排序的优化"},{"categories":["「算法第四版」"],"content":" 自底向上的归并排序","date":"2023-05-21","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」归并排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#自底向上的归并排序"},{"categories":["「算法第四版」"],"content":" 自底向上归并排序数组 public class Merge { public static void sort(Comparable[] a) { int n = a.length; Comparable[] aux = new Comparable[n]; for (int len = 1; len \u003c n; len *= 2) { for (int lo = 0; lo \u003c n - len; lo += len + len) { int mid = lo + len - 1; int hi = Math.min(lo + len + len - 1, n - 1); merge(a, aux, lo, mid, hi); } } } private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) { // copy to aux[] for (int k = lo; k \u003c= hi; k++) { aux[k] = a[k]; } // merge back to a[] int i = lo, j = mid + 1; for (int k = lo; k \u003c= hi; k++) { if (i \u003e mid) a[k] = aux[j++]; // this copying is unnecessary else if (j \u003e hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; } } } ","date":"2023-05-21","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:2:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」归并排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#自底向上归并排序数组"},{"categories":["「算法第四版」"],"content":" 自底向上归并排序链表 class LinkedListNatureMerge { public static void sort(LinkedList\u003cComparable\u003e a) { if (a == null || a.size() \u003c 2) return; LinkedList.Node sentinel = a.new Node(null, a.first); while (true) { LinkedList.Node prev = sentinel; LinkedList.Node lo = prev.next; LinkedList.Node mid = findAscIndex(lo, a.last); if (mid == a.last) break; while (mid != a.last) { LinkedList.Node hi = findAscIndex(mid.next, a.last); prev = merge(prev, lo, mid, hi); if (a.last.next != null) a.last = prev; // 维护链表 last 指针 lo = prev.next; mid = findAscIndex(lo, a.last); } } a.first = sentinel.next; // 维护链表 first 指针 } private static LinkedList.Node merge(LinkedList.Node prev, LinkedList.Node lo, LinkedList.Node mid, LinkedList.Node hi) { LinkedList.Node next = hi.next; LinkedList.Node p1 = lo; LinkedList.Node p2 = mid.next; mid.next = null; hi.next = null; while (p1 != null \u0026\u0026 p2 != null) { if (less(p2.item, p1.item)) { prev.next = p2; p2 = p2.next; } else { prev.next = p1; p1 = p1.next; } prev = prev.next; } if (p1 == null) { prev.next = p2; } else { prev.next = p1; } while (prev.next != null) { prev = prev.next; } prev.next = next; return prev; } private static LinkedList.Node findAscIndex(LinkedList.Node node, LinkedList.Node last) { if (node == null) return last; while (node.next != null) { if (less(node.next.item, node.item)) return node; node = node.next; } return last; } public static boolean isSorted(LinkedList\u003cComparable\u003e a) { LinkedList.Node pointer = a.first; while (pointer.next != null) { if (less(pointer.next.item, pointer.item)) return false; pointer = pointer.next; } return true; } private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u003c 0; } static class LinkedList\u003cItem extends Comparable\u003e { Node first; Node last; private int size; LinkedList() { first = last = null; size = 0; } public void insert(Item item) { if (first == null) { first = last = new Node(item, null); } else { first = new Node(item, first); } size++; } public Item remove() { if (first == null) return null; Node temp = first; if (first == last) { first = last = null; } else { first = first.next; } size--; return temp.item; } public int size() { return size; } class Node { Item item; Node next; Node(Item item, Node next) { this.item = item; this.next = next; } } } } ","date":"2023-05-21","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:2:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」归并排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#自底向上归并排序链表"},{"categories":["「算法第四版」"],"content":" 归并排序的特点归并排序是分治思想的典型应用。 归并排序的算法复杂度： 对于长度为 N 的任意数组，自底向上的归并排序需要 1/2NlgN 至 NlgN次比较，最多访问数组 6NlgN 次； 没有任何基于比较的算法能够保证使用少于 lg(N!) ~ NlgN次比较将长度为 N 的数组排序； 归并排序是一种渐进最优的基于比较排序的算法，归并排序在最坏情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是 ~NlgN。 ","date":"2023-05-21","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」归并排序","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_07_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/#归并排序的特点"},{"categories":["「算法第四版」"],"content":"选择排序、插入排序和希尔排序","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["「算法第四版」"],"content":" 排序算法类的模版 public class Sort { public static void sort(Comparable[] a) { // 排序算法具体实现 } private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u003c 0; } private static void exch(Comparable[] a, int i, int j) { Comparable temp = a[i]; a[i] = a[j]; a[j] = temp; } private static void show(Comparable[] a) { for (int i = 0; i \u003c a.length; i++) StdOut.print(a[i] + \" \"); StdOut.println(); } private static boolean isSorted(Comparable[] a) { for (int i = 1; i \u003c a.length; i++) { if (less(a[i], a[i - 1])) return false; } return true; } } ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#排序算法类的模版"},{"categories":["「算法第四版」"],"content":" 选择排序","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#选择排序"},{"categories":["「算法第四版」"],"content":" 选择排序算法描述首先，找到数组中最小的元素，其次，将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。直到将整个数组排序。 ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#选择排序算法描述"},{"categories":["「算法第四版」"],"content":" 选择排序的实现 public class Selection { public static void sort(Comparable[] a) { int n = a.length; for (int i = 0; i \u003c n; i++) { int min = i; for (int j = i + 1; j \u003c n; j++) { if (less(a[j], a[min])) min = j; } exch(a, i, min); assert isSorted(a, 0, i); } assert isSorted(a); } } 算法将第 i 小的元素放到 a[i] 中。数组的第 i 个位置的左边是 i 个最小的元素且它们不会再被访问。 ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#选择排序的实现"},{"categories":["「算法第四版」"],"content":" 选择排序的特点对于长度为 N 的数组，选择排序需要大约 (N^2) / 2 次比较和 N 次交换。 运行时间和输入无关。 数据移动是最少的。数据移动与数组长度线性相关。 ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:3","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#选择排序的特点"},{"categories":["「算法第四版」"],"content":" 插入排序","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#插入排序"},{"categories":["「算法第四版」"],"content":" 插入排序算法描述初始状态，把第一个元素看做只有一个元素的有序序列，从第二个元素开始及其之后的元素是未排序序列。对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#插入排序算法描述"},{"categories":["「算法第四版」"],"content":" 插入排序的实现 public class Insertion { public static void sort(Comparable[] a) { int n = a.length; for (int i = 1; i \u003c n; i++) { for (int j = i; j \u003e 0 \u0026\u0026 less(a[j], a[j - 1]); j--) { exch(a, j, j - 1); } assert isSorted(a, 0, i); } assert isSorted(a); } public static void sort(Comparable[] a, int lo, int hi) { for (int i = lo + 1; i \u003c hi; i++) { for (int j = i; j \u003e lo \u0026\u0026 less(a[j], a[j - 1]); j--) { exch(a, j, j - 1); } } assert isSorted(a, lo, hi); } } 对于 1 到 N - 1 之间的每个 i，将 a[i] 与 a[0] 到 a[i - 1] 中比它小的所有元素依次有序地交换。在索引 i 由左向右变化的过程中，它左侧的元素总是有序的，当 i 到达数组右端时完成排序。 在内循环中将较大的元素都向右移动而不总是交换两个元素，可以大幅提高插入排序的速度。 public class InsertionSortWithoutExchange { public static void sort(Comparable[] a) { int n = a.length; for (int i = 1; i \u003c n; i++) { Comparable value = a[i]; int j; for (j = i; j \u003e 0 \u0026\u0026 less(value, a[j - 1]); j--) { a[j] = a[j - 1]; } a[j] = value; } assert isSorted(a, 0, n - 1); } } 先找出最小的元素并将其置于数组的最左边，这样能够规避判断边界条件 j \u003e 0 从而提高插入排序速度，这个元素被称为哨兵。 public class InsertionWithSentinel { public static void sort(Comparable[] a) { int min = 0; for (int i = 1; i \u003c a.length; i++) if (less(a[i], a[min])) min = i; exch(a, 0, min); for (int i = 2; i \u003c a.length; i++) { for (int j = i; less(j, j - 1); j--) { exch(a, j, j - 1); } } } } ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#插入排序的实现"},{"categories":["「算法第四版」"],"content":" 插入排序的特点对于随机排列的长度为 N 且逐渐不重复的数组，平均情况下插入排序需要 ~(N^2)/4 次比较与交换。最坏情况下需要 ~(N^2)/2 次比较与交换。最好情况下需要 N - 1 次比较和 0 次交换。 插入排序所需时间取决于元素的初始顺序。因此插入排序适合实际应用中部分有序的非随机数组。 插入排序的比较和交换的次数相等。 ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:3","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#插入排序的特点"},{"categories":["「算法第四版」"],"content":" 希尔排序","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#希尔排序"},{"categories":["「算法第四版」"],"content":" 希尔排序算法描述希尔排序是更高效的插入排序。 对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数维的一端移动到另一端。 希尔排序使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 h 有序数组。在进行排序时，如果 h 很大，我们就能将元素移动到很远的地方，为实现更小的 h 有序创造方便。对于任意以 1 结尾的 h 序列，我们都能够将数组排序。这就是希尔排序。 希尔排序比插入排序更高效的原因：排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。 ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#希尔排序算法描述"},{"categories":["「算法第四版」"],"content":" 希尔排序的实现递增序列为 (3^k - 1) / 2 的希尔排序。 public class Shell { public static void sort(Comparable[] a) { int n = a.length; // 3x+1 increment sequence: 1, 4, 13, 40, 121, 364, 1093, ... int h = 1; while (h \u003c n / 3) h = 3 * h + 1; while (h \u003e= 1) { // h-sort the array for (int i = h; i \u003c n; i++) { for (int j = i; j \u003e= h \u0026\u0026 less(a[j], a[j - h]); j -= h) { exch(a, j, j - h); } } assert isHsorted(a, h); h /= 3; } assert isSorted(a); } // is the array h-sorted? private static boolean isHsorted(Comparable[] a, int h) { for (int i = h; i \u003c a.length; i++) if (less(a[i], a[i - h])) return false; return true; } } 也可以将希尔排序的递增序列存储在一个数组中。 class ShellSortKeepIncrementSequence { public static void sort(Comparable[] a) { int n = a.length; int[] incrementSequence = getIncrementSequence(n); for (int h : incrementSequence) { for (int i = h; i \u003c n; i++) { for (int j = i; j \u003e= h \u0026\u0026 less(a[j], a[j - h]); j -= h) { exch(a, j, j - h); } } } } private static int[] getIncrementSequence(int n) { int size = (int) (Math.log(2 * n + 1) / Math.log(3)); int[] incrementSequence = new int[size]; for (int h = 0, i = size - 1; i \u003e= 0; i--) { h = 3 * h + 1; incrementSequence[i] = h; } return incrementSequence; } } 一个更加高效的递增序列为 1，5，19，41, 109，209，505，929，2161，3905，8929，16 001，36 289，64 769，146 305，260 609。该序列通过 9 * (4^k) - 9 * (2^k) + 1 与 (4^k) - 3 * (2^k) + 1 综合得到 。在实际应用中可能可以将性能改进 20% ~ 40%。 class ShellSortHighPerformanceIncrementSequence { public static void sort(Comparable[] a) { int n = a.length; Stack\u003cInteger\u003e incrementSequence = getIncrementSequence(n); while (!incrementSequence.isEmpty()) { int h = incrementSequence.pop(); for (int i = h; i \u003c n; i++) { for (int j = i; j \u003e= h \u0026\u0026 less(a[j], a[j - h]); j -= h) { exch(a, j, j - h); } } } } private static Stack\u003cInteger\u003e getIncrementSequence(int n) { Stack\u003cInteger\u003e sequence = new Stack\u003c\u003e(); int value = -1; int k = 0; while (true) { value = (int) (9 * Math.pow(4, k) - 9 * Math.pow(2, k) + 1); if (value \u003c n) sequence.push(value); value = (int) (Math.pow(4, k + 2) - 3 * Math.pow(2, k + 2) + 1); if (value \u003c n) sequence.push(value); if (value \u003e= n) break; k++; } return sequence; } } ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#希尔排序的实现"},{"categories":["「算法第四版」"],"content":" 希尔排序的特点希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大。 对于中等大小的数组它的运行时间是可以接受的。它的代码量很小，且不需要使用额外的内存空间。 解决一个排序问题时，可以先用希尔排序，然后再考虑是否值得将它替换为更加复杂的排序算法。 ","date":"2023-04-20","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:3","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」","排序算法"],"title":"「算法第四版」初级排序算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_06_%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#希尔排序的特点"},{"categories":["Redis"],"content":"分析 Redis 内存碎片整理功能，给出控制内存碎片可行方案。","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/"},{"categories":["Redis"],"content":" 内存碎片产生原因内存碎片产生有两种原因 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:1:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#内存碎片产生原因"},{"categories":["Redis"],"content":" 内存分配原因 To store user keys, Redis allocates at most as much memory as the maxmemory setting enables (however there are small extra allocations possible). Redis 在分配内存时有可能会分配少量额外空间。 Redis 封装的 zmalloc 方法会调用 ztrymalloc_usable 方法额外分配 PREFIX_SIZE 大小的空间。 /* Try allocating memory, and return NULL if failed. * '*usable' is set to the usable size if non NULL. */ void *ztrymalloc_usable(size_t size, size_t *usable) { /* Possible overflow, return NULL, so that the caller can panic or handle a failed allocation. */ if (size \u003e= SIZE_MAX/2) return NULL; void *ptr = malloc(MALLOC_MIN_SIZE(size)+PREFIX_SIZE); if (!ptr) return NULL; #ifdef HAVE_MALLOC_SIZE size = zmalloc_size(ptr); update_zmalloc_stat_alloc(size); if (usable) *usable = size; return ptr; #else *((size_t*)ptr) = size; update_zmalloc_stat_alloc(size+PREFIX_SIZE); if (usable) *usable = size; return (char*)ptr+PREFIX_SIZE; #endif } 其次在默认内存分配器 Jemalloc 下，会按照固定大小分配内存，比如需要申请 6 bytes，但实际分配 8 bytes。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:1:1","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#内存分配原因"},{"categories":["Redis"],"content":" 频繁修改 Redis 中数据 Redis will not always free up (return) memory to the OS when keys are removed. This is not something special about Redis, but it is how most malloc() implementations work. For example if you fill an instance with 5GB worth of data, and then remove the equivalent of 2GB of data, the Resident Set Size (also known as the RSS, which is the number of memory pages consumed by the process) will probably still be around 5GB, even if Redis will claim that the user memory is around 3GB. This happens because the underlying allocator can’t easily release the memory. For example often most of the removed keys were allocated in the same pages as the other keys that still exist. 在删除数据时，Redis 不会直接将该部分内存归还操作系统，原因是有可能有其他数据落在相同页上，这部分删除的内存也会产生内存碎片。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:1:2","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#频繁修改-redis-中数据"},{"categories":["Redis"],"content":" 内存碎片率mem_fragmentation_ratio = used_memory_rss / used_memory 可以理解为 Redis 向操作系统申请的内存与 Redis 实际使用内存的比。 理想情况下内存碎片率维持在 1.03 最好。正常情况下在 1-1.5 之间。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:2:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#内存碎片率"},{"categories":["Redis"],"content":" 内存碎片整理功能默认配置 activedefrag = 0 # 内存碎片整理总开关，默认不开启。 active-defrag-cycle-min = 1 # 内存碎片整理的 CPU 时间占总 CPU 时间不低于 1%。 active-defrag-cycle-max = 25 # 内存碎片整理的 CPU 时间占总 CPU 时间不高于 25%。 active-defrag-threshold-lower = 10 # 内存碎片率小于 10%，不进行内存碎片整理。 active-defrag-threshold-upper = 100 # 在 100% 碎片率时达到最大的碎片整理力度。 active-defrag-max-scan-fields = 1000 # key 中包含的 field 大于 1000 会被单独处理。 active-defrag-ignore-bytes = 100mb # 碎片总空间少于 100mb 不进行内存整理。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:3:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#内存碎片整理功能默认配置"},{"categories":["Redis"],"content":" 内存碎片整理的实现内存碎片整理功能通过 activeDefragCycle 函数实现，该函数通过 serverCron 函数调用，在开启该功能后会被定时调用。一次完整的内存碎片整理过程需要多次调用 activeDefragCycle 函数，即会横跨多次定时任务。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:4:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#内存碎片整理的实现"},{"categories":["Redis"],"content":" 控制占用 CPU 时间比率限制的实现通过 active-defrag-cycle-min、active-defrag-cycle-max、active-defrag-threshold-lower、active-defrag-threshold-upper 四个配置能够控制内存碎片整理功能占用 CPU 时间的百分比。 该百分比最终会被计算为每次执行 activeDefragCycle 函数的最大时间限制 timeLimit，从而控制每次执行内存碎片整理功能的时间。 #define INTERPOLATE(x, x1, x2, y1, y2) ( (y1) + ((x)-(x1)) * ((y2)-(y1)) / ((x2)-(x1)) ) #define LIMIT(y, min, max) ((y)\u003c(min)? min: ((y)\u003e(max)? max: (y))) /* decide if defrag is needed, and at what CPU effort to invest in it */ void computeDefragCycles() { size_t frag_bytes; // 获得内存碎片率和内存碎片的总字节数 float frag_pct = getAllocatorFragmentation(\u0026frag_bytes); /* If we're not already running, and below the threshold, exit. */ // 如果当前未进行内存碎片整理，且内存碎片率和内存碎片总字节数不满足阈值要求，退出 if (!server.active_defrag_running) { if(frag_pct \u003c server.active_defrag_threshold_lower || frag_bytes \u003c server.active_defrag_ignore_bytes) return; } /* Calculate the adaptive aggressiveness of the defrag */ // 自适应计算内存碎片清理的 cpu 占用百分比 int cpu_pct = INTERPOLATE(frag_pct, server.active_defrag_threshold_lower, server.active_defrag_threshold_upper, server.active_defrag_cycle_min, server.active_defrag_cycle_max); // 将 cpu 占用百分比限制在 [active_defrag_cycle_min, active_defrag_cycle_max] cpu_pct = LIMIT(cpu_pct, server.active_defrag_cycle_min, server.active_defrag_cycle_max); /* We allow increasing the aggressiveness during a scan, but don't * reduce it. */ if (cpu_pct \u003e server.active_defrag_running) { // 记录比率 server.active_defrag_running = cpu_pct; serverLog(LL_VERBOSE, \"Starting active defrag, frag=%.0f%%, frag_bytes=%zu, cpu=%d%%\", frag_pct, frag_bytes, cpu_pct); } } 计算公式： cycle-min + (frag_pct - threshold_lower) * (cycle_max - cycle_min) / (threshold_upper - threshold_lower)。 若当前内存碎片率为 1.5，则计算出来的 cpu_pct = 14。 则 timelimit = 1000000 * server.active_defrag_running / server.hz / 100 = 1000000 * 14 / 10 / 100 = 14,000 μs = 14 ms。 该值计算出来后，会在每 16 次 scan，或每 512 次指针移动，或每 64 个 key 完成内存整理完毕后，判断运行时间是否超过运行时间限制，若超过则退出本次内存整理。 即在内存碎片率为 1.5 时，每次定时任务会花费 14ms 左右时间整理内存碎片。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:4:1","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#控制占用-cpu-时间比率限制的实现"},{"categories":["Redis"],"content":" 内存碎片整理核心实现内存整理功能通过 scan 键空间实现。每次 scan 时会调用 defragScanCallback 回调函数，执行 scan 出来的 key 的内存碎片清理工作。 cursor = dictScan(db-\u003edict, cursor, defragScanCallback, defragDictBucketCallback, db); defragScanCallback 调用 defragKey 函数，先尝试整理 key 对象，再判断 value 对象的编码从而调用相关函数整理 value 对象。 最终都会调用 activeDefragAlloc 函数进行内存整理。内存整理的过程为：分配新内存、内存复制、释放旧内存。 /* Defrag helper for generic allocations. * * returns NULL in case the allocation wasn't moved. * when it returns a non-null value, the old pointer was already released * and should NOT be accessed. */ void* activeDefragAlloc(void *ptr) { size_t size; void *newptr; if(!je_get_defrag_hint(ptr)) { server.stat_active_defrag_misses++; return NULL; } /* move this allocation to a new allocation. * make sure not to use the thread cache. so that we don't get back the same * pointers we try to free */ size = zmalloc_size(ptr); // 分配新内存 newptr = zmalloc_no_tcache(size); // 内存复制 memcpy(newptr, ptr, size); // 释放旧内存 zfree_no_tcache(ptr); return newptr; } 这样就完成了单个内存区域的内存整理。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:4:2","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#内存碎片整理核心实现"},{"categories":["Redis"],"content":" 内存碎片整理大 Key 是否阻塞假设有一大 key 其拥有的元素为 fields 个。 在处理到该 key 时，会比较 fields 与 active-defrag-max-scan-fields 的大小，若 fields \u003e active-defrag-max-scan-fields，则将其标记为大 key 放在一个列表里，并跳过该 key 的内存整理。 if (dictSize(d) \u003e server.active_defrag_max_scan_fields) defragLater(db, kde); else defragged += activeDefragSdsDict(d, DEFRAG_SDS_DICT_VAL_IS_SDS); 在 scan 下一个桶之前，会检查列表里是否有大 key 未完成内存整理，若有则会单独为大 key 进行内存整理。 /* before scanning the next bucket, see if we have big keys left from the previous bucket to scan */ if (defragLaterStep(db, endtime)) { quit = 1; /* time is up, we didn't finish all the work */ break; /* this will exit the function and we'll continue on the next cycle */ } 在整理大 key 的内存时，也会分多次整理。会在每 16 次迭代，或每 512 个指针移动，或每 64 个 field 内存整理完毕后，判断运行时间是否超过运行时间限制，若超过则退出本次内存整理。 do { int quit = 0; if (defragLaterItem(de, \u0026defrag_later_cursor, endtime,db-\u003eid)) quit = 1; /* time is up, we didn't finish all the work */ /* Once in 16 scan iterations, 512 pointer reallocations, or 64 fields * (if we have a lot of pointers in one hash bucket, or rehashing), * check if we reached the time limit. */ if (quit || (++iterations \u003e 16 || server.stat_active_defrag_hits - prev_defragged \u003e 512 || server.stat_active_defrag_scanned - prev_scanned \u003e 64)) { if (quit || ustime() \u003e endtime) { if(key_defragged != server.stat_active_defrag_hits) server.stat_active_defrag_key_hits++; else server.stat_active_defrag_key_misses++; return 1; } iterations = 0; prev_defragged = server.stat_active_defrag_hits; prev_scanned = server.stat_active_defrag_scanned; } } while(defrag_later_cursor); 即一个大 key 的内存整理会分多次处理，不会长时间阻塞主线程。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:4:3","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#内存碎片整理大-key-是否阻塞"},{"categories":["Redis"],"content":" 手动内存整理 Memory Purge该命令只在使用 jemalloc 内存分配器下生效。 该命令清理内存脏页，和上述内存碎片整理功能管理的不是相同区域。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:5:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#手动内存整理-memory-purge"},{"categories":["Redis"],"content":" 结论Redis 内存碎片整理功能是通过 scan 命令渐进式地整理每次迭代到的 key，每次调用的时间复杂度为 O(1), 完整执行完一次内存碎片整理功能的时间复杂度为 O(n)。 内存碎片整理大 key 会将大 key 分多次处理，不会长时间阻塞主线程。 内存碎片整理功能的核心作用是降低内存碎片率，提高内存利用率以节省内存成本。 但内存整理功能在主线程中执行，会阻塞主线程而降低 Redis 的性能。 ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:6:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#结论"},{"categories":["Redis"],"content":" 参考资料Memory optimization | Redis redis/defrag.c at unstable · redis/redis · GitHub MEMORY PURGE | Redis ","date":"2023-04-19","objectID":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/:7:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/redis%E5%8D%87%E7%BA%A7_02_%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87/#参考资料"},{"categories":["「算法第四版」"],"content":"「算法第四版」Union-Find 算法","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/"},{"categories":["「算法第四版」"],"content":" 动态连通性问题及其应用若整数对 (p, q) 是“相连”的，则： 自反性：p 和 p 是相连的； 对称性：如果 p 和 q 是相连的，那么 q 和 p 也是相连的； 传递性：如果 p 和 q 是相连的且 q 和 r 是相连的，那么 p 和 r 也是相连的。 当且仅当两个对象相连时它们才属于同一个等价类。 判断一对新的对象是否“相连”，这样的问题叫动态连通性问题。 ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#动态连通性问题及其应用"},{"categories":["「算法第四版」"],"content":" 网络在大型计算机网络中，输入的整数表示主机(触点)，整数对表示网络(连接)，同一网络中的主机属于同一等价类(连通分量)。 在社交网络中，整数可以表示社交网络中的人，整数对表示朋友关系。 ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:1:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#网络"},{"categories":["「算法第四版」"],"content":" 数学集合将每个整数看做属于不同的数学集合，每一个整数对则需要先判断是否在同一数学集合中。若不是，则将 p 所属集合与 q 所属集合归并到同一集合。 ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:1:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#数学集合"},{"categories":["「算法第四版」"],"content":" Union-Find 算法的 API public class UF UF(int N) 以整数标志 [0, N-1] 初始化 N 个触点 void union(int p, int q) 在 p 和 q 之间添加一条连接 int find(int p) p (0 \u003c= p \u003c= N-1) 所在的分量标识符 boolean connected(int p, int q) p 和 q 是否连通 int count() 连通分量的数量 ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#union-find-算法的-api"},{"categories":["「算法第四版」"],"content":" Union-Find 算法的实现基本的 UF 算法实现见如下代码，union 与 find 的详细实现分别见 Quick-Find，Quick-Union，Weighted Quick-Union，Quick-Union with Path Compresson 的实现。 public class UF { private int[] id; private int count; public UF(int n) { count = n; id = new int[n]; for (int i = 0; i \u003c n; i++) id[i] = i; } public void union(int p, int q); public int find(int p); public boolean connected(int p, int q) { return find(p) == find(q); } public int count() { return count; } private void validate(int p) { int n = id.length; if (p \u003c 0 || p \u003e= n) { throw new IllegalArgumentException(\"index \" + p + \" is not between 0 and \" + (n-1)); } } public static void main(String[] args) { int n = StdIn.readInt(); UF uf = new UF(n); while (!StdIn.isEmpty()) { int p = StdIn.readInt(); int q = StdIn.readInt(); if (uf.find(p) == uf.find(q)) continue; uf.union(p, q); StdOut.println(p + \" \" + q); } StdOut.println(uf.count() + \" components\"); } } ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#union-find-算法的实现"},{"categories":["「算法第四版」"],"content":" Quick-Find public class QuickFindUF { private int[] id; // id[i] = component identifier of i private int count; // number of components public QuickFindUF(int n) { count = n; id = new int[n]; for (int i = 0; i \u003c n; i++) id[i] = i; } public void union(int p, int q) { validate(p); validate(q); int pID = id[p]; // needed for correctness int qID = id[q]; // to reduce the number of array accesses // p and q are already in the same component if (pID == qID) return; for (int i = 0; i \u003c id.length; i++) if (id[i] == pID) id[i] = qID; count--; } public int find(int p) { validate(p); return id[p]; } } Quick-Find 算法中，find 方法的时间复杂度为 O(1)，但 union 方法的时间复杂度为 O(n)。 ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:3:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#quick-find"},{"categories":["「算法第四版」"],"content":" Quick-Union public class QuickUnionUF { private int[] parent; // parent[i] = parent of i private int count; // number of components public QuickUnionUF(int n) { parent = new int[n]; count = n; for (int i = 0; i \u003c n; i++) { parent[i] = i; } } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootP] = rootQ; count--; } public int find(int p) { validate(p); while (p != parent[p]) p = parent[p]; return p; } } Quick-Union 算法中，h 表示树的高度，find 方法的时间复杂度为 O(h)，union 方法的时间复杂度为 2·O(h) + 1 = O(h)。 ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:3:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#quick-union"},{"categories":["「算法第四版」"],"content":" Weighted Quick-Union public class WeightedQuickUnionUF { private int[] parent; // parent[i] = parent of i private int[] size; // size[i] = number of elements in subtree rooted at i private int count; // number of components public WeightedQuickUnionUF(int n) { count = n; parent = new int[n]; size = new int[n]; for (int i = 0; i \u003c n; i++) { parent[i] = i; size[i] = 1; } } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; // make smaller root point to larger one if (size[rootP] \u003c size[rootQ]) { parent[rootP] = rootQ; size[rootQ] += size[rootP]; } else { parent[rootQ] = rootP; size[rootP] += size[rootQ]; } count--; } public int find(int p) { validate(p); while (p != parent[p]) p = parent[p]; return p; } } 加权 Quick-Union 算法在最坏情况下，即归并的两个树大小总是相等，此时能够保证对数级别的性能 O(logN)。 加权 Quick-Union 算法能够在合理时间范围内处理大规模动态连通性问题。 ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:3:3","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#weighted-quick-union"},{"categories":["「算法第四版」"],"content":" Weighted Quick-Union with Path Compresson public class WeightedQuickUnionWithPathCompression { private final int[] parent; private final int[] size; private int count; WeightedQuickUnionWithPathCompression(int n) { parent = new int[n]; size = new int[n]; for (int i = 0; i \u003c n; i++) { parent[i] = i; size[i] = 1; } count = n; } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; if (size[rootP] \u003c size[rootQ]) { parent[rootP] = rootQ; size[rootQ] += size[rootP]; } else { parent[rootQ] = rootP; size[rootP] += size[rootQ]; } count--; } public int find(int p) { validate(p); int root = p; while (root != parent[root]) { root = parent[root]; } // Path Compression while (parent[p] != root) { int temp = parent[p]; parent[p] = root; p = temp; } return root; } } 路经压缩的加权 Quick-Union 算法，find 方法能够得到几乎完全扁平化的树，使得算法的均摊成本接近 O(1)。 路经压缩的加权 Quick-Union 算法是本题的最优算法。 ","date":"2023-04-15","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/:3:4","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」Union-Find 算法","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_05_union-find%E7%AE%97%E6%B3%95/#weighted-quick-union-with-path-compresson"},{"categories":null,"content":"整理记录 Shell Script 语法","date":"2023-04-14","objectID":"/shell-script-%E6%95%B4%E7%90%86/","series":null,"tags":null,"title":"Shell Script 整理","uri":"/shell-script-%E6%95%B4%E7%90%86/"},{"categories":null,"content":" Shell 参数处理特殊字符 #!/bin/bash echo \"Starting program at $(date)\" # 1. $( CMD ) 运行 CMD 命令 echo \"Running program $0 with $# arguments with pid $$\" # 2. 见特殊字符表 for file in \"$@\"; do # 3. 见特殊字符表 grep foobar \"$file\" \u003e /dev/null 2\u003e /dev/null # 4. \"2\u003e /dev/null\" 把标准错误重定向到/dev/null if [[ $? -ne 0 ]]; then # 5. 见特殊字符表；在比较操作中使用双中括号 echo \"File $file does not have any foobar, adding one\" echo \"# foobar\" \u003e\u003e \"$file\" fi done ","date":"2023-04-14","objectID":"/shell-script-%E6%95%B4%E7%90%86/:1:0","series":null,"tags":null,"title":"Shell Script 整理","uri":"/shell-script-%E6%95%B4%E7%90%86/#shell-参数处理特殊字符"},{"categories":null,"content":" 特殊字符表 参数处理 说明 $0 Shell Script 名字 $# 参数个数 $$ 进程 PID $@ 所有参数 $? 上一条命令的返回码 ","date":"2023-04-14","objectID":"/shell-script-%E6%95%B4%E7%90%86/:1:1","series":null,"tags":null,"title":"Shell Script 整理","uri":"/shell-script-%E6%95%B4%E7%90%86/#特殊字符表"},{"categories":null,"content":" Test 命令的双中括号Differences Between Single and Double Brackets in Bash. ","date":"2023-04-14","objectID":"/shell-script-%E6%95%B4%E7%90%86/:1:2","series":null,"tags":null,"title":"Shell Script 整理","uri":"/shell-script-%E6%95%B4%E7%90%86/#test-命令的双中括号"},{"categories":null,"content":" Safe-bgsave 脚本整理 #!/bin/bash function help() # 1. 函数声明 { echo \"usage: safe-bgsave -t THRESHOLD -i INTERVAL -p PORT.\" echo \" safe-bgsave -t 20 -i 1 -p 7002\" exit } # success return 0; fail return 1. function safe_bgsave() { # check security local available=`free -g | grep Mem | awk '{print $7}'` # 2. awk 选取第 7 列 if [ ${available} -le ${THRESHOLD} ] then echo `date` \" Available memory: ${available} \u003c= threshold: ${THRESHOLD}. Do not process bgsave.\" \u003e\u003e ${LOG_PATH} 2\u003e\u00261 return 1 fi # bgsave local bgsave=`${REDIS_CLI} -p ${PORT} bgsave` echo `date` \" ${bgsave}.\" \u003e\u003e ${LOG_PATH} 2\u003e\u00261 # 3. 字符串拼接；\"2\u003e\u00261\" 将标准错误重定向到标准输出 sleep ${INTERVAL} local pid=`ps -ef | grep \"${PROCESS_NAME}\" | grep -v grep | awk '{print $2}'` while [ -n \"${pid}\" ] do available=`free -g | grep Mem | awk '{print $7}'` if [ ${available} -le ${THRESHOLD} ] then echo `date` \" bgsave failed. Available memory: ${available} \u003c= threshold: ${THRESHOLD}. Trying to kill process.\" \u003e\u003e ${LOG_PATH} 2\u003e\u00261 kill \"${pid}\" return 1 fi sleep ${INTERVAL} pid=`ps -ef | grep \"${PROCESS_NAME}\" | grep -v grep | awk '{print $2}'` done echo `date` \" bgsave success.\" \u003e\u003e ${LOG_PATH} 2\u003e\u00261 return 0 } # Begin [ $# -ne 6 ] \u0026\u0026 help # 4. 检查参数个数；调用 help 函数 while [ -n \"$1\" ] # 5. 参数赋值的写法 do case \"$1\" in -t) THRESHOLD=$2 shift 2 # 6. 将参数数组向左移动两位 ;; -i) INTERVAL=$2 shift 2 ;; -p) PORT=$2 shift 2 ;; *) help ;; esac done REDIS_CLI=\"redis-cli\" PROCESS_NAME=\"redis-rdb-bgsave\" LOG_PATH=\"/opt/data/redis/safe_bgsave.${PORT}.log\" safe_bgsave if [ $? -eq 1 ] then exit 1 fi exit 0 ","date":"2023-04-14","objectID":"/shell-script-%E6%95%B4%E7%90%86/:2:0","series":null,"tags":null,"title":"Shell Script 整理","uri":"/shell-script-%E6%95%B4%E7%90%86/#safe-bgsave-脚本整理"},{"categories":["「算法第四版」"],"content":"「算法第四版」算法分析","date":"2023-04-12","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」算法分析","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"},{"categories":["「算法第四版」"],"content":" 算法分析的方法 Observe some feature of the natural world, generally with precise measurements. Hypothesize a model that is consistent with the observations. Predict events using the hypothesis. Verify the predictions by making further observations. Validate by repeating until the hypothesis and observations agree. ","date":"2023-04-12","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」算法分析","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#算法分析的方法"},{"categories":["「算法第四版」"],"content":" 算法运行时间实验程序执行速度的快慢通常取决于问题的规模。 通过观察代码初步预测程序的执行时间。 使用类似 DoublingTest 方法不断增加问题规模并计时，进入“预测——验证”循环。 public class DoublingTest { public static double timeTrial(int N) { // Time ThreeSum.count() for N random 6-digit ints. int MAX = 1000000; int[] a = new int[N]; for (int i = 0; i \u003c N; i++) a[i] = StdRandom.uniformInt(-MAX, MAX); Stopwatch timer = new Stopwatch(); int cnt = ThreeSum.count(a); return timer.elapsedTime(); } public static void main(String[] args) { // Print table of running times. for (int N = 250; true; N += N) { // Print time for problem size N. double time = timeTrial(N); StdOut.printf(\"%7d %5.1f\\n\", N, time); } } } 分析实验数据，得到其运行时间的数学模型。 ","date":"2023-04-12","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」算法分析","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#算法运行时间实验"},{"categories":["「算法第四版」"],"content":" 运行时间的数学模型得到运行时间的数学模型步骤：（书：P114） 确定输入模型，定义问题规模 识别内循环 根据内循环中的操作确定成本模型 对于给定的输入，判断这些操作的执行频率 ","date":"2023-04-12","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」算法分析","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#运行时间的数学模型"},{"categories":["「算法第四版」"],"content":" 增长数量级 描述 增长的数量级 典型代码 说明 举例 常数级别 1 a = b + c 普通语句 两个数相加 对数级别 logN 二分查找 二分策略 二分查找 线性级别 N 循环 循环 循环查找最大元素 线性对数级别 NlogN 归并排序 Merge.sort 和 快速排序 Quick.sort 归并排序，快速排序 归并排序，快速排序 平方级别 N^2 选择排序 Selection.sort 和 插入排序 Insertion.sort 双层循环 选择排序，插入排序 立方级别 N^3 ThreeSum 三层循环 三层循环 三层循环 指数级别 2^N 第六章 穷举查找 检查所有子集 ","date":"2023-04-12","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:4:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」算法分析","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#增长数量级"},{"categories":["「算法第四版」"],"content":" 倍率实验通过倍率实验能够简单有效地预测任意程序的性能并判断它们运行时间大致的增长数量级，但对比值没有极限的算法无效。 public class DoublingRatio { public static double timeTrial(int N) { // Time ThreeSum.count() for N random 6-digit ints. int MAX = 1000000; int[] a = new int[N]; for (int i = 0; i \u003c N; i++) a[i] = StdRandom.uniformInt(-MAX, MAX); Stopwatch timer = new Stopwatch(); int cnt = ThreeSum.count(a); return timer.elapsedTime(); } public static void main(String[] args) { double prev = timeTrial(125); for (int N = 250; true; N += N) { double time = timeTrial(N); StdOut.printf(\"%6d %7.1f \", N, time); StdOut.printf(\"%5.1f\\n\", time / prev); prev = time; } } } 在有性能问题的情况家应该考虑对编写过的所有程序进行倍率实验，以便能找到性能问题。 ","date":"2023-04-12","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/:5:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」算法分析","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#倍率实验"},{"categories":["「算法第四版」"],"content":"「算法第四版」背包、队列和栈","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/"},{"categories":["「算法第四版」"],"content":" 背包背包 API： 背包 public class Bag\u003cItem\u003e implements Iterable\u003cItem\u003e Bag() 创建一个背包 void add(Item item) 添加一个元素 boolean isEmpty() 背包是否为空 int size() 背包中元素数量 背包是一种不支持从中删除元素的集合数据类型——他的目的是帮助用例收集元素并迭代遍历所有收集到的元素。 ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#背包"},{"categories":["「算法第四版」"],"content":" 背包的链表实现 import java.util.Iterator; public class Bag\u003cItem\u003e implements Iterable\u003cItem\u003e { private Node first; private class Node { Item item; Node next; } public void add(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; } @Override public Iterator\u003cItem\u003e iterator() { return new ListIterator(); } private class ListIterator implements Iterator\u003cItem\u003e { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:1:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#背包的链表实现"},{"categories":["「算法第四版」"],"content":" 先进先出（FIFO）队列队列 API： 先进先出（FIFO）队列 public class Queue\u003cItem\u003e implements Interable\u003cItem\u003e Queue() 创建空队列 void enqueue(Item item) 添加一个元素 Item dequeue() 删除最早添加的元素 boolean isEmpty() 队列是否为空 int size() 队列中的元素数量 先进先出队列是一种基于先进先出（FIFO）策略的集合类型。 ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#先进先出fifo队列"},{"categories":["「算法第四版」"],"content":" 队列的实现 队列的链表实现 import java.util.Iterator; public class Queue\u003cItem\u003e implements Iterable\u003cItem\u003e { private Node first; private Node last; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void enqueue(Item item) { Node oldLast = last; last = new Node(); last.item = item; last.next = null; if (isEmpty()) { first = last; } else { oldLast.next = last; } size++; } public Item dequeue() { Item item = first.item; first = first.next; if (isEmpty()) { last = null; } size--; return item; } @Override public Iterator\u003cItem\u003e iterator() { return new ListIterator(); } private class ListIterator implements Iterator\u003cItem\u003e { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:2:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#队列的实现"},{"categories":["「算法第四版」"],"content":" 队列的实现 队列的链表实现 import java.util.Iterator; public class Queue implements Iterable { private Node first; private Node last; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void enqueue(Item item) { Node oldLast = last; last = new Node(); last.item = item; last.next = null; if (isEmpty()) { first = last; } else { oldLast.next = last; } size++; } public Item dequeue() { Item item = first.item; first = first.next; if (isEmpty()) { last = null; } size--; return item; } @Override public Iterator iterator() { return new ListIterator(); } private class ListIterator implements Iterator { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:2:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#队列的链表实现"},{"categories":["「算法第四版」"],"content":" 后进先出（LIFO）栈栈 API： public class Stack\u003cItem\u003e implements Iterable\u003cItem\u003e Stack() 创建一个空栈 void push() 添加一个元素 Item pop() 删除最近添加的元素 boolean isEmpty() 栈是否为空 int size() 栈中元素数量 ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#后进先出lifo栈"},{"categories":["「算法第四版」"],"content":" 栈的实现 栈的数组实现 import java.util.Iterator; public class ResizingArrayStack\u003cItem\u003e implements Iterable\u003cItem\u003e { private Item[] array = (Item[]) new Object[1]; private int size = 0; public boolean isEmpty() { return size == 0; } public int size() { return size; } public void push(Item item) { if (size == array.length) { resize(2 * array.length); } array[size++] = item; } public Item pop() { Item item = array[--size]; array[size] = null; if (size \u003e 0 \u0026\u0026 size == array.length / 4) { resize(array.length / 2); } return item; } private void resize(int length) { Item[] temp = (Item[]) new Object[length]; for (int i = 0; i \u003c size; i++) { temp[i] = array[i]; } array = temp; } @Override public Iterator\u003cItem\u003e iterator() { return new ReverseArrayIterator(); } private class ReverseArrayIterator implements Iterator\u003cItem\u003e { private int index = size; @Override public boolean hasNext() { return index \u003e 0; } @Override public Item next() { return array[--index]; } } } 栈的链表实现 import java.util.Iterator; public class Stack\u003cItem\u003e implements Iterable\u003cItem\u003e { private Node first; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void push(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; size++; } public Item pop() { Item item = first.item; first = first.next; size--; return item; } @Override public Iterator\u003cItem\u003e iterator() { return new ListIterator(); } private class ListIterator implements Iterator\u003cItem\u003e { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:3:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#栈的实现"},{"categories":["「算法第四版」"],"content":" 栈的实现 栈的数组实现 import java.util.Iterator; public class ResizingArrayStack implements Iterable { private Item[] array = (Item[]) new Object[1]; private int size = 0; public boolean isEmpty() { return size == 0; } public int size() { return size; } public void push(Item item) { if (size == array.length) { resize(2 * array.length); } array[size++] = item; } public Item pop() { Item item = array[--size]; array[size] = null; if (size \u003e 0 \u0026\u0026 size == array.length / 4) { resize(array.length / 2); } return item; } private void resize(int length) { Item[] temp = (Item[]) new Object[length]; for (int i = 0; i \u003c size; i++) { temp[i] = array[i]; } array = temp; } @Override public Iterator iterator() { return new ReverseArrayIterator(); } private class ReverseArrayIterator implements Iterator { private int index = size; @Override public boolean hasNext() { return index \u003e 0; } @Override public Item next() { return array[--index]; } } } 栈的链表实现 import java.util.Iterator; public class Stack implements Iterable { private Node first; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void push(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; size++; } public Item pop() { Item item = first.item; first = first.next; size--; return item; } @Override public Iterator iterator() { return new ListIterator(); } private class ListIterator implements Iterator { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:3:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#栈的数组实现"},{"categories":["「算法第四版」"],"content":" 栈的实现 栈的数组实现 import java.util.Iterator; public class ResizingArrayStack implements Iterable { private Item[] array = (Item[]) new Object[1]; private int size = 0; public boolean isEmpty() { return size == 0; } public int size() { return size; } public void push(Item item) { if (size == array.length) { resize(2 * array.length); } array[size++] = item; } public Item pop() { Item item = array[--size]; array[size] = null; if (size \u003e 0 \u0026\u0026 size == array.length / 4) { resize(array.length / 2); } return item; } private void resize(int length) { Item[] temp = (Item[]) new Object[length]; for (int i = 0; i \u003c size; i++) { temp[i] = array[i]; } array = temp; } @Override public Iterator iterator() { return new ReverseArrayIterator(); } private class ReverseArrayIterator implements Iterator { private int index = size; @Override public boolean hasNext() { return index \u003e 0; } @Override public Item next() { return array[--index]; } } } 栈的链表实现 import java.util.Iterator; public class Stack implements Iterable { private Node first; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void push(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; size++; } public Item pop() { Item item = first.item; first = first.next; size--; return item; } @Override public Iterator iterator() { return new ListIterator(); } private class ListIterator implements Iterator { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:3:1","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#栈的链表实现"},{"categories":["「算法第四版」"],"content":" 栈的应用Dijkstra 双栈算术表达式求值算法 public class Evaluate { public static void main(String[] args) { Stack\u003cString\u003e ops = new Stack\u003c\u003e(); Stack\u003cDouble\u003e vals = new Stack\u003c\u003e(); while (!StdIn.isEmpty()) { String s = StdIn.readString(); switch (s) { case \"(\" -\u003e { ; } case \"+\", \"-\", \"*\", \"/\", \"sqrt\" -\u003e ops.push(s); case \")\" -\u003e { String op = ops.pop(); double v = vals.pop(); v = switch (op) { case \"+\" -\u003e vals.pop() + v; case \"-\" -\u003e vals.pop() - v; case \"*\" -\u003e vals.pop() * v; case \"/\" -\u003e vals.pop() / v; case \"sqrt\" -\u003e Math.sqrt(v); default -\u003e v; }; vals.push(v); } default -\u003e vals.push(Double.parseDouble(s)); } } StdOut.println(vals.pop()); } } ","date":"2023-03-19","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/:3:2","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」背包、队列和栈","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/#栈的应用"},{"categories":null,"content":"Volatile 变量与线程安全","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"},{"categories":null,"content":" 一个线程不安全的现象一个数组实现的环形缓冲区，变量 readPos 和 writePos 分别记录下一个读取的索引和下一个写入的索引。当缓冲区为空时，消费者会在数据存入缓冲区前等待。当缓冲区满时，生产者会等待将数据存入缓冲区。 public class RingBuffer\u003cItem\u003e { private final Item[] buffer; private int readPos; private int writePos; RingBuffer(int capacity) { this.buffer = (Item[]) new Object[capacity]; this.readPos = 0; this.writePos = 0; } public void write(Item item) { while (isFull()) ; buffer[writePos] = item; writePos = (writePos + 1) % buffer.length; } public Item read() { while (isEmpty()) ; Item item = buffer[readPos]; readPos = (readPos + 1) % buffer.length; return item; } private boolean isEmpty() { return readPos == writePos; } private boolean isFull() { return ((writePos + 1) % buffer.length) == readPos; } public static void main(String[] args) { RingBuffer\u003cInteger\u003e ringBuffer = new RingBuffer\u003c\u003e(10); Thread writer1 = new Thread(() -\u003e { for (int item = 0; item \u003c Integer.MAX_VALUE; item++) { ringBuffer.write(item); } }); writer1.start(); while (true) { StdOut.println(ringBuffer.read()); } } } 在运行此测试用例时发现两个线程都容易进入死循环。写入线程一直认为缓冲区是满的，消费线程一直认为缓冲区是空的。经过排查，此现象是 readPos 和 writePos 变量不一致导致的。 在写入线程中，writePos 变量只会被写入线程修改，因此该变量对于写入线程来说始终是最新值。而写入线程调用 isFull 方法的 readPos 变量会被读取线程修改，导致写入线程中 readPos 变量是旧数据。 在读取线程中，readPos 变量只会被读取线程修改，因此该变量对于读取线程来说始终是最新值。而读取线程调用 isEmpty 方法的 writePos 变量会被写入线程修改，导致读取线程中 writePos 变量是旧数据。 ","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:1:0","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#一个线程不安全的现象"},{"categories":null,"content":" 解决方案将 readPos 和 writePos 改为 volatile 变量，在这个场景中能够保证这两个变量的线程安全。 那么 volatile 变量在此场景中是如何保证线程安全的呢？ ","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:2:0","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#解决方案"},{"categories":null,"content":" volatile 变量机制","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:3:0","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#volatile-变量机制"},{"categories":null,"content":" 可见行保证对于非 volatile 变量，JVM 不会保证线程修改变量会被立即从 CPU 缓存中回写到主内存中。使得另一个线程可能会从主内存读取到该变量的旧值。 对于 volatile 变量，JVM 会保证线程每次都会从主内存中读取该变量。并且对该变量的修改会被立即回写到主内存。此时其余所有线程都会看到该变量的最新值。 ","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:3:1","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#可见行保证"},{"categories":null,"content":" happens-before 保证happens-before 保证会对指令重排序进行限制。 对 volatile 变量进行写入操作之前的所有指令不会因指令重排序导致这些指令在写入操作的后面； 对 volatile 变量进行读取操作之后的所有指令不会因指令重排序导致这些指令在写入操作的之前。 即本应在 volatile 变量读取与写入操作之间的指令，不会因为指令重排序导致这些指令在变量读取与写入操作之外。 ","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:3:2","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#happens-before-保证"},{"categories":null,"content":" volatile 变量何时是线程安全的？在以下两个场景，volatile 变量是线程安全的： 当只有一个线程向 volatile 变量写入，其余多个线程仅读取该变量时，总会读取最新的数据，此时是线程安全的； 当多个线程向 volatile 变量写入并且对变量的操作是原子操作（被写入的新值不依赖旧值），此时是线程安全的。 ","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:4:0","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#volatile-变量何时是线程安全的"},{"categories":null,"content":" 一个 volitile 变量例子 public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } ","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:5:0","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#一个-volitile-变量例子"},{"categories":null,"content":" 参考资料Concurrency in Java: “synchronized” and “volatile” keywords Volatile Variables and Thread Safety ","date":"2023-03-11","objectID":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/:6:0","series":null,"tags":null,"title":"Volatile 变量与线程安全","uri":"/volatile-%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/#参考资料"},{"categories":["Redis"],"content":"通过分析 Redis 异步删除源码，判断异步删除能否解决大 Key 过期阻塞主线程的问题。","date":"2023-03-04","objectID":"/redis%E5%8D%87%E7%BA%A7_01_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/","series":["Redis升级"],"tags":["Redis"],"title":"Redis 异步删除解决大 Key 过期阻塞问题可行性分析","uri":"/redis%E5%8D%87%E7%BA%A7_01_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/"},{"categories":["Redis"],"content":"自 Redis 4 版本引入了异步删除方法 unlink，官方对该接口的解释： “This command is very similar to DEL: it removes the specified keys. Just like DEL a key is ignored if it does not exist. However the command performs the actual memory reclaiming in a different thread, so it is not blocking, while DEL is. This is where the command name comes from: the command just unlinks the keys from the keyspace. The actual removal will happen later asynchronously.” 可知 unlink 与 del 用法相同，只不过内存回收在另一个不同线程中，内存回收操作在 unlink 方法调用结束之后，因此是非阻塞方法。 ","date":"2023-03-04","objectID":"/redis%E5%8D%87%E7%BA%A7_01_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/:0:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 异步删除解决大 Key 过期阻塞问题可行性分析","uri":"/redis%E5%8D%87%E7%BA%A7_01_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/#"},{"categories":["Redis"],"content":" 源码分析","date":"2023-03-04","objectID":"/redis%E5%8D%87%E7%BA%A7_01_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/:1:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 异步删除解决大 Key 过期阻塞问题可行性分析","uri":"/redis%E5%8D%87%E7%BA%A7_01_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/#源码分析"},{"categories":["Redis"],"content":" 异步删除流程同步删除与异步删除的方法入口分别为 delCommand 方法与 unlinkCommand 方法。 void delCommand(client *c) { delGenericCommand(c,server.lazyfree_lazy_user_del); } void unlinkCommand(client *c) { delGenericCommand(c,1); } 这两个方法都调用 delGenericCommand 方法，server.lazyfree_lazy_user_del 可通过配置文件配置，配置后可以使 del 命令与 unlink 命令完全相同。 /* This command implements DEL and LAZYDEL. */ void delGenericCommand(client *c, int lazy) { int numdel = 0, j; for (j = 1; j \u003c c-\u003eargc; j++) { expireIfNeeded(c-\u003edb,c-\u003eargv[j],0); // 判断传入的 lazy 值选择异步删除或同步删除 int deleted = lazy ? dbAsyncDelete(c-\u003edb,c-\u003eargv[j]) : dbSyncDelete(c-\u003edb,c-\u003eargv[j]); if (deleted) { signalModifiedKey(c,c-\u003edb,c-\u003eargv[j]); notifyKeyspaceEvent(NOTIFY_GENERIC, \"del\",c-\u003eargv[j],c-\u003edb-\u003eid); server.dirty++; numdel++; } } addReplyLongLong(c,numdel); } delGenericCommand 方法判断传入的 lazy 参数值决定异步删除或者同步删除。 /* Delete a key, value, and associated expiration entry if any, from the DB */ int dbSyncDelete(redisDb *db, robj *key) { return dbGenericDelete(db, key, 0); } /* Delete a key, value, and associated expiration entry if any, from the DB. If * the value consists of many allocations, it may be freed asynchronously. */ int dbAsyncDelete(redisDb *db, robj *key) { return dbGenericDelete(db, key, 1); } 同步删除和异步删除都是调用 dbGenericDelete 方法，仅传入的 async 参数不同。 /* Helper for sync and async delete. */ static int dbGenericDelete(redisDb *db, robj *key, int async) { /* Deleting an entry from the expires dict will not free the sds of * the key, because it is shared with the main dictionary. */ // 删除 expires 字典中该 key，但不会删除 SDS 结构，因为该 SDS 在 dict 字典中被共享。 if (dictSize(db-\u003eexpires) \u003e 0) dictDelete(db-\u003eexpires,key-\u003eptr); // 数据库字典中移除 key，不释放内存。 dictEntry *de = dictUnlink(db-\u003edict,key-\u003eptr); if (de) { robj *val = dictGetVal(de); /* Tells the module that the key has been unlinked from the database. */ moduleNotifyKeyUnlink(key,val,db-\u003eid); /* We want to try to unblock any client using a blocking XREADGROUP */ if (val-\u003etype == OBJ_STREAM) signalKeyAsReady(db,key,val-\u003etype); if (async) { // 异步释放内存 freeObjAsync(key, val, db-\u003eid); dictSetVal(db-\u003edict, de, NULL); } if (server.cluster_enabled) slotToKeyDelEntry(de, db); // 释放内存 dictFreeUnlinkedEntry(db-\u003edict,de); return 1; } else { return 0; } } /* You need to call this function to really free the entry after a call * to dictUnlink(). It's safe to call this function with 'he' = NULL. */ void dictFreeUnlinkedEntry(dict *d, dictEntry *he) { if (he == NULL) return; dictFreeKey(d, he); dictFreeVal(d, he); zfree(he); } dbGenericDelete 方法首先将 key 在 expires 字典中删除并释放内存，再在 dict 字典中移除该 key，但此时不释放内存。 通过 async 参数判断是否需要异步释放内存，若需要则会调用 freeObjAsync 方法进行异步释放内存，若不需要异步释放内存，则在 dictFreeUnlinkedEntry 方法中直接释放。 若进入 freeObjAsync 方法但不满足异步释放条件（在 freeObjAsync 方法中），也会在 dictFreeUnlinkedEntry 方法中直接释放。 /* If there are enough allocations to free the value object asynchronously, it * may be put into a lazy free list instead of being freed synchronously. The * lazy free list will be reclaimed in a different bio.c thread. If the value is * composed of a few allocations, to free in a lazy way is actually just * slower... So under a certain limit we just free the object synchronously. */ #define LAZYFREE_THRESHOLD 64 /* Free an object, if the object is huge enough, free it in async way. */ void freeObjAsync(robj *key, robj *obj, int dbid) { // 计算异步删除阈值 size_t free_effort = lazyfreeGetFreeEffort(key,obj,dbid); /* Note that if the object is shared, to reclaim it now it is not * possible. This rarely happens, however sometimes the implementation * of parts of the Redis core may call incrRefCount() to protect * objects, and then call dbDelete(). */ if (free_effort \u003e LAZYFREE_THRESHOLD \u0026\u0026 obj-\u003erefcount == 1) { atomicIncr(lazyfree_objects,1); // 任务超过异步删除阈值，创建异步删除任务 bioCreateLazyFreeJob(lazyfreeFreeObject,1,obj); } else { decrRefCount(obj); } } 重点看 freeObjAsync 方法，先计算该 key 的异步删除阈值，若大于阈值 64，则为该 key 创建异步删除任务。 void bioCreateLazyFreeJob(lazy_free_fn free_fn, int arg_count, ...) { va_list valist; /* Allocate memory for the job structure and all required * a","date":"2023-03-04","objectID":"/redis%E5%8D%87%E7%BA%A7_01_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/:1:1","series":["Redis升级"],"tags":["Redis"],"title":"Redis 异步删除解决大 Key 过期阻塞问题可行性分析","uri":"/redis%E5%8D%87%E7%BA%A7_01_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/#异步删除流程"},{"categories":["Redis"],"content":" 惰性删除与异步删除Redis 惰性删除策略是否采用异步删除策略？ 在惰性删除中，Redis 在操作 Key 时会先判断该 Key 是否过期，若过期则会删除该 Key。 /* This function is called when we are going to perform some operation * in a given key, but such key may be already logically expired even if * it still exists in the database. The main way this function is called * is via lookupKey*() family of functions. * * The behavior of the function depends on the replication role of the * instance, because by default replicas do not delete expired keys. They * wait for DELs from the master for consistency matters. However even * replicas will try to have a coherent return value for the function, * so that read commands executed in the replica side will be able to * behave like if the key is expired even if still present (because the * master has yet to propagate the DEL). * * In masters as a side effect of finding a key which is expired, such * key will be evicted from the database. Also this may trigger the * propagation of a DEL/UNLINK command in AOF / replication stream. * * On replicas, this function does not delete expired keys by default, but * it still returns 1 if the key is logically expired. To force deletion * of logically expired keys even on replicas, use the EXPIRE_FORCE_DELETE_EXPIRED * flag. Note though that if the current client is executing * replicated commands from the master, keys are never considered expired. * * On the other hand, if you just want expiration check, but need to avoid * the actual key deletion and propagation of the deletion, use the * EXPIRE_AVOID_DELETE_EXPIRED flag. * * The return value of the function is 0 if the key is still valid, * otherwise the function returns 1 if the key is expired. */ int expireIfNeeded(redisDb *db, robj *key, int flags) { if (!keyIsExpired(db,key)) return 0; /* If we are running in the context of a replica, instead of * evicting the expired key from the database, we return ASAP: * the replica key expiration is controlled by the master that will * send us synthesized DEL operations for expired keys. The * exception is when write operations are performed on writable * replicas. * * Still we try to return the right information to the caller, * that is, 0 if we think the key should be still valid, 1 if * we think the key is expired at this time. * * When replicating commands from the master, keys are never considered * expired. */ if (server.masterhost != NULL) { if (server.current_client == server.master) return 0; if (!(flags \u0026 EXPIRE_FORCE_DELETE_EXPIRED)) return 1; } /* In some cases we're explicitly instructed to return an indication of a * missing key without actually deleting it, even on masters. */ if (flags \u0026 EXPIRE_AVOID_DELETE_EXPIRED) return 1; /* If clients are paused, we keep the current dataset constant, * but return to the client what we believe is the right state. Typically, * at the end of the pause we will properly expire the key OR we will * have failed over and the new primary will send us the expire. */ if (checkClientPauseTimeoutAndReturnIfPaused()) return 1; /* Delete the key */ // 删除 key deleteExpiredKeyAndPropagate(db,key); return 1; } expireIfNeeded 方法会调用 deleteExpiredKeyAndPropagate 方法删除 key。 删除 key 时会读取 server.lazyfree_lazy_expire 配置决定删除策略。server.lazyfree_lazy_expire 可在配置文件中配置，配置后惰性删除将采用异步删除策略。 /* Delete the specified expired key and propagate expire. */ void deleteExpiredKeyAndPropagate(redisDb *db, robj *keyobj) { mstime_t expire_latency; latencyStartMonitor(expire_latency); if (server.lazyfree_lazy_expire) // 采用异步删除策略 dbAsyncDelete(db,keyobj); else dbSyncDelete(db,keyobj); latencyEndMonitor(expire_latency); latencyAddSampleIfNeeded(\"expire-del\",expire_latency); notifyKeyspaceEvent(NOTIFY_EXPIRED,\"expired\",keyobj,db-\u003eid); signalModifiedKey(NULL, db, keyobj); propagateDeletion(db,keyobj,server.lazyfree_lazy_expire); server.stat_expiredkeys++; } 结论：Redis 惰性删除在配置后可采用异步删除策略。 ","date":"2023-03-04","objectID":"/redis%E5%8D%87%E7%BA%A7_01_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/:1:2","series":["Redis升级"],"tags":["Redis"],"title":"Redis 异步删除解决大 Key 过期阻塞问题可行性分析","uri":"/redis%E5%8D%87%E7%BA%A7_01_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/#惰性删除与异步删除"},{"categories":["Redis"],"content":" 定时删除与异步删除定时任务 serverCron 方法最终会调用 activeExpireCycleTryExpire 方法，该方法仍会调用 deleteExpiredKeyAndPropagate 方法。 /* Helper function for the activeExpireCycle() function. * This function will try to expire the key that is stored in the hash table * entry 'de' of the 'expires' hash table of a Redis database. * * If the key is found to be expired, it is removed from the database and * 1 is returned. Otherwise no operation is performed and 0 is returned. * * When a key is expired, server.stat_expiredkeys is incremented. * * The parameter 'now' is the current time in milliseconds as is passed * to the function to avoid too many gettimeofday() syscalls. */ int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) { long long t = dictGetSignedIntegerVal(de); if (now \u003e t) { sds key = dictGetKey(de); robj *keyobj = createStringObject(key,sdslen(key)); // 删除 key deleteExpiredKeyAndPropagate(db,keyobj); decrRefCount(keyobj); return 1; } else { return 0; } } 结论：Redis 定时删除在配置后可采用异步删除策略。 ","date":"2023-03-04","objectID":"/redis%E5%8D%87%E7%BA%A7_01_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/:1:3","series":["Redis升级"],"tags":["Redis"],"title":"Redis 异步删除解决大 Key 过期阻塞问题可行性分析","uri":"/redis%E5%8D%87%E7%BA%A7_01_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/#定时删除与异步删除"},{"categories":["Redis"],"content":" 结论异步删除策略能够在删除大 Key 时避免主线程阻塞，惰性删除与定时删除在配置后均可采用异步删除策略，因此异步删除能够解决大 Key 过期引起的主线程阻塞问题。 ","date":"2023-03-04","objectID":"/redis%E5%8D%87%E7%BA%A7_01_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/:2:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 异步删除解决大 Key 过期阻塞问题可行性分析","uri":"/redis%E5%8D%87%E7%BA%A7_01_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/#结论"},{"categories":["Redis"],"content":"记录Redis升级流程。","date":"2023-03-03","objectID":"/redis%E5%8D%87%E7%BA%A7_00_%E5%BC%80%E7%AF%87/","series":["Redis升级"],"tags":["Redis"],"title":"Redis 升级——开篇","uri":"/redis%E5%8D%87%E7%BA%A7_00_%E5%BC%80%E7%AF%87/"},{"categories":["Redis"],"content":" 现版本存在的问题目前在生产环境中部署的旧版本Redis存在的问题： 大 key 过期删除引发集群节点阻塞失去响应不可用； 内存碎片高，内存使用率低； 运维时，手动主从切换总会产生复制风暴问题，主从无法同步； bgsave 内存消耗较高，有 OOM 风险。 ","date":"2023-03-03","objectID":"/redis%E5%8D%87%E7%BA%A7_00_%E5%BC%80%E7%AF%87/:1:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 升级——开篇","uri":"/redis%E5%8D%87%E7%BA%A7_00_%E5%BC%80%E7%AF%87/#现版本存在的问题"},{"categories":["Redis"],"content":" 推进版本升级由于以上原因，开始推进 Redis 版本升级。 版本升级工作流程： 通过文档与源码，调研 Redis 新特性； 客户端兼容性改造； 功能测试、性能测试和稳定性测试； 开发配套监控和运维工具； 推进上线。 ","date":"2023-03-03","objectID":"/redis%E5%8D%87%E7%BA%A7_00_%E5%BC%80%E7%AF%87/:2:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 升级——开篇","uri":"/redis%E5%8D%87%E7%BA%A7_00_%E5%BC%80%E7%AF%87/#推进版本升级"},{"categories":["「算法第四版」"],"content":"「算法第四版」欧几里得算法求最大公因数","date":"2023-02-27","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」欧几里得算法求最大公因数","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/"},{"categories":["「算法第四版」"],"content":" 自然语言描述计算两个非负整数 p 和 q 的最大公约数：若 q 是 0，则最大公约数为 p。否则，将 p 除以 q 得到余数 r，p 和 q 的最大公约数即为 q 和 r 的最大公约数。 ","date":"2023-02-27","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」欧几里得算法求最大公因数","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/#自然语言描述"},{"categories":["「算法第四版」"],"content":" 递归写法 public class Euclid { public static int gcd(int p, int q) { if (q == 0) return p; int r = p % q; return gcd(q, r); } } ","date":"2023-02-27","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」欧几里得算法求最大公因数","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/#递归写法"},{"categories":["「算法第四版」"],"content":" 循环写法 public class Euclid { public static int gcd(int p, int q) { if (q == 0) return p; while (q != 0) { int r = p % q; p = q; q = r; } return p; } } ","date":"2023-02-27","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」欧几里得算法求最大公因数","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/#循环写法"},{"categories":["「算法第四版」"],"content":"「算法第四版」二分查找","date":"2023-02-26","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」二分查找","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["「算法第四版」"],"content":" 前提条件查找的数组是有序的。 ","date":"2023-02-26","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」二分查找","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#前提条件"},{"categories":["「算法第四版」"],"content":" 递归写法 public class BinarySearch { public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1); } public static int rank(int key, int[] a, int lo, int hi) { if (lo \u003e hi) return -1; int mid = lo + (hi - lo) / 2; if (key \u003c a[mid]) return rank(key, a, lo, hi - 1); else if (key \u003e a[mid]) return rank(key, a, lo + 1, hi); else return mid; } } ","date":"2023-02-26","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:2:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」二分查找","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#递归写法"},{"categories":["「算法第四版」"],"content":" 循环写法 public class BinarySearch { public static int rank(int key, int[] a) { int lo = 0; int hi = a.length - 1; while (lo \u003c hi) { int mid = lo + (hi - lo) / 2; if (key \u003c a[mid]) hi = lo - 1; else if (key \u003e a[mid]) lo = hi + 1; else return mid; } return -1; } } ","date":"2023-02-26","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」二分查找","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#循环写法"},{"categories":["「算法第四版」"],"content":" 二分查找 key 的最小索引 public class BinarySearch { public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1); } public static int rank(int[] array, int key, int lo, int hi) { while (lo \u003c= hi) { int mid = lo + ((hi - lo) \u003e\u003e 1); if (key \u003c= array[mid]) { hi = mid - 1; } else { lo = mid + 1; } } if (lo == array.length) return -1; return array[lo] == key ? lo : -1; } } ","date":"2023-02-26","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」二分查找","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#二分查找-key-的最小索引"},{"categories":["「算法第四版」"],"content":" 二分查找极小(大)值 public class BinarySearch { public static int partialMin(int[] array) { assert array != null \u0026\u0026 array.length \u003e 0; int lo = 0; int hi = array.length - 1; while (lo \u003c= hi) { int mid = lo + ((hi - lo) \u003e\u003e 1); if (mid == 0 || mid == array.length - 1) break; if (array[mid] \u003c array[mid - 1] \u0026\u0026 array[mid] \u003c array[mid + 1]) { return mid; } else if (array[mid - 1] \u003c= array[mid + 1]) { hi = mid - 1; } else { lo = mid + 1; } } return -1; } } ","date":"2023-02-26","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:5:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」二分查找","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#二分查找极小大值"},{"categories":["「算法第四版」"],"content":"「算法第四版」阅读开篇","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」阅读开篇","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/"},{"categories":["「算法第四版」"],"content":" 本系列文章作用2023 年计划将「算法第四版」认真阅读一遍，在博客中整理常用的算法，把书读薄，时常复习，提高编码水平。 习题仓库：https://github.com/Nanciico/algs4 加油！ ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/:1:0","series":["「算法第四版」阅读笔记"],"tags":["「算法第四版」"],"title":"「算法第四版」阅读开篇","uri":"/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/#本系列文章作用"},{"categories":null,"content":" 关于我 姓名: Shuyang 职业: 后端程序员，负责 Redis 相关工作 ","date":"2022-10-13","objectID":"/about/:1:0","series":null,"tags":null,"title":"关于","uri":"/about/#关于我"}]