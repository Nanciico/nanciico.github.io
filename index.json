[{"categories":["设计模式"],"content":"设计模式 —— 组合模式","date":"2024-05-10","objectID":"/posts/design_patterns/design_patterns_08/","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 组合模式","uri":"/posts/design_patterns/design_patterns_08/"},{"categories":["设计模式"],"content":"组合模式是一种结构型设计模式，你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们。 ","date":"2024-05-10","objectID":"/posts/design_patterns/design_patterns_08/:0:0","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 组合模式","uri":"/posts/design_patterns/design_patterns_08/#"},{"categories":["设计模式"],"content":" 1 组合模式结构 组合模式结构图 组件（Component）：接口描述了树中简单项目和复杂项目所共有的操作。 叶节点（Leaf）：树的基本结构，它不包含子项目。 容器（Container）：又名“组合（Composite）”。是包含叶节点或其他容器等子项目的单位。容器不知道其子项目所属的具体类，它只通过通用的组件接口与其子项目交互。 客户端（Client）：客户端只通过组件接口与所有项目交互。 ","date":"2024-05-10","objectID":"/posts/design_patterns/design_patterns_08/:1:0","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 组合模式","uri":"/posts/design_patterns/design_patterns_08/#组合模式结构"},{"categories":["设计模式"],"content":" 2 组合模式的应用场景 如果你需要实现树状对象结构，可以使用组合模式。组合模式为你提供了两种共享公共接口的基本元素类型：简单叶节点和复杂容器。容器中可以包含叶节点和其他容器。这使得你可以构建树状嵌套递归对象结构。 如果你希望客户端代码以相同方式处理简单和复杂元素，可以使用该模式。 ","date":"2024-05-10","objectID":"/posts/design_patterns/design_patterns_08/:2:0","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 组合模式","uri":"/posts/design_patterns/design_patterns_08/#组合模式的应用场景"},{"categories":["设计模式"],"content":" 3 桥接模式的优缺点","date":"2024-05-10","objectID":"/posts/design_patterns/design_patterns_08/:3:0","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 组合模式","uri":"/posts/design_patterns/design_patterns_08/#桥接模式的优缺点"},{"categories":["设计模式"],"content":" 3.1 优点 可以利用多态和递归机制更方便地使用复杂树结构。 开闭原则。无需更改现有代码，你就可以在应用中添加新元素，使其成为对象树的一部分。 ","date":"2024-05-10","objectID":"/posts/design_patterns/design_patterns_08/:3:1","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 组合模式","uri":"/posts/design_patterns/design_patterns_08/#优点"},{"categories":["设计模式"],"content":" 3.2 缺点 对于功能差异较大的类，提供公共接口或许会有困难。 ","date":"2024-05-10","objectID":"/posts/design_patterns/design_patterns_08/:3:2","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 组合模式","uri":"/posts/design_patterns/design_patterns_08/#缺点"},{"categories":["设计模式"],"content":" 4 代码示例组合可以通过将同一抽象或接口类型的实例放入树状结构的行为方法来轻松识别。 C# using Composite.Conceptual; Client.Main(); namespace Composite.Conceptual { // The base Component class declares common operations for both simple and // complex objects of a composition. abstract class Component { public Component() { } // The base Component may implement some default behavior or leave it to // concrete classes (by declaring the method containing the behavior as // \"abstract\"). public abstract string Operation(); public virtual void Add(Component component) { throw new NotImplementedException(); } public virtual void Remove(Component component) { throw new NotImplementedException(); } // You can provide a method that lets the client code figure out whether // a component can bear children. public virtual bool IsComposite() { return true; } } // The Leaf class represents the end objects of a composition. A leaf can't // have any children. // // Usually, it's the Leaf objects that do the actual work, whereas Composite // objects only delegate to their sub-components. class Leaf : Component { public override string Operation() { return \"Leaf\"; } public override bool IsComposite() { return false; } } // The Composite class represents the complex components that may have // children. Usually, the Composite objects delegate the actual work to // their children and then \"sum-up\" the result. class Composite : Component { protected List\u003cComponent\u003e _children = []; public override void Add(Component component) { _children.Add(component); } public override void Remove(Component component) { _children.Remove(component); } // The Composite executes its primary logic in a particular way. It // traverses recursively through all its children, collecting and // summing their results. Since the composite's children pass these // calls to their children and so forth, the whole object tree is // traversed as a result. public override string Operation() { int i = 0; string result = \"Branch(\"; foreach (Component component in _children) { result += component.Operation(); if (i != this._children.Count - 1) { result += \"+\"; } i++; } return result + \")\"; } } class Client { public static void Main() { // This way the client code can support the simple leaf // components... var leaf = new Leaf(); Console.WriteLine(\"Client: I get a simple component:\"); ClientCode(leaf); // ...as well as the complex composites. var tree = new Composite(); var branch1 = new Composite(); branch1.Add(new Leaf()); branch1.Add(new Leaf()); var branch2 = new Composite(); branch2.Add(new Leaf()); tree.Add(branch1); tree.Add(branch2); Console.WriteLine(\"Client: Now I've got a composite tree:\"); ClientCode(tree); Console.Write(\"Client: I don't need to check the components classes even when managing the tree:\\n\"); ClientCode2(tree, leaf); } // The client code works with all of the components via the base // interface. public static void ClientCode(Component leaf) { Console.WriteLine($\"RESULT: {leaf.Operation()}\\n\"); } // Thanks to the fact that the child-management operations are declared // in the base Component class, the client code can work with any // component, simple or complex, without depending on their concrete // classes. public static void ClientCode2(Component component1, Component component2) { if (component1.IsComposite()) { component1.Add(component2); } Console.WriteLine($\"RESULT: {component1.Operation()}\"); } } } ","date":"2024-05-10","objectID":"/posts/design_patterns/design_patterns_08/:4:0","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 组合模式","uri":"/posts/design_patterns/design_patterns_08/#代码示例"},{"categories":["设计模式"],"content":"设计模式 —— 桥接模式","date":"2024-05-09","objectID":"/posts/design_patterns/design_patterns_07/","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 桥接模式","uri":"/posts/design_patterns/design_patterns_07/"},{"categories":["设计模式"],"content":"桥接模式是一种结构型设计模式，可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。 ","date":"2024-05-09","objectID":"/posts/design_patterns/design_patterns_07/:0:0","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 桥接模式","uri":"/posts/design_patterns/design_patterns_07/#"},{"categories":["设计模式"],"content":" 1 桥接模式结构适配器实现了其中一个对象的接口，并对另一个对象进行封装。 桥接模式结构图 抽象部分（Abstraction）：提供高层控制逻辑，依赖于完成底层实际工作的实现对象。 实现部分（Implementation）：为所有具体实现声明通用接口。抽象部分仅能通过在这里声明的方法与实现对象交互。 具体实现（Concrete Implementations）：具体实现中包括特定于平台的代码。 精确抽象（Refined Abstraction）：提供控制逻辑的变体。与其父类一样，它们通过通用实现接口与不同的实现进行交互。 客户端（Client）：客户端需要将抽象对象与一个实现对象连接起来。但仅关心如何与抽象部分合作。 ","date":"2024-05-09","objectID":"/posts/design_patterns/design_patterns_07/:1:0","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 桥接模式","uri":"/posts/design_patterns/design_patterns_07/#桥接模式结构"},{"categories":["设计模式"],"content":" 2 桥接模式的应用场景 如果你想要拆分或重组一个具有多重功能的庞杂类（例如能与多个数据库服务器进行交互的类），可以使用桥接模式。 如果你希望在几个独立维度上扩展一个类， 可使用该模式。 如果你需要在运行时切换不同实现方法， 可使用桥接模式。 ","date":"2024-05-09","objectID":"/posts/design_patterns/design_patterns_07/:2:0","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 桥接模式","uri":"/posts/design_patterns/design_patterns_07/#桥接模式的应用场景"},{"categories":["设计模式"],"content":" 3 桥接模式的优缺点","date":"2024-05-09","objectID":"/posts/design_patterns/design_patterns_07/:3:0","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 桥接模式","uri":"/posts/design_patterns/design_patterns_07/#桥接模式的优缺点"},{"categories":["设计模式"],"content":" 3.1 优点 客户端代码仅与高层抽象部分进行互动，不会接触到平台的详细信息。因此可以创建与平台无关的类和程序。 开闭原则。你可以新增抽象部分和实现部分，且它们之间不会相互影响。 单一职责原则。抽象部分专注于处理高层逻辑，实现部分处理平台细节。 ","date":"2024-05-09","objectID":"/posts/design_patterns/design_patterns_07/:3:1","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 桥接模式","uri":"/posts/design_patterns/design_patterns_07/#优点"},{"categories":["设计模式"],"content":" 3.2 缺点 对高内聚的类使用该模式可能会让代码更加复杂。 ","date":"2024-05-09","objectID":"/posts/design_patterns/design_patterns_07/:3:2","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 桥接模式","uri":"/posts/design_patterns/design_patterns_07/#缺点"},{"categories":["设计模式"],"content":" 4 代码示例 C# using Bridge.Conceptual; Client.Main(); namespace Bridge.Conceptual { // The Abstraction defines the interface for the \"control\" part of the two // class hierarchies. It maintains a reference to an object of the // Implementation hierarchy and delegates all of the real work to this // object. class Abstraction { protected IImplementation _implementation; public Abstraction(IImplementation implementation) { _implementation = implementation; } public virtual string Operation() { return \"Abstract: Base operation with:\\n\" + _implementation.OperationImplementation(); } } // You can extend the Abstraction without changing the Implementation // classes. class ExtendedAbstraction : Abstraction { public ExtendedAbstraction(IImplementation implementation) : base(implementation) { } public override string Operation() { return \"ExtendedAbstraction: Extended operation with:\\n\" + _implementation.OperationImplementation(); } } // The Implementation defines the interface for all implementation classes. // It doesn't have to match the Abstraction's interface. public interface IImplementation { string OperationImplementation(); } // Each Concrete Implementation corresponds to a specific platform and // implements the Implementation interface using that platform's API. class ConcreteImplementationA : IImplementation { public string OperationImplementation() { return \"ConcreteImplementationA: The result in platform A.\\n\"; } } class ConcreteImplementationB : IImplementation { public string OperationImplementation() { return \"ConcreteImplementationB: The result in platform B.\\n\"; } } class Client { public static void Main() { var abstraction = new Abstraction(new ConcreteImplementationA()); ClientCode(abstraction); Console.WriteLine(); abstraction = new Abstraction(new ConcreteImplementationB()); ClientCode(abstraction); } // Except for the initialization phase, where an Abstraction object gets // linked with a specific Implementation object, the client code should // only depend on the Abstraction class. This way the client code can // support any abstraction-implementation combination. public static void ClientCode(Abstraction abstraction) { Console.Write(abstraction.Operation()); } } } ","date":"2024-05-09","objectID":"/posts/design_patterns/design_patterns_07/:4:0","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 桥接模式","uri":"/posts/design_patterns/design_patterns_07/#代码示例"},{"categories":["设计模式"],"content":"设计模式 —— 适配器模式","date":"2024-05-08","objectID":"/posts/design_patterns/design_patterns_06/","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 适配器模式","uri":"/posts/design_patterns/design_patterns_06/"},{"categories":["设计模式"],"content":"适配器模式是一种结构型设计模式，它能使接口不兼容的对象能够相互合作。 ","date":"2024-05-08","objectID":"/posts/design_patterns/design_patterns_06/:0:0","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 适配器模式","uri":"/posts/design_patterns/design_patterns_06/#"},{"categories":["设计模式"],"content":" 1 适配器模式结构","date":"2024-05-08","objectID":"/posts/design_patterns/design_patterns_06/:1:0","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 适配器模式","uri":"/posts/design_patterns/design_patterns_06/#适配器模式结构"},{"categories":["设计模式"],"content":" 1.1 对象适配器适配器实现了其中一个对象的接口，并对另一个对象进行封装。 对象适配器结构图 客户端（Client）：包含当前程序业务逻辑的类。客户端代码只需通过接口与适配器交互即可，无需与具体的适配器类耦合。 客户端接口（Client Interface）：描述了其他类与客户端代码合作时必须遵循的协议。 服务（Service）：服务中有一些功能类（通常来自第三方或遗留系统）。客户端与其接口不兼容，因此无法直接调用其功能。 适配器（Adapter）是一个可以同时与客户端和服务交互的类：它在实现客户端接口的同时封装了服务对象。适配器接受客户端通过适配器接口发起的调用，并将其转换为适用于被封装服务对象的调用。 ","date":"2024-05-08","objectID":"/posts/design_patterns/design_patterns_06/:1:1","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 适配器模式","uri":"/posts/design_patterns/design_patterns_06/#对象适配器"},{"categories":["设计模式"],"content":" 1.2 类适配器适配器同时继承两个对象的接口。这种方式仅能在支持多重继承的编程语言中实现，例如 C++。 类适配器结构图 类适配器不需要封装任何对象，因为它同时继承了客户端和服务的行为。适配功能在重写的方法中完成。最后生成的适配器可替代已有的客户端类进行使用。 ","date":"2024-05-08","objectID":"/posts/design_patterns/design_patterns_06/:1:2","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 适配器模式","uri":"/posts/design_patterns/design_patterns_06/#类适配器"},{"categories":["设计模式"],"content":" 2 适配器模式的应用场景 当你希望使用某个类，但是其接口与其他代码不兼容时，可以使用适配器类。适配器模式允许你创建一个中间层类，其可作为代码与遗留类、第三方类或提供怪异接口的类之间的转换器。 ","date":"2024-05-08","objectID":"/posts/design_patterns/design_patterns_06/:2:0","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 适配器模式","uri":"/posts/design_patterns/design_patterns_06/#适配器模式的应用场景"},{"categories":["设计模式"],"content":" 3 适配器模式的优缺点","date":"2024-05-08","objectID":"/posts/design_patterns/design_patterns_06/:3:0","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 适配器模式","uri":"/posts/design_patterns/design_patterns_06/#适配器模式的优缺点"},{"categories":["设计模式"],"content":" 3.1 优点 符合单一职责原则，可以将接口或数据转换代码从程序主要业务逻辑中分离。 开闭原则。只要客户端代码通过客户端接口与适配器进行交互，你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。 ","date":"2024-05-08","objectID":"/posts/design_patterns/design_patterns_06/:3:1","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 适配器模式","uri":"/posts/design_patterns/design_patterns_06/#优点"},{"categories":["设计模式"],"content":" 3.2 缺点 代码整体复杂度增加，因为你需要新增一系列接口和类。 ","date":"2024-05-08","objectID":"/posts/design_patterns/design_patterns_06/:3:2","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 适配器模式","uri":"/posts/design_patterns/design_patterns_06/#缺点"},{"categories":["设计模式"],"content":" 4 代码示例适配器可以通过以不同抽象或接口类型实例为参数的构造函数来识别。当适配器的任何方法被调用时，它会将参数转换为合适的格式，然后将调用定向到其封装对象中的一个或多个方法。 C# using Adapter.Conceptual; Client.Main(); namespace Adapter.Conceptual { // The Target defines the domain-specific interface used by the client code. public interface ITarget { string GetRequest(); } // The Adaptee contains some useful behavior, but its interface is // incompatible with the existing client code. The Adaptee needs some // adaptation before the client code can use it. class Adaptee { public string GetSpecificRequest() { return \"Specific request.\"; } } // The Adapter makes the Adaptee's interface compatible with the Target's // interface. class Adapter : ITarget { private readonly Adaptee _adaptee; public Adapter(Adaptee adaptee) { _adaptee = adaptee; } public string GetRequest() { return $\"This is '{_adaptee.GetSpecificRequest()}'\"; } } public class Client { public static void Main() { var adaptee = new Adaptee(); var target = new Adapter(adaptee); Console.WriteLine(\"Adaptee interface is incompatible with the client.\"); Console.WriteLine(\"But with adapter client can call it's method.\"); Console.WriteLine(target.GetRequest()); } } } ","date":"2024-05-08","objectID":"/posts/design_patterns/design_patterns_06/:4:0","series":["设计模式 学习笔记"],"tags":["设计模式","结构型设计模式"],"title":"设计模式 —— 适配器模式","uri":"/posts/design_patterns/design_patterns_06/#代码示例"},{"categories":["设计模式"],"content":"设计模式 —— 单例模式","date":"2024-05-07","objectID":"/posts/design_patterns/design_patterns_05/","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 单例模式","uri":"/posts/design_patterns/design_patterns_05/"},{"categories":["设计模式"],"content":"单例模式是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。 单例模式解决了两个问题： 保证一个类只有一个实例； 为该实例提供一个全局访问节点。 单例模式类，既需要提供创建实例的操作，又需要提供获取实例的操作，因此违反了单一职责原则。 ","date":"2024-05-07","objectID":"/posts/design_patterns/design_patterns_05/:0:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 单例模式","uri":"/posts/design_patterns/design_patterns_05/#"},{"categories":["设计模式"],"content":" 1 单例模式结构 单例模式结构结构图 单例（Singleton）：单例类声明 get­Instance 静态方法来返回其所属类的一个相同实例。单例的构造函数必须对客户端代码隐藏。调用 getInstance 方法必须是获取单例对象的唯一方式。 ","date":"2024-05-07","objectID":"/posts/design_patterns/design_patterns_05/:1:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 单例模式","uri":"/posts/design_patterns/design_patterns_05/#单例模式结构"},{"categories":["设计模式"],"content":" 2 单例模式的应用场景程序中的某个类对于所有客户端只有一个可用的实例，可以使用单例模式。 ","date":"2024-05-07","objectID":"/posts/design_patterns/design_patterns_05/:2:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 单例模式","uri":"/posts/design_patterns/design_patterns_05/#单例模式的应用场景"},{"categories":["设计模式"],"content":" 3 单例模式的优缺点","date":"2024-05-07","objectID":"/posts/design_patterns/design_patterns_05/:3:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 单例模式","uri":"/posts/design_patterns/design_patterns_05/#单例模式的优缺点"},{"categories":["设计模式"],"content":" 3.1 优点 保证一个类只有一个实例。 获得了一个指向该实例的全局访问节点。 仅在首次请求单例对象时对其进行初始化。 ","date":"2024-05-07","objectID":"/posts/design_patterns/design_patterns_05/:3:1","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 单例模式","uri":"/posts/design_patterns/design_patterns_05/#优点"},{"categories":["设计模式"],"content":" 3.2 缺点 违反了单一职责原则。 单例模式可能掩盖不良设计，比如程序各组件之间相互了解过多等。 该模式在多线程环境下需要进行特殊处理，避免多个线程多次创建单例对象。 单例的客户端代码单元测试可能会比较困难。 ","date":"2024-05-07","objectID":"/posts/design_patterns/design_patterns_05/:3:2","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 单例模式","uri":"/posts/design_patterns/design_patterns_05/#缺点"},{"categories":["设计模式"],"content":" 4 代码示例","date":"2024-05-07","objectID":"/posts/design_patterns/design_patterns_05/:4:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 单例模式","uri":"/posts/design_patterns/design_patterns_05/#代码示例"},{"categories":["设计模式"],"content":" 4.1 基础单例 C# using Singleton.Conceptual; Client.Main(); namespace Singleton.Conceptual { // The Singleton class defines the `GetInstance` method that serves as an // alternative to constructor and lets clients access the same instance of // this class over and over. // EN : The Singleton should always be a 'sealed' class to prevent class // inheritance through external classes and also through nested classes. public sealed class Singleton { // The Singleton's constructor should always be private to prevent // direct construction calls with the `new` operator. private Singleton() { } private static Singleton? _instance; // This is the static method that controls the access to the singleton // instance. On the first run, it creates a singleton object and places // it into the static field. On subsequent runs, it returns the client // existing object stored in the static field. public static Singleton GetInstance() { _instance ??= new Singleton(); return _instance; } // Finally, any singleton should define some business logic, which can // be executed on its instance. public void SomeBusinessLogic() { // ... } } public class Client { public static void Main() { // The client code. var s1 = Singleton.GetInstance(); var s2 = Singleton.GetInstance(); if (s1 == s2) { Console.WriteLine(\"Singleton works, both variables contain the same instance.\"); } else { Console.WriteLine(\"Singleton failed, variables contain different instances.\"); } } } } ","date":"2024-05-07","objectID":"/posts/design_patterns/design_patterns_05/:4:1","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 单例模式","uri":"/posts/design_patterns/design_patterns_05/#基础单例"},{"categories":["设计模式"],"content":" 4.2 线程安全单例 C# using Singleton.Conceptual; Client.Main(); namespace Singleton.Conceptual { // This Singleton implementation is called \"double check lock\". It is safe // in multithreaded environment and provides lazy initialization for the // Singleton object. public sealed class Singleton { private static readonly object _locker = new(); public string Value { get; } private Singleton(string value) { Value = value; } private static Singleton? _instance; public static Singleton GetInstance(string value) { if (_instance == null) { lock (_locker) { _instance ??= new Singleton(value); } } return _instance; } } public class Client { public static void Main() { Console.WriteLine( \"{0}\\n{1}\\n\\n{2}\\n\", \"If you see the same value, then singleton was reused (yay!)\", \"If you see different values, then 2 singletons were created (booo!!)\", \"RESULT:\" ); var process1 = new Thread(() =\u003e { TestSingleton(\"FOO\"); }); var process2 = new Thread(() =\u003e { TestSingleton(\"BAR\"); }); process1.Start(); process2.Start(); process1.Join(); process2.Join(); } public static void TestSingleton(string value) { Singleton singleton = Singleton.GetInstance(value); Console.WriteLine(singleton.Value); } } } ","date":"2024-05-07","objectID":"/posts/design_patterns/design_patterns_05/:4:2","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 单例模式","uri":"/posts/design_patterns/design_patterns_05/#线程安全单例"},{"categories":["设计模式"],"content":"设计模式 —— 原型模式","date":"2024-05-06","objectID":"/posts/design_patterns/design_patterns_04/","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 原型模式","uri":"/posts/design_patterns/design_patterns_04/"},{"categories":["设计模式"],"content":"原型模式是一种创建型设计模式，使你能够复制已有对象，而又无需使代码依赖它们所属的类。 ","date":"2024-05-06","objectID":"/posts/design_patterns/design_patterns_04/:0:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 原型模式","uri":"/posts/design_patterns/design_patterns_04/#"},{"categories":["设计模式"],"content":" 1 原型模式结构","date":"2024-05-06","objectID":"/posts/design_patterns/design_patterns_04/:1:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 原型模式","uri":"/posts/design_patterns/design_patterns_04/#原型模式结构"},{"categories":["设计模式"],"content":" 1.1 原型模式基本实现 原型模式基本实现结构图 原型（Prototype）：声明克隆方法。 具体原型（Concrete Prototype）：实现克隆方法。 客户端（Client）：客户端可以调用克隆方法来复制实现了原型接口的任何对象。 ","date":"2024-05-06","objectID":"/posts/design_patterns/design_patterns_04/:1:1","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 原型模式","uri":"/posts/design_patterns/design_patterns_04/#原型模式基本实现"},{"categories":["设计模式"],"content":" 1.2 原型模式注册表实现 原型模式注册表实现结构图 原型注册表（Prototype Registry）：供了一种访问常用原型的简单方法，其中存储了一系列可供随时复制的预生成对象。 ","date":"2024-05-06","objectID":"/posts/design_patterns/design_patterns_04/:1:2","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 原型模式","uri":"/posts/design_patterns/design_patterns_04/#原型模式注册表实现"},{"categories":["设计模式"],"content":" 2 原型模式的应用场景 需要复制一些对象，同时又希望代码独立于这些对象所属的具体类，可以使用原型模式。 如果子类的区别仅在于其对象的初始化方式，可以使用该模式来减少子类的数量。 ","date":"2024-05-06","objectID":"/posts/design_patterns/design_patterns_04/:2:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 原型模式","uri":"/posts/design_patterns/design_patterns_04/#原型模式的应用场景"},{"categories":["设计模式"],"content":" 3 原型模式的优缺点","date":"2024-05-06","objectID":"/posts/design_patterns/design_patterns_04/:3:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 原型模式","uri":"/posts/design_patterns/design_patterns_04/#原型模式的优缺点"},{"categories":["设计模式"],"content":" 3.1 优点 可以克隆对象，而无需与它们所属的具体类相耦合。 可以克隆预生成原型， 避免反复运行初始化代码。 可以更方便地生成复杂对象。 可以用继承以外的方式来处理复杂对象的不同配置。 ","date":"2024-05-06","objectID":"/posts/design_patterns/design_patterns_04/:3:1","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 原型模式","uri":"/posts/design_patterns/design_patterns_04/#优点"},{"categories":["设计模式"],"content":" 3.2 缺点克隆包含循环引用的复杂对象可能会非常麻烦。 ","date":"2024-05-06","objectID":"/posts/design_patterns/design_patterns_04/:3:2","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 原型模式","uri":"/posts/design_patterns/design_patterns_04/#缺点"},{"categories":["设计模式"],"content":" 4 代码示例C# 的 ICloneable 接口就是立即可用的原型模式。 C# using Prototype.Conceptual; Client.Main(); namespace Prototype.Conceptual { public class Person { public int Age; public DateTime BirthDate; public string Name; public IdInfo IdInfo; public Person(int age, DateTime birthDate, string name, IdInfo idInfo) { Age = age; BirthDate = birthDate; Name = name; IdInfo = idInfo; } public Person ShallowCopy() { return (Person)MemberwiseClone(); } public Person DeepCopy() { Person clone = (Person)MemberwiseClone(); clone.IdInfo = new IdInfo(IdInfo.IdNumber); clone.Name = Name; return clone; } } public class IdInfo { public int IdNumber; public IdInfo(int idNumber) { IdNumber = idNumber; } } public class Client { public static void Main() { var age = 42; var birthDate = Convert.ToDateTime(\"1977-01-01\"); var name = \"Jack Daniels\"; var idInfo = new IdInfo(666); var p1 = new Person(age, birthDate, name, idInfo); // Perform a shallow copy of p1 and assign it to p2. Person p2 = p1.ShallowCopy(); // Make a deep copy of p1 and assign it to p3. Person p3 = p1.DeepCopy(); // Display values of p1, p2 and p3. Console.WriteLine(\"Original values of p1, p2, p3:\"); Console.WriteLine(\" p1 instance values: \"); DisplayValues(p1); Console.WriteLine(\" p2 instance values:\"); DisplayValues(p2); Console.WriteLine(\" p3 instance values:\"); DisplayValues(p3); // Change the value of p1 properties and display the values of p1, // p2 and p3. p1.Age = 32; p1.BirthDate = Convert.ToDateTime(\"1900-01-01\"); p1.Name = \"Frank\"; p1.IdInfo.IdNumber = 7878; Console.WriteLine(\"\\nValues of p1, p2 and p3 after changes to p1:\"); Console.WriteLine(\" p1 instance values: \"); DisplayValues(p1); Console.WriteLine(\" p2 instance values (reference values have changed):\"); DisplayValues(p2); Console.WriteLine(\" p3 instance values (everything was kept the same):\"); DisplayValues(p3); } public static void DisplayValues(Person p) { Console.WriteLine(\" Name: {0:s}, Age: {1:d}, BirthDate: {2:MM/dd/yy}\", p.Name, p.Age, p.BirthDate); Console.WriteLine(\" ID#: {0:d}\", p.IdInfo.IdNumber); } } } ","date":"2024-05-06","objectID":"/posts/design_patterns/design_patterns_04/:4:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 原型模式","uri":"/posts/design_patterns/design_patterns_04/#代码示例"},{"categories":["设计模式"],"content":"设计模式 —— 生成器模式","date":"2024-05-05","objectID":"/posts/design_patterns/design_patterns_03/","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 生成器模式","uri":"/posts/design_patterns/design_patterns_03/"},{"categories":["设计模式"],"content":"生成器模式是一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。 ","date":"2024-05-05","objectID":"/posts/design_patterns/design_patterns_03/:0:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 生成器模式","uri":"/posts/design_patterns/design_patterns_03/#"},{"categories":["设计模式"],"content":" 1 生成器模式结构 生成器模式结构图 生成器（Builder）：生成器接口负责声明在所有类型生成器中通用的产品构造步骤。 具体生成器（Concrete Builders）：提供构造过程的不同实现。 产品（Products）：最终生成的对象。 主管（Director）：定义调用构造步骤的顺序，这样你就可以创建和复用特定的产品配置。 客户端（Client）：将某个生成器对象与主管类关联。 ","date":"2024-05-05","objectID":"/posts/design_patterns/design_patterns_03/:1:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 生成器模式","uri":"/posts/design_patterns/design_patterns_03/#生成器模式结构"},{"categories":["设计模式"],"content":" 2 生成器模式的应用场景 需要简化构造函数的重载方法时，可以使用生成器模式。 如果希望使用代码创建不同形式的产品，它们的制造过程相似且仅有细节上的差异，可使用生成器模式。 ","date":"2024-05-05","objectID":"/posts/design_patterns/design_patterns_03/:2:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 生成器模式","uri":"/posts/design_patterns/design_patterns_03/#生成器模式的应用场景"},{"categories":["设计模式"],"content":" 3 生成器模式的优缺点","date":"2024-05-05","objectID":"/posts/design_patterns/design_patterns_03/:3:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 生成器模式","uri":"/posts/design_patterns/design_patterns_03/#生成器模式的优缺点"},{"categories":["设计模式"],"content":" 3.1 优点 可以分步创建对象，暂缓创建步骤或递归运行创建步骤。 生成不同形式的产品时，你可以复用相同的制造代码。 单一职责原则。你可以将复杂构造代码从产品的业务逻辑中分离出来。 ","date":"2024-05-05","objectID":"/posts/design_patterns/design_patterns_03/:3:1","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 生成器模式","uri":"/posts/design_patterns/design_patterns_03/#优点"},{"categories":["设计模式"],"content":" 3.2 缺点由于采用该模式需要向应用中引入众多接口和类，代码可能会比之前更加复杂。 ","date":"2024-05-05","objectID":"/posts/design_patterns/design_patterns_03/:3:2","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 生成器模式","uri":"/posts/design_patterns/design_patterns_03/#缺点"},{"categories":["设计模式"],"content":" 4 代码示例 C# using Builder.Conceptual; Client.Main(); namespace Builder.Conceptual { // The Builder interface specifies methods for creating the different parts // of the Product objects. public interface IBuilder { void BuildPartA(); void BuildPartB(); void BuildPartC(); } // The Concrete Builder classes follow the Builder interface and provide // specific implementations of the building steps. public class ConcreteBuilder : IBuilder { private Product _product = new(); // A fresh builder instance should contain a blank product object, which // is used in further assembly. public ConcreteBuilder() { Reset(); } public void Reset() { _product = new Product(); } // All production steps work with the same product instance. public void BuildPartA() { _product.Add(\"PartA1\"); } public void BuildPartB() { _product.Add(\"PartB1\"); } public void BuildPartC() { _product.Add(\"PartC1\"); } public Product GetProduct() { Product result = _product; Reset(); return result; } } // It makes sense to use the Builder pattern only when your products are // quite complex and require extensive configuration. public class Product { private readonly List\u003cobject\u003e _parts = []; public void Add(string part) { _parts.Add(part); } public string ListParts() { string str = string.Empty; for (int i = 0; i \u003c _parts.Count; i++) { str += _parts[i] + \", \"; } str = str.Remove(str.Length - 2); // removing last \",c\" return \"Product parts: \" + str + \"\\n\"; } } // The Director is only responsible for executing the building steps in a // particular sequence. It is helpful when producing products according to a // specific order or configuration. Strictly speaking, the Director class is // optional, since the client can control builders directly. public class Director { private readonly IBuilder _builder; public Director(IBuilder builder) { _builder = builder; } // The Director can construct several product variations using the same // building steps. public void BuildMinimalViableProduct() { _builder.BuildPartA(); } public void BuildFullFeaturedProduct() { _builder.BuildPartA(); _builder.BuildPartB(); _builder.BuildPartC(); } } class Client { public static void Main() { // The client code creates a builder object, passes it to the // director and then initiates the construction process. The end // result is retrieved from the builder object. var builder = new ConcreteBuilder(); var director = new Director(builder); Console.WriteLine(\"Standard basic product:\"); director.BuildMinimalViableProduct(); Console.WriteLine(builder.GetProduct().ListParts()); Console.WriteLine(\"Standard full featured product:\"); director.BuildFullFeaturedProduct(); Console.WriteLine(builder.GetProduct().ListParts()); // The Builder pattern can be used without a Director class. Console.WriteLine(\"Custom product:\"); builder.BuildPartA(); builder.BuildPartC(); Console.Write(builder.GetProduct().ListParts()); } } } ","date":"2024-05-05","objectID":"/posts/design_patterns/design_patterns_03/:4:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 生成器模式","uri":"/posts/design_patterns/design_patterns_03/#代码示例"},{"categories":["设计模式"],"content":"设计模式 —— 抽象工厂模式","date":"2024-04-30","objectID":"/posts/design_patterns/design_patterns_02/","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 抽象工厂模式","uri":"/posts/design_patterns/design_patterns_02/"},{"categories":["设计模式"],"content":"抽象工厂模式是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类。 ","date":"2024-04-30","objectID":"/posts/design_patterns/design_patterns_02/:0:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 抽象工厂模式","uri":"/posts/design_patterns/design_patterns_02/#"},{"categories":["设计模式"],"content":" 1 抽象工厂模式结构 抽象工厂模式结构图 抽象产品（Abstract Product）：为构成系列产品的一组不同但相关的产品声明接口。 具体产品（Concrete Product）：是抽象产品的多种不同类型实现。所有变体都必须实现相应的抽象产品。 抽象工厂（Abstract Factory）：抽象工厂接口声明了一组创建各种抽象产品的方法。 具体工厂（Concrete Factory）：实现抽象工厂的构建方法。每个具体工厂都对应特定产品变体，且仅创建此种产品变体。具体工厂会对具体产品进行初始化，其构建方法签名必须返回相应的抽象产品。 客户端（Client）：客户端只需通过抽象接口调用工厂和产品对象，就能与任何具体工厂/产品变体交互。 ","date":"2024-04-30","objectID":"/posts/design_patterns/design_patterns_02/:1:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 抽象工厂模式","uri":"/posts/design_patterns/design_patterns_02/#抽象工厂模式结构"},{"categories":["设计模式"],"content":" 2 抽象工厂模式的应用场景 如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者出于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建，在这种情况下，你可以使用抽象工厂。 如果你有一个基于一组抽象方法的类，且其主要功能因此变得不明确，那么在这种情况下可以考虑使用抽象工厂模式。 技巧 在设计良好的程序中，每个类仅负责一件事。如果一个类与多种类型产品交互，就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。 ","date":"2024-04-30","objectID":"/posts/design_patterns/design_patterns_02/:2:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 抽象工厂模式","uri":"/posts/design_patterns/design_patterns_02/#抽象工厂模式的应用场景"},{"categories":["设计模式"],"content":" 3 抽象工厂模式的优缺点","date":"2024-04-30","objectID":"/posts/design_patterns/design_patterns_02/:3:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 抽象工厂模式","uri":"/posts/design_patterns/design_patterns_02/#抽象工厂模式的优缺点"},{"categories":["设计模式"],"content":" 3.1 优点 可以确保同一工厂生成的产品相互匹配。 可以避免客户端和具体产品代码的耦合。 单一职责原则。你可以将产品生成代码抽取到同一位置，使得代码易于维护。 开闭原则。向应用程序中引入新产品变体时，你无需修改客户端代码。 ","date":"2024-04-30","objectID":"/posts/design_patterns/design_patterns_02/:3:1","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 抽象工厂模式","uri":"/posts/design_patterns/design_patterns_02/#优点"},{"categories":["设计模式"],"content":" 3.2 缺点由于采用该模式需要向应用中引入众多接口和类，代码可能会比之前更加复杂。 ","date":"2024-04-30","objectID":"/posts/design_patterns/design_patterns_02/:3:2","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 抽象工厂模式","uri":"/posts/design_patterns/design_patterns_02/#缺点"},{"categories":["设计模式"],"content":" 4 代码示例 C# using AbstractFactory.Conceptual; Client.Main(); namespace AbstractFactory.Conceptual { // The Abstract Factory interface declares a set of methods that return // different abstract products. public interface IAbstractFactory { IAbstractProductA CreateProductA(); IAbstractProductB CreateProductB(); } // Concrete Factories produce a family of products that belong to a single // variant. class ConcreteFactory1 : IAbstractFactory { public IAbstractProductA CreateProductA() { return new ConcreteProductA1(); } public IAbstractProductB CreateProductB() { return new ConcreteProductB1(); } } // Each Concrete Factory has a corresponding product variant. class ConcreteFactory2 : IAbstractFactory { public IAbstractProductA CreateProductA() { return new ConcreteProductA2(); } public IAbstractProductB CreateProductB() { return new ConcreteProductB2(); } } // Each distinct product of a product family should have a base interface. // All variants of the product must implement this interface. public interface IAbstractProductA { string UsefulFunctionA(); } // Concrete Products are created by corresponding Concrete Factories. class ConcreteProductA1 : IAbstractProductA { public string UsefulFunctionA() { return \"The result of the product A1.\"; } } class ConcreteProductA2 : IAbstractProductA { public string UsefulFunctionA() { return \"The result of the product A2.\"; } } // Here's the the base interface of another product. public interface IAbstractProductB { // Product B is able to do its own thing... string UsefulFunctionB(); // Product B also can collaborate with the ProductA. string AnotherUsefulFunctionB(IAbstractProductA collaborator); } // Concrete Products are created by corresponding Concrete Factories. class ConcreteProductB1 : IAbstractProductB { public string UsefulFunctionB() { return \"The result of the product B1.\"; } public string AnotherUsefulFunctionB(IAbstractProductA collaborator) { var result = collaborator.UsefulFunctionA(); return $\"The result of the B1 collaborating with the ({result})\"; } } class ConcreteProductB2 : IAbstractProductB { public string UsefulFunctionB() { return \"The result of the product B2.\"; } public string AnotherUsefulFunctionB(IAbstractProductA collaborator) { var result = collaborator.UsefulFunctionA(); return $\"The result of the B2 collaborating with the ({result})\"; } } // The client code works with factories and products only through abstract // types: AbstractFactory and AbstractProduct. This lets you pass any // factory or product subclass to the client code without breaking it. class Client { public static void Main() { // The client code can work with any concrete factory class. Console.WriteLine(\"Client: Testing client code with the first factory type...\"); ClientMethod(new ConcreteFactory1()); Console.WriteLine(); Console.WriteLine(\"Client: Testing the same client code with the second factory type...\"); ClientMethod(new ConcreteFactory2()); } public static void ClientMethod(IAbstractFactory factory) { var productA = factory.CreateProductA(); var productB = factory.CreateProductB(); Console.WriteLine(productB.UsefulFunctionB()); Console.WriteLine(productB.AnotherUsefulFunctionB(productA)); } } } ","date":"2024-04-30","objectID":"/posts/design_patterns/design_patterns_02/:4:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 抽象工厂模式","uri":"/posts/design_patterns/design_patterns_02/#代码示例"},{"categories":["设计模式"],"content":"设计模式 —— 工厂方法模式","date":"2023-12-29","objectID":"/posts/design_patterns/design_patterns_01/","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 工厂方法模式","uri":"/posts/design_patterns/design_patterns_01/"},{"categories":["设计模式"],"content":"工厂方法模式是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。 ","date":"2023-12-29","objectID":"/posts/design_patterns/design_patterns_01/:0:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 工厂方法模式","uri":"/posts/design_patterns/design_patterns_01/#"},{"categories":["设计模式"],"content":" 1 工厂方法模式结构 工厂方法模式结构图 产品（Product）：对接口进行声明。 具体产品（Concrete Products）：产品接口的不同实现。 创建者（Creator）：声明返回产品对象的工厂方法。 具体创建者（Concrete Creators）：重写基础工厂方法，使其返回不同类型的产品。并不一定每次调用工厂方法都会创建新的实例。工厂方法也可以返回缓存、对象池或其他来源的已有对象。 ","date":"2023-12-29","objectID":"/posts/design_patterns/design_patterns_01/:1:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 工厂方法模式","uri":"/posts/design_patterns/design_patterns_01/#工厂方法模式结构"},{"categories":["设计模式"],"content":" 2 工厂方法模式的应用场景 在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。工厂方法将创建产品的代码与实际使用产品的代码分离，从而能在不影响其他代码的情况下扩展产品创建部分代码。 希望用户能扩展你软件库或框架的内部组件，可使用工厂方法。 希望复用现有对象来节省系统资源，而不是每次都重新创建对象，可使用工厂方法。 ","date":"2023-12-29","objectID":"/posts/design_patterns/design_patterns_01/:2:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 工厂方法模式","uri":"/posts/design_patterns/design_patterns_01/#工厂方法模式的应用场景"},{"categories":["设计模式"],"content":" 3 工厂方法模式的优缺点","date":"2023-12-29","objectID":"/posts/design_patterns/design_patterns_01/:3:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 工厂方法模式","uri":"/posts/design_patterns/design_patterns_01/#工厂方法模式的优缺点"},{"categories":["设计模式"],"content":" 3.1 优点 可以避免创建者和具体产品之间的紧密耦合。 单一职责原则。你可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护。 开闭原则。无需更改现有客户端代码，你就可以在程序中引入新的产品类型。 ","date":"2023-12-29","objectID":"/posts/design_patterns/design_patterns_01/:3:1","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 工厂方法模式","uri":"/posts/design_patterns/design_patterns_01/#优点"},{"categories":["设计模式"],"content":" 3.2 缺点应用工厂方法模式需要引入许多新的子类，代码可能会因此变得更复杂。 ","date":"2023-12-29","objectID":"/posts/design_patterns/design_patterns_01/:3:2","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 工厂方法模式","uri":"/posts/design_patterns/design_patterns_01/#缺点"},{"categories":["设计模式"],"content":" 4 代码示例工厂方法模式识别方法：工厂方法可通过构建方法来识别，它会创建具体类的对象，但以抽象类型或接口的形式返回这些对象。 C# using FactoryMethod.Conceptual; Client.Main(); namespace FactoryMethod.Conceptual { // The Creator class declares the factory method that is supposed to return // an object of a Product class. abstract class Creator { public abstract IProduct FactoryMethod(); // Creator's primary responsibility is not creating products. // Usually, it contains some core business logic that relies on Product objects, // returned by the factory method. Subclasses can indirectly change that business logic // by overriding the factory method and returning a different type of // product from it. public string SomeOperation() { var product = FactoryMethod(); var result = \"Creator: The same creator's code has just worked with \" + product.Operation(); return result; } } class ConcreteCreator1 : Creator { // Note that the signature of the method still uses the abstract product // type, even though the concrete product is actually returned from the // method. This way the Creator can stay independent of concrete product // classes. public override IProduct FactoryMethod() { return new ConcreteProduct1(); } } class ConcreteCreator2 : Creator { public override IProduct FactoryMethod() { return new ConcreteProduct2(); } } // The Product interface declares the operations that all concrete products // must implement. public interface IProduct { string Operation(); } class ConcreteProduct1 : IProduct { public string Operation() { return \"{Result of ConcreteProduct1}\"; } } class ConcreteProduct2 : IProduct { public string Operation() { return \"{Result of ConcreteProduct2}\"; } } class Client { public static void Main() { Console.WriteLine(\"App: Launched with the ConcreteCreator1.\"); ClientCode(new ConcreteCreator1()); Console.WriteLine(); Console.WriteLine(\"App: Launched with the ConcreteCreator2.\"); ClientCode(new ConcreteCreator2()); } public static void ClientCode(Creator creator) { Console.WriteLine(\"Client: I'm not aware of the creator's class,\" + \"but it still works.\\n\" + creator.SomeOperation()); } } } ","date":"2023-12-29","objectID":"/posts/design_patterns/design_patterns_01/:4:0","series":["设计模式 学习笔记"],"tags":["设计模式","创建型设计模式"],"title":"设计模式 —— 工厂方法模式","uri":"/posts/design_patterns/design_patterns_01/#代码示例"},{"categories":["设计模式"],"content":"设计模式 —— 什么是设计模式","date":"2023-12-28","objectID":"/posts/design_patterns/design_patterns_00/","series":["设计模式 学习笔记"],"tags":["设计模式"],"title":"设计模式 —— 什么是设计模式","uri":"/posts/design_patterns/design_patterns_00/"},{"categories":["设计模式"],"content":" 1 什么是设计模式设计模式是软件设计中常见问题的典型解决方案。它们就像预制的蓝图，您可以自定义它们来解决代码中反复出现的设计问题。 设计模式是针对软件设计中常见问题的经过尝试和测试的解决方案的工具包。即使您从未遇到过这些问题，了解模式仍然很有用，因为它教会您如何使用面向对象设计的原理解决各种问题。 ","date":"2023-12-28","objectID":"/posts/design_patterns/design_patterns_00/:1:0","series":["设计模式 学习笔记"],"tags":["设计模式"],"title":"设计模式 —— 什么是设计模式","uri":"/posts/design_patterns/design_patterns_00/#什么是设计模式"},{"categories":["设计模式"],"content":" 2 设计模式的分类将设计模式根据使用意图进行分类，可分为如下三类： 创建模式：提供了对象创建机制，可以提高现有代码的灵活性和重用性； 结构模式：解释了如何将对象和类组装成更大的结构，同时保持这些结构的灵活性和高效性； 行为模式：负责对象之间的有效沟通和职责分配。 ","date":"2023-12-28","objectID":"/posts/design_patterns/design_patterns_00/:2:0","series":["设计模式 学习笔记"],"tags":["设计模式"],"title":"设计模式 —— 什么是设计模式","uri":"/posts/design_patterns/design_patterns_00/#设计模式的分类"},{"categories":["设计模式"],"content":" 3 参考资料https://refactoring.guru/design-patterns ","date":"2023-12-28","objectID":"/posts/design_patterns/design_patterns_00/:3:0","series":["设计模式 学习笔记"],"tags":["设计模式"],"title":"设计模式 —— 什么是设计模式","uri":"/posts/design_patterns/design_patterns_00/#参考资料"},{"categories":["数据结构与算法"],"content":"符号表","date":"2023-12-04","objectID":"/posts/algs4/algs4_11/","series":["算法第四版 阅读笔记"],"tags":["算法第四版","查找算法"],"title":"算法第四版 —— 符号表","uri":"/posts/algs4/algs4_11/"},{"categories":["数据结构与算法"],"content":" 1 TODO// TODO ","date":"2023-12-04","objectID":"/posts/algs4/algs4_11/:1:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","查找算法"],"title":"算法第四版 —— 符号表","uri":"/posts/algs4/algs4_11/#todo"},{"categories":["计算机体系结构"],"content":"深入理解计算机系统 —— 计算机系统漫游","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/"},{"categories":["计算机体系结构"],"content":"本章通过跟踪 hello 程序的生命周期来开始对计算机系统的学习。 C // hello.c #include \u003cstdio.h\u003e int main() { printf(\"hello, world\\n\"); return 0; } ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:0:0","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#"},{"categories":["计算机体系结构"],"content":" 1 信息就是位 + 上下文hello.c 源程序实际上是一个由值 0 和 1 组成的位（比特）序列。8 个位被组成一组，称为字节。hello.c 程序以字节序列的方式存储在文件中。 计算机中表示信息的基本思想：系统中的所有信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:1:0","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#信息就是位--上下文"},{"categories":["计算机体系结构"],"content":" 2 程序被其他程序翻译成不同的格式为了在系统上执行 hello.c 程序，每条 C 语句都必须被其他程序转化为一系列的低级机器语言指令。这些指令按照可执行目标程序的格式打包，以二进制磁盘文件的形式存放。 编译系统 翻译过程分为四个阶段。执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统。 预处理阶段。预处理器根据以字符“#”开头的命令，修改原始的 C 程序。以“.i ”作为扩展名。比如#include \u003cstdio.h\u003e命令告诉预处理器读取系统头文件“stdio.h”，并把它的内容直接插入程序文本中。 编译阶段。编译器将文本文件 hello.i 翻译成文本文件 hello.s： text main: subq $8, %rsp movl $.LC0, %edi call puts movl $0, %eax addq $8, %rsp ret 汇编阶段。汇编器将 hello.s 翻译成机器语言指令，把指令打包成可重定位目标程序（relocatable object program）的格式，并将结果保存在 hello.o 二进制文件中。 链接阶段。hello 程序调用了 printf 函数，它标准 C 库中的一个函数，存在于 printf.o 的预编译好的目标文件中。这个文件必须以某种方式合并到 hello.o 程序中。链接器负责处理这种合并，生成 hello 的可执行目标文件，可以被加载到内存中，由系统执行。 此时，hello.c 源程序被编译系统翻译成了可执行目标文件 hello，并被存放在磁盘上。 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:2:0","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#程序被其他程序翻译成不同的格式"},{"categories":["计算机体系结构"],"content":" 3 处理器读取并解释存储在内存中的指令","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:3:0","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#处理器读取并解释存储在内存中的指令"},{"categories":["计算机体系结构"],"content":" 3.1 系统的硬件组成为了理解运行 hello 程序时发生了什么，需要了解一个典型系统的硬件组织。 一个典型系统的硬件组成 总线。贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传输。 I/O 设备。I/O 设备是系统与外部世界的联系通道。每个 I/O 设备都通过一个控制器或适配器与 I/O 总线相连。控制器是 I/O 设备本身或者系统主板上的芯片组；适配器是一块插在主板插槽上的卡。 主存。主存是临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。主存是由一组动态随机存取存储器（DRAM）芯片组成的。 处理器。即中央处理单元（CPU），是解释（或执行）存储在主存中指令的引擎。处理器的核心是程序计数器（PC）。在任何时刻 PC 指向主存中的某条机器语言指令。 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:3:1","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#系统的硬件组成"},{"categories":["计算机体系结构"],"content":" 3.2 运行 hello 程序简单描述运行 hello 程序时到底发生了什么： 在 shell 程序中输入 “./hello” 后，shell 程序将字符逐一读入寄存器，再把它存放到内存中； 从键盘上读取 hello 命令 敲下回车键，shell 加载可执行的 hello 文件，利用直接存储器存取（DMA）技术，直接将 hello 目标文件中的代码和数据从磁盘复制到主存； 从磁盘加载可执行文件到主存 目标文件 hello 加载到主存，处理器执行 hello 程序的 main 程序的机器指令，指令将 “hello, world\\n” 字符串从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。 将输出字符串从存储器写到显示器 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:3:2","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#运行-hello-程序"},{"categories":["计算机体系结构"],"content":" 4 高速缓存与存储设备的层次结构","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:4:0","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#高速缓存与存储设备的层次结构"},{"categories":["计算机体系结构"],"content":" 4.1 高速缓存处理器从寄存器文件中读取数据比从主存中读取几乎快 100 倍，针对这种差异，引入了高速缓存存储器（cache memory）。 利用高速缓存的局部性原理，程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，可以提高程序性能。 CPU 芯片的高速缓存 L1、L2、L3 高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:4:1","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#高速缓存"},{"categories":["计算机体系结构"],"content":" 4.2 存储设备的层次结构每个计算机系统中的存储设备都被组织成了一个存储器层次结构。存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。 存储器层次结构示例 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:4:2","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#存储设备的层次结构"},{"categories":["计算机体系结构"],"content":" 5 操作系统管理硬件所有应用程序对硬件的操作都必须通过操作系统。操作系统有两个基本的功能： 防止硬件被失控的应用程序滥用； 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。 操作系统通过几个基本的抽象概念来实现这两个功能，文件是对 I/O 设备的抽象表示，虚拟内存是对主存和磁盘 I/O 设备的抽象表示，进程是对处理器、主存和 I/O 设备的抽象表示。 操作系统提供的抽象表示 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:5:0","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#操作系统管理硬件"},{"categories":["计算机体系结构"],"content":" 5.1 进程与线程进程是操作系统对一个正在运行的程序的一种抽象。好似程序是独占使用处理器、主存和 I/O 设备一样。 一个 CPU 看上去都是在并发地执行多个进程，是通过上下文切换实现的。一个进程到另一个进程的转换是由操作系统内核管理的。 进程的上下文切换 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:5:1","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#进程与线程"},{"categories":["计算机体系结构"],"content":" 5.2 虚拟内存虚拟内存为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。 进程的虚拟地址空间 进程虚拟地址空间从最低地址向上，逐步为： 程序代码和数据。代码是从一固定地址开始，紧接着的是和 C 全局变量相对应的数据位置。代码和数据区直接按照可执行目标文件的内容初始化。该区域在进程一开始运行时就被指定大小。 堆。当调用 malloc 和 free 这样的 C 标准库时，该区域可以在运行时动态扩展和收缩。 共享库。大约在地址空间的中间部分，用来存放像 C 标准库和数学库这样的共享代码的数据和区域。 栈。用户虚拟地址空间顶部是用户栈，编译器用栈来实现函数调用，每次调用一个函数，栈就会增长；从一个函数返回，栈就会收缩。 内核虚拟内存。地址空间顶部区域是为内核保留的，不允许应用程序读写这个区域的内容。 技巧 关于代码和数据区的存放位置，可以参考之前整理的 汇编语言 —— 第一个完整的程序 —— 执行 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:5:2","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#虚拟内存"},{"categories":["计算机体系结构"],"content":" 5.3 文件文件就是字节序列，每个 I/O 设备，包括磁盘、键盘、显示器或者网络，都可以看成是文件。 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:5:3","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#文件"},{"categories":["计算机体系结构"],"content":" 6 系统之间利用网络通信现代系统通过网络和其他系统连接到一起。 网络也是一种 I/O 设备 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:6:0","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#系统之间利用网络通信"},{"categories":["计算机体系结构"],"content":" 7 重要主题","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:7:0","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#重要主题"},{"categories":["计算机体系结构"],"content":" 7.1 Amdahl 定律当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:7:1","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#amdahl-定律"},{"categories":["计算机体系结构"],"content":" 7.2 并发和并行并发指一个同时具有多个活动的系统；并行指的是用并发来使一个系统运行得更快。 并行可以在计算机系统的多个抽象层次上运用，按照系统层次结构由高到低重点强调三个层次。 7.2.1 线程级并发使用线程能够在一个进程中执行多个控制流。对于单处理器系统来说，并发执行是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的。 不同处理器分类 多处理器系统是由单个操作系统内核控制多个处理器的系统。多核处理器分为多核和超线程。一个典型多核处理器组织结构如下图所示： 多核处理器组织结构，4个处理器核集成在一个芯片上 其中微处理器芯片有 4 个 CPU 核，每个核有自己的 L1、L2 高速缓存，L1 高速缓存分为两个部分——一个保存最近取到的指令，另一个存放数据。 超线程，又称同时多线程，允许一个 CPU 执行多个控制流。 多处理器可以从两方面提高系统性能： 减少在执行多任务时模拟并发的需要； 使多线程应用程序运行得更快。 7.2.2 指令级并行现代处理器可以同时执行多条指令的属性称为指令级并行。实现指令级并行的技术有：流水线。 如果处理器可以达到比一个周期一条指令更快的执行速率，称之为超标量处理器。 7.2.3 单指令、多数据并行许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即 SIMD 并行。比如现代 Intel 和 AMD 处理器都具有并行对 8 对单精度浮点数做加法的指令。 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:7:2","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#并发和并行"},{"categories":["计算机体系结构"],"content":" 7.2 并发和并行并发指一个同时具有多个活动的系统；并行指的是用并发来使一个系统运行得更快。 并行可以在计算机系统的多个抽象层次上运用，按照系统层次结构由高到低重点强调三个层次。 7.2.1 线程级并发使用线程能够在一个进程中执行多个控制流。对于单处理器系统来说，并发执行是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的。 不同处理器分类 多处理器系统是由单个操作系统内核控制多个处理器的系统。多核处理器分为多核和超线程。一个典型多核处理器组织结构如下图所示： 多核处理器组织结构，4个处理器核集成在一个芯片上 其中微处理器芯片有 4 个 CPU 核，每个核有自己的 L1、L2 高速缓存，L1 高速缓存分为两个部分——一个保存最近取到的指令，另一个存放数据。 超线程，又称同时多线程，允许一个 CPU 执行多个控制流。 多处理器可以从两方面提高系统性能： 减少在执行多任务时模拟并发的需要； 使多线程应用程序运行得更快。 7.2.2 指令级并行现代处理器可以同时执行多条指令的属性称为指令级并行。实现指令级并行的技术有：流水线。 如果处理器可以达到比一个周期一条指令更快的执行速率，称之为超标量处理器。 7.2.3 单指令、多数据并行许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即 SIMD 并行。比如现代 Intel 和 AMD 处理器都具有并行对 8 对单精度浮点数做加法的指令。 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:7:2","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#线程级并发"},{"categories":["计算机体系结构"],"content":" 7.2 并发和并行并发指一个同时具有多个活动的系统；并行指的是用并发来使一个系统运行得更快。 并行可以在计算机系统的多个抽象层次上运用，按照系统层次结构由高到低重点强调三个层次。 7.2.1 线程级并发使用线程能够在一个进程中执行多个控制流。对于单处理器系统来说，并发执行是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的。 不同处理器分类 多处理器系统是由单个操作系统内核控制多个处理器的系统。多核处理器分为多核和超线程。一个典型多核处理器组织结构如下图所示： 多核处理器组织结构，4个处理器核集成在一个芯片上 其中微处理器芯片有 4 个 CPU 核，每个核有自己的 L1、L2 高速缓存，L1 高速缓存分为两个部分——一个保存最近取到的指令，另一个存放数据。 超线程，又称同时多线程，允许一个 CPU 执行多个控制流。 多处理器可以从两方面提高系统性能： 减少在执行多任务时模拟并发的需要； 使多线程应用程序运行得更快。 7.2.2 指令级并行现代处理器可以同时执行多条指令的属性称为指令级并行。实现指令级并行的技术有：流水线。 如果处理器可以达到比一个周期一条指令更快的执行速率，称之为超标量处理器。 7.2.3 单指令、多数据并行许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即 SIMD 并行。比如现代 Intel 和 AMD 处理器都具有并行对 8 对单精度浮点数做加法的指令。 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:7:2","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#指令级并行"},{"categories":["计算机体系结构"],"content":" 7.2 并发和并行并发指一个同时具有多个活动的系统；并行指的是用并发来使一个系统运行得更快。 并行可以在计算机系统的多个抽象层次上运用，按照系统层次结构由高到低重点强调三个层次。 7.2.1 线程级并发使用线程能够在一个进程中执行多个控制流。对于单处理器系统来说，并发执行是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的。 不同处理器分类 多处理器系统是由单个操作系统内核控制多个处理器的系统。多核处理器分为多核和超线程。一个典型多核处理器组织结构如下图所示： 多核处理器组织结构，4个处理器核集成在一个芯片上 其中微处理器芯片有 4 个 CPU 核，每个核有自己的 L1、L2 高速缓存，L1 高速缓存分为两个部分——一个保存最近取到的指令，另一个存放数据。 超线程，又称同时多线程，允许一个 CPU 执行多个控制流。 多处理器可以从两方面提高系统性能： 减少在执行多任务时模拟并发的需要； 使多线程应用程序运行得更快。 7.2.2 指令级并行现代处理器可以同时执行多条指令的属性称为指令级并行。实现指令级并行的技术有：流水线。 如果处理器可以达到比一个周期一条指令更快的执行速率，称之为超标量处理器。 7.2.3 单指令、多数据并行许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即 SIMD 并行。比如现代 Intel 和 AMD 处理器都具有并行对 8 对单精度浮点数做加法的指令。 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:7:2","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#单指令多数据并行"},{"categories":["计算机体系结构"],"content":" 7.3 计算机系统中抽象的重要性抽象是计算机科学中最为重要的概念之一。 在处理器里，指令集架构提供了对实际处理器硬件的抽象。虚拟机，提供对整个计算机的抽象，包括操作系统、处理器和程序。 操作系统提供的一些抽象 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:7:3","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#计算机系统中抽象的重要性"},{"categories":["计算机体系结构"],"content":" 8 重点小结 了解一个系统的硬件组成，以及这些硬件如何协作来执行一个程序； 理解程序执行的局部性原理，引入高速缓存的原因，并理解存储设备的层次结构； 理解计算机系统中抽象的重要性，理解虚拟机、指令集架构、进程、虚拟内存和文件的抽象概念。 ","date":"2023-11-25","objectID":"/posts/computer_architecture/csapp/csapp_01/:8:0","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 计算机系统漫游","uri":"/posts/computer_architecture/csapp/csapp_01/#重点小结"},{"categories":["计算机体系结构"],"content":"深入理解计算机系统 —— 前言","date":"2023-11-24","objectID":"/posts/computer_architecture/csapp/csapp_00/","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 前言","uri":"/posts/computer_architecture/csapp/csapp_00/"},{"categories":["计算机体系结构"],"content":" 1 学习 CSAPP 的目的 学习计算机系统的本质概念，应用这些概念以提升应用程序的正确性、性能和实用性； 学习如何能够利用系统知识来编写出更好的程序； 做好更深入探究的准备，研究像编译器、计算机体系结构、操作系统、嵌入式系统、网络互联和网络安全等高级题目。 ","date":"2023-11-24","objectID":"/posts/computer_architecture/csapp/csapp_00/:1:0","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 前言","uri":"/posts/computer_architecture/csapp/csapp_00/#学习-csapp-的目的"},{"categories":["计算机体系结构"],"content":" 2 如何学习 CSAPPCSAPP 以程序员的角度，讲述应用程序员如何能够利用系统来编写出更好的程序。 学习系统的唯一方法就是做系统，在真正的系统上解决具体问题，或是编写和运行程序。 ","date":"2023-11-24","objectID":"/posts/computer_architecture/csapp/csapp_00/:2:0","series":["深入理解计算机系统 阅读笔记"],"tags":["深入理解计算机系统"],"title":"深入理解计算机系统 —— 前言","uri":"/posts/computer_architecture/csapp/csapp_00/#如何学习-csapp"},{"categories":["计算机体系结构"],"content":"汇编语言 —— 使用BIOS进行键盘输入和磁盘读写","date":"2023-11-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_17/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 使用BIOS进行键盘输入和磁盘读写","uri":"/posts/computer_architecture/assemply_language/assemply_language_17/"},{"categories":["计算机体系结构"],"content":" 1 INT 9 中断例程对键盘输入的处理键盘输入将引发 9 号中断，BIOS 提供了 int 9 中断例程 。CPU 在 9 号中断发生后，执行 int 9 中断例程，从 60h 端又读出扫描码，并将其转化为相应的 ASCII 码或状态信息，存储在内存的指定空间(键盘缓冲区或状态字节)中。 一般的键盘输入，在 CPU 执行完 int 9 中断例程后，都放到了键盘缓冲区中。键盘缓冲区中有 16 个字单元，可以存储 15 个按键的扫描码和对应的 ASCII 码。 警告 在这里，仅在逻辑结构的基础上，讨论 BIOS 键盘缓冲区的读写问题。其实键盘缓冲区是用环形队列结构管理的内存区。 下面通过 A、B、C、D、E、Shift_A、A 的输入过程，简要地看一下 int 9 中断例程对键盘输入的处理方法。 初始状态下，没有键盘输入，键盘缓冲区空，此时没有任何元素。 键盘缓冲区状态 1 按下 A 键，引发键盘中断：CPU 执行 int 9 中断例程，从 60h 端又读出 A 键的通码：然后检测状态字节，看看是否有 Shift、Ctrl 等切换键按下；发现没有切换键按下，则将 A 键的扫描码 1Eh 和对应的 ASCII 码 61h，写入键盘缓冲区。缓冲区的字单元中，高位字节存储扫描码，低位字节存储 ASCII 码。此时缓冲区中的内容如下： 键盘缓冲区状态 2 按下 B、C、D、E 键后，缓冲区中的内容如下： 键盘缓冲区状态 3 按下左 Shift 键，引发键盘中断：int 9 中断例程接收左 Shift 键的通码，设置 0040:17 处的状态字节的第 1 位为 1，表示左 Shift 键按下。 按下 A 键，引发键盘中断：CPU 执行 int9 中断例程，从 60h 端又读出 A 键的通码；检测状态字节，看看是否有切换键按下;发现左 Shift 键被按下，则将 A 键的扫描码 1Eh 和 Shift_A 对应的 ASCII 码，即字母 “A” 的 ASCII 码 41h，写入键盘缓冲区。此时缓冲区中的内容如下： 键盘缓冲区状态 5 松开左 Shift 键，引发键盘中断：int 9 中断例程接收左 Shift 键的断码，设置 0040:17 处的状态字节的第 1 位为 0，表示左 Shift 键松开。 按下 A 键，引发键盘中断：CPU 执行 int 9 中断例程，从 60h 端又读出 A 键的通码：然后检测状态字节，看看是否有 Shift、Ctrl 等切换键按下；发现没有切换键按下，则将 A 键的扫描码 1Eh 和对应的 ASCII 码 61h，写入键盘缓冲区。缓冲区的字单元中，高位字节存储扫描码，低位字节存储 ASCII 码。此时缓冲区中的内容如下： 键盘缓冲区状态 7 ","date":"2023-11-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_17/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 使用BIOS进行键盘输入和磁盘读写","uri":"/posts/computer_architecture/assemply_language/assemply_language_17/#int-9-中断例程对键盘输入的处理"},{"categories":["计算机体系结构"],"content":" 2 使用 INT 16H 中断例程读取键盘缓冲区BIOS 提供了 int 16h 中断例程供程序员调用。int 16h 中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为 0。 下面的指令从键盘缓冲区中读取一个键盘输入，并且将其从缓冲区中删除： text mov ah, 0 int 16h 结果：(ah)=扫描码，(al)=ASCII码。 下面我们接着上一节中的键盘输入过程，看一下 int 16h 如何读取键盘缓冲区： 执行 mov ah, 0; int 16h 后，缓冲区的内容如下： 键盘缓冲区状态 8 ah 中的内容为 1Eh，al 中的内容为 61h。 执行 6 次 mov ah, 0; int 16h 后，缓冲区空： 键盘缓冲区状态 9 ah 中的内容为 1Eh，al 中的内容为 61h。 执行 mov ah, 0; int 16h 后，int 16h 中断例程检测键盘缓冲区，发现缓冲区空，则循环等待，直到缓冲区中有数据。 按下 A 键后，缓冲区中的内容如下： 键盘缓冲区状态 10 循环等待的 int 16h 中断例程检测到键盘缓冲区中有数据，将其读出，缓冲区又为空： 键盘缓冲区状态 11 ah 中的内容为 1Eh，al 中的内容为 61h。 从上面我们可以看出， int 16h 中断例程的 0 号功能，进行如下的工作： 检测键盘缓冲区中是否有数据； 没有则继续做第 1 步； 读取缓冲区第一个字单元中的键盘输入； 将读取的扫描码送入 ah，ASCII 码送入 al； 将已读取的键盘输入从缓冲区中删除。 BIOS 的 int 9 中断例程和 int 16h 中断例程是一对相互配合的程序，int 9 中断例程向键盘缓冲区中写入，int 16h 中断例程从缓冲区中读出。它们写入和读出的时机不同，int 9 中断例程是在有键按下的时候向键盘缓冲区中写入数据；而 int 16h 中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。 ","date":"2023-11-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_17/:2:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 使用BIOS进行键盘输入和磁盘读写","uri":"/posts/computer_architecture/assemply_language/assemply_language_17/#使用-int-16h-中断例程读取键盘缓冲区"},{"categories":["计算机体系结构"],"content":" 3 应用 INT 13H 中断例程对磁盘进行读写以 3.5 英寸软盘为例：软盘分为上下两面，每面有 80 个磁道，每个磁道又分为 18 个扇区，每个扇区的大小为 512 个字节。 磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘。只能以扇区为单位对磁盘进行读写。在读写扇区的时候，要给出面号、磁道号和扇区号。面号和磁道号从 0 开始，而扇区号从 1 开始。 ","date":"2023-11-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_17/:3:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 使用BIOS进行键盘输入和磁盘读写","uri":"/posts/computer_architecture/assemply_language/assemply_language_17/#应用-int-13h-中断例程对磁盘进行读写"},{"categories":["计算机体系结构"],"content":" 3.1 从磁盘读取数据BIOS 提供的访问磁盘的中断例程为 int 13h。读取 0 面 0 道 1 扇区的内容到 0:200 的程序如下所示： text mov ax, 0 mov es, ax mov bx, 200h mov al, 1 mov ch, 0 mov cl, 1 mov dl, 0 mov dh, 0 mov ah, 2 int 13h 入口参数： (ah)=int 13h 的功能号(2 表示读扇区) (al)=读取的扇区数 (ch)=磁道号 (cl)=扇区号 (dh)=磁头号(对于软盘即面号，因为一个面用一个磁头来读写) (dl)=驱动器号（软驱从 0 开始，0：软驱A，1：软驱B；硬盘从 80h 开始，80h：硬盘C，81h：硬盘D） es:bx 指向接收从扇区读入数据的内存区 返回参数： 操作成功：(ah)=0，(al)=读入的扇区数 操作失败：(ah)=出错代码 ","date":"2023-11-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_17/:3:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 使用BIOS进行键盘输入和磁盘读写","uri":"/posts/computer_architecture/assemply_language/assemply_language_17/#从磁盘读取数据"},{"categories":["计算机体系结构"],"content":" 3.2 从磁盘写入数据将 0:200 中的内容写入 0 面 0 道 1 扇区的程序如下所示： text mov ax, 0 mov es, ax mov bx, 200h mov al, 1 mov ch, 0 mov cl, 1 mov dl, 0 mov dh, 0 mov ah, 3 int 13h 入口参数： (ah)=int 13h 的功能号(3 表示写扇区) (al)=写入的扇区数 (ch)=磁道号 (cl)=扇区号 (dh)=磁头号(面) (dl)=驱动器号 es:bx 指向将写入磁盘的数据 返回参数： 操作成功：(ah)=0，(al)=写入的扇区数 操作失败：(ah)=出错代码 ","date":"2023-11-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_17/:3:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 使用BIOS进行键盘输入和磁盘读写","uri":"/posts/computer_architecture/assemply_language/assemply_language_17/#从磁盘写入数据"},{"categories":["计算机体系结构"],"content":"汇编语言 —— 直接定址表","date":"2023-11-22","objectID":"/posts/computer_architecture/assemply_language/assemply_language_16/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 直接定址表","uri":"/posts/computer_architecture/assemply_language/assemply_language_16/"},{"categories":["计算机体系结构"],"content":" 1 描述了单元长度的标号我们一直在代码段中使用标号来标记指令、数据、段的起始地址。 text assume cs:code code segment a: db 1,2,3,4,5,6,7,8 b: dw 0 start: ... ... code ends end start 上述案例中，code、a、b、start、s 都是标号。这些标号仅仅表示内存单元的地址。 我们还可以使用一种标号，这种标号不但表示内存单元的地址，还表示了内存单元的长度，即表示在此标号处的单元，是一个字节单元，还是字单元，还是双字单元。 text assume cs:code code segment a db 1,2,3,4,5,6,7,8 b dw 0 start: ... ... code ends end start 在 code 段中使用的标号 a、b 后面没有 “:”，它们是同时描述内存地址和单元长度的标号。标号 a，描述了地址 code:0，和从这个地址开始，以后的内存单元都是字节单元；而标号 b 描述了地址 code:8，和从这个地址开始，以后的内存单元都是字单元。 我们将这种标号称数据标号，它标记了存储数据的单元的地址和长度。它不同于仅仅表示地址的地址标号。 地址标号只能在代码段中使用，不能在其他段中使用。 ","date":"2023-11-22","objectID":"/posts/computer_architecture/assemply_language/assemply_language_16/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 直接定址表","uri":"/posts/computer_architecture/assemply_language/assemply_language_16/#描述了单元长度的标号"},{"categories":["计算机体系结构"],"content":" 2 在其他段中使用数据标号一般来说，我们不在代码段中定义数据，而是将数据定义到其他段中。在其他段中，我们也可以使用数据标号来描述存储数据的单元的地址和长度。 下面的程序将 data 段中 a 标号处的 8 个数据累加，结果存储到 b 标号处的字中： text assume cs:code, ds:data ; 用 assume 将寄存器与 data 相联 data segment a db 1,2,3,4,5,6,7,8 b dw 0 data ends code segment start: mov ax, data mov ds, ax ; 用指令对段寄存器进行设置 mov si, 0 mov cx, 8 s: mov al, a[si] ; 直接使用数据标号 a 访问数据 mov ah, 0 add b, ax ; 直接使用数据标号 b 访问数据 inc si loop s mov ax, 4c00h int 21h code ends end start 我们要在代码段 code 中用 data 段中的数据标号 a、b 访问数据，则必须用 assume 将一个寄存器和 data 段相联。 ","date":"2023-11-22","objectID":"/posts/computer_architecture/assemply_language/assemply_language_16/:2:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 直接定址表","uri":"/posts/computer_architecture/assemply_language/assemply_language_16/#在其他段中使用数据标号"},{"categories":["计算机体系结构"],"content":" 3 直接定址表利用表，在两个数据集合之间建立一种映射关系，使我们可以用查表的方法根据给出的数据得到其在另一集合中的对应数据。这样做的目的一般有 3 个。 为了算法的清晰和简洁； 为了加快运算速度； 为了使程序易于扩充。 用查表的依据数据，直接计算出所要查找的元素在表中的位置，可以通过依据数据，直接计算出所要找的元素的位置的表，我们称其为直接定址表。 ","date":"2023-11-22","objectID":"/posts/computer_architecture/assemply_language/assemply_language_16/:3:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 直接定址表","uri":"/posts/computer_architecture/assemply_language/assemply_language_16/#直接定址表"},{"categories":["计算机体系结构"],"content":" 4 程序入口地址的直接定址表我们可以在直接定址表中存储子程序的地址，从而方便地实现不同子程序的调用。 ","date":"2023-11-22","objectID":"/posts/computer_architecture/assemply_language/assemply_language_16/:4:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 直接定址表","uri":"/posts/computer_architecture/assemply_language/assemply_language_16/#程序入口地址的直接定址表"},{"categories":["计算机体系结构"],"content":"汇编语言 —— 外中断","date":"2023-11-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_15/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 外中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_15/"},{"categories":["计算机体系结构"],"content":"CPU 除了有运算能力外，还要有 I/O 能力。 要及时处理外设的输入，需要解决两个问题： 外设的输入随时可能发生，CPU 如何得知？ CPU 从何处得到外设的输入？ ","date":"2023-11-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_15/:0:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 外中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_15/#"},{"categories":["计算机体系结构"],"content":" 1 接口芯片和端口PC 系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CPU 将这些寄存器当作端口来访问。 外设的输入不直接送入内存和 CPU，而是送入相关的接口芯片的端口中；CPU 向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。CPU 还可以向外设输出控制命令，而这些控制命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施控制。 CPU 通过端口和外部设备进行联系。 ","date":"2023-11-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_15/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 外中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_15/#接口芯片和端口"},{"categories":["计算机体系结构"],"content":" 2 外中断信息外设随时都可能发生需要 CPU 及时处理的事件，CPU 如何及时得知并进行处理？ CPU 提供中断机制来满足这种需要。 当 CPU 外部有需要处理的事情发生的时候比如外设的输入到达，相关芯片将向 CPU 发出相应的中断信息。CPU 在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。 在 PC 系统中，外中断源一共有以下两类： 可屏蔽中断 不可屏蔽中断 ","date":"2023-11-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_15/:2:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 外中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_15/#外中断信息"},{"categories":["计算机体系结构"],"content":" 2.1 可屏蔽中断可屏蔽中断是 CPU 可以不响应的外中断。CPU 是否响应可屏蔽中断，要看标志寄存器的 IF 位的设置。当 CPU 检测到可屏蔽中断信息时，如果 IF=1，则 CPU 在执行完当前指令后响应中断，引发中断过程：如果 IF=0，则不响应可屏蔽中断。 内中断将 IF 置为 0 的原因是：在进入中断处理程序后，禁止其他的可屏蔽中断。 8086CPU 提供的设置 IF 的指令如下： sti，设置 IF=1； cli，设置 IF=0。 几乎所有由外设引发的外中断，都是可屏蔽中断。当外设有需要处理的事件（比如说键盘输入）发生时，相关芯片向 CPU 发出可屏蔽中断信息。 ","date":"2023-11-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_15/:2:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 外中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_15/#可屏蔽中断"},{"categories":["计算机体系结构"],"content":" 2.2 不可屏蔽中断不可屏蔽中断是 CPU 必须响应的外中断。当 CPU 检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。 对于 8086CPU，不可屏蔽中断的中断类型码固定为 2，所以中断过程中，不需要取中断类型码。则不可屏蔽中断的中断过程为： 标志寄存器入栈，IF=0，TF=0； CS、IP 入栈； (IP)=(8), (CS)=(0AH)。 不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知 CPU 的中断信息。 ","date":"2023-11-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_15/:2:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 外中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_15/#不可屏蔽中断"},{"categories":["计算机体系结构"],"content":" 3 指令系统总结8086CPU提供以下几大类指令。 ","date":"2023-11-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_15/:3:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 外中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_15/#指令系统总结"},{"categories":["计算机体系结构"],"content":" 3.1 数据传送指令比如，mov、push、pop、pushf、popf、xchg 等都是数据传送指令，这些指令实现寄存器和内存、寄存器和寄存器之间的单个数据传送。 ","date":"2023-11-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_15/:3:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 外中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_15/#数据传送指令"},{"categories":["计算机体系结构"],"content":" 3.2 算术运算指令比如，add、sub、adc、sbb、inc、dec、cmp、imul、idiv、aaa 等都是算术运算指令，这些指令实现寄存器和内存中的数据的算数运算。它们的执行结果影响标志寄存器的 sf、zf、of、cf、pf、af 位。 ","date":"2023-11-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_15/:3:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 外中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_15/#算术运算指令"},{"categories":["计算机体系结构"],"content":" 3.3 逻辑指令比如，and、or、not、xor、test、shl、shr、sal、sar、rol、ror、rcl、rcr 等都是逻辑指令。除了 not 指令外，它们的执行结果都影响标志寄存器的相关标志位。 ","date":"2023-11-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_15/:3:3","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 外中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_15/#逻辑指令"},{"categories":["计算机体系结构"],"content":" 3.4 转移指令可以修改 IP，或同时修改 CS 和 IP 的指令统称为转移指令。转移指令分为以下几类： 无条件转移指令，比如，jmp； 条件转移指令，比如，jcxz、je、jb、ja、jnb、jna 等； 循环指令，比如，loop; 过程，比如，call、ret、retf； 中断，比如，int、iret。 ","date":"2023-11-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_15/:3:4","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 外中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_15/#转移指令"},{"categories":["计算机体系结构"],"content":" 3.5 处理机控制指令这些指令对标志寄存器或其他处理机状态进行设置，比如，cld、std、cli、sti、nop、clc、cmc、stc、hlt、wait、ese、lock 等都是处理机控制指令。 ","date":"2023-11-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_15/:3:5","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 外中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_15/#处理机控制指令"},{"categories":["计算机体系结构"],"content":" 3.6 串处理指令这些指令对内存中的批量数据进行处理，比如，movsb、movsw、cmps、scas、lods、stos 等。若要使用这些指令方便地进行批量数据的处理，则需要和 rep、repe、repne 等前缀指令配合使用。 ","date":"2023-11-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_15/:3:6","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 外中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_15/#串处理指令"},{"categories":["计算机体系结构"],"content":"汇编语言 —— 端口","date":"2023-11-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_14/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 端口","uri":"/posts/computer_architecture/assemply_language/assemply_language_14/"},{"categories":["计算机体系结构"],"content":"在 PC 机系统中，和 CPU 通过总线相连的芯片除各种存储器外，还有以下 3 种芯片： 各种接口卡(比如，网卡、显卡)上的接口芯片，它们控制接口卡进行工作； 主板上的接口芯片，CPU 通过它们对部分外设进行访问； 其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。 在这些芯片中，都有一组可以由 CPU 读写的寄存器。这些寄存器，它们在物理上可能处于不同的芯片中，但是它们在以下两点上相同： 都和 CPU 的总线相连，这种连接是通过它们所在的芯片进行的； CPU 对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令。 从 CPU 的角度，将这些寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。 CPU 可以直接读写以下 3 个地方的数据： CPU 内部的寄存器； 内存单元； 端口。 ","date":"2023-11-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_14/:0:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 端口","uri":"/posts/computer_architecture/assemply_language/assemply_language_14/#"},{"categories":["计算机体系结构"],"content":" 1 端口的读写在访问端口的时候，CPU 通过端口地址来定位端口。因为端口所在的芯片和 CPU 通过总线相连，所以，端口地址和内存地址一样，通过地址总线来传送。在 PC 系统中， CPU 最多可以定位 64KB 个不同的端口。则端口地址的范围为 O~65535。 端口的读写指令只有两条: in 和 out，分别用于从端口读取数据和往端口写入数据。 指令 in al, 60h ; 从 60h 号端口读入一个字节 执行时与总线相关的操作如下： CPU 通过地址线将地址信息 60h 发出； CPU 通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据； 端口所在的芯片将 60h 端口中的数据通过数据线送入 CPU。 警告 在 in 和 out 指令中，只能使用 ax 或 al 来存放从端口中读入的数据或要发送到端口中的数据。访问 8 位端口时用 al，访问 16 位端口时用 ax。 对 0~255 以内的端口进行读写时： text in al, 20h ; 从 20h 端口读入一个字节 out 20h, al ; 往 20h 端口写入一个字节 对 256~65535 的端口进行读写时，端口号放在 dx 中： text mov dx, 3f8h ; 将端口号 3f8h 送入 dx in al, dx ; 从 3f8h 端口读入一个字节 out dx, al ; 向 3f8h 端口写入一个字节 ","date":"2023-11-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_14/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 端口","uri":"/posts/computer_architecture/assemply_language/assemply_language_14/#端口的读写"},{"categories":["计算机体系结构"],"content":" 2 CMOS RAM 芯片PC 机中，有一个 CMOS RAM 芯片，一般简称为 CMOS。此芯片的特征如下： 包含一个实时钟和一个有 128 个存储单元的 RAM 存储器； 该芯片靠电池供电。所以，关机后其内部的实时钟仍可正常工作，RAM 中的信息不丢失。 128 个字节的 RAM 中，内部实时钟占用 0～0dh 单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时 BIOS 程序读取。BIOS 也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM 中的系统信息。 该芯片内部有两个端口，端口地址为 70h 和 71h 。CPU 通过这两个端口来读写 CMOS RAM。 70h 为地址端口，存放要访问的 CMOS RAM 单元的地址；71h 为数据端口，存放从选定的 CMOS RAM 单元中读取的数据，或要写入到其中的数据。 可见，CPU 对 CMOS RAM 的读写分两步进行，比如，读 CMOS RAM 的 2 号单元: 将 2 送入端口 70h； 从端口 71h 读出 2 号单元的内容。 示例 读取 CMOS RAM 的 2 号单元内容： text assume cs:code code segment start: mov al, 2h out 70h, al ; 将 2 送入端口 70h in al, 71h ; 从 71h 读出 2 号单元内容 mov ax, 4c00h int 21h code ends end start 向 CMOS RAM 的 2 号单元写入 0： text assume cs:code code segment start: mov al, 2h out 70h, al ; 将 2 送入端口 70h mov al, 0 out 71h, al ; 将 0 写入 2 号单元 mov ax, 4c00h int 21h code ends end start ","date":"2023-11-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_14/:2:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 端口","uri":"/posts/computer_architecture/assemply_language/assemply_language_14/#cmos-ram-芯片"},{"categories":["计算机体系结构"],"content":" 3 SHL 和 SHR 指令shl 是逻辑左移指令，它的功能为： 将一个寄存器或内存单元中的数据向左移位； 将最后移出的一位写入 CF 中； 最低位用 0 补充。 示例 text mov al, 01010001b mov cl,3 ; 移动位数大于 1 时，必须将移动位数放在 cl 中 shl al, cl 执行后 (al)=10001000b，因为最后移出的一位是 0，所以 CF=0。 将 X 逻辑左移一位，相当于执行 X=X*2。 shr 是逻辑右移指令，它和 shl 所进行的操作刚好相反： 将一个寄存器或内存单元中的数据向右移位； 将最后移出的一位写入 CF 中； 最高位用 0 补充。 示例 text mov al, 01010001b mov cl,3 ; 移动位数大于 1 时，必须将移动位数放在 cl 中 shr al, cl 执行后 (al)=00001010b，因为最后移出的一位是 0，所以 CF=0。 将 X 逻辑右移一位，相当于执行 X=X/2。 ","date":"2023-11-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_14/:3:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 端口","uri":"/posts/computer_architecture/assemply_language/assemply_language_14/#shl-和-shr-指令"},{"categories":["计算机体系结构"],"content":"汇编语言 —— INT指令","date":"2023-11-15","objectID":"/posts/computer_architecture/assemply_language/assemply_language_13/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— INT指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_13/"},{"categories":["计算机体系结构"],"content":"中断信息可以来自 CPU 的内部和外部，当 CPU 的内部有需要处理的事情发生的时候，将产生需要马上处理的中断信息，引发中断过程。 本章，讲解由 int 指令引发的内中断。 ","date":"2023-11-15","objectID":"/posts/computer_architecture/assemply_language/assemply_language_13/:0:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— INT指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_13/#"},{"categories":["计算机体系结构"],"content":" 1 INT 指令int 指令的格式为：int n，n 为中断类型码，它的功能是引发中断过程。 CPU 执行 int n 指令，相当于引发一个 n 号中断的中断过程，执行过程如下： 取中断类型码n； 标志寄存器入栈，IF=0，TF=0； CS、IP 入栈； (IP)=(nx4)，(CS)=(nx4+2)。 从此处转去执行 n 号中断的中断处理程序。 一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。我们在编程的时候，可以用 int 指令调用这些子程序。也可以自己编写一些中断处理程序供别人使用。 中断处理程序又称中断例程。 ","date":"2023-11-15","objectID":"/posts/computer_architecture/assemply_language/assemply_language_13/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— INT指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_13/#int-指令"},{"categories":["计算机体系结构"],"content":" 2 编写供应用程序调用的中断例程这里通过两个案例来讨论可以供应用程序调用的中断例程的编写方法。 ","date":"2023-11-15","objectID":"/posts/computer_architecture/assemply_language/assemply_language_13/:2:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— INT指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_13/#编写供应用程序调用的中断例程"},{"categories":["计算机体系结构"],"content":" 2.1 案例1：编写、安装中断 7ch 的中断例程功能：求 word 型数据的平方。 参数：(ax) = 要计算的数据。 返回值：dx、ax 中存放结果的高 16 位和低 16 位。 应用举例：求 2*3456^2 的值 text assume cs:code code segment start: mov ax, 3456 ; (ax)=3456 int 7ch ; 计算 ax 中数据的平方 add ax, ax adc dx, dx ; dx:ax 存放结果，将结果乘以2 mov ax, 4c00h int 21h code ends end start 我们要做以下 3 部分工作： 编写实现求平方功能的程序； 安装程序，将其安装在 0:200 处； 设置中断向量表，将程序的入口地址保存在 7ch 表项中，使其成为中断 7ch 的中断例程。 安装程序如下： text assume cs:code code segment start: mov ax, cs mov ds, ax mov si, offset sqr ; 设置 ds:si 指向源地址 mov ax, 0 mov es, ax mov di, 200 ; 设置 es:di 指向目的地址 mov cx, offset sqrend-offset sqr ; 设置 cx 为传输长度 cld ; 设置传输方向为正 rep movsb mov ax, 0 mov es, ax mov word ptr es:[7ch*4], 200h mov word ptr es:[7ch*4+2], 0 mov ax, 4c00h int 21h sqr: mul ax iret ; 在中断例程最后使用 iret 指令 sqrend: nop code ends end start CPU 执行 int 7ch 指令进入中断例程之前，标志寄存器、当前的 CS 和 IP 被压入栈中，在执行完中断例程后，应该用 iret 指令恢复 int 7ch 执行前的标志寄存器和 CS、IP 的值，从而接着执行应用程序。 int 指令和 iret 指令的配合使用与 call 指令和 ret 指令的配合使用具有相似的思路。 ","date":"2023-11-15","objectID":"/posts/computer_architecture/assemply_language/assemply_language_13/:2:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— INT指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_13/#案例1编写安装中断-7ch-的中断例程"},{"categories":["计算机体系结构"],"content":" 2.2 案例2：编写、安装中断 7ch 的中断例程功能：将一个全是字母，以 0 结尾的字符串，转化为大写。 参数：ds:si 指向字符串的首地址。 应用举例：将 data 段中的字符串转化为大写。 text assume cs:code data segment db 'conversation',0 data ends code segment start: mov ax, data mov ds, ax mov si, 0 int 7ch mov ax, 4c00h int 21h code ends end start 安装程序如下： text assume cs:code code segment start: mov ax, cs mov ds, ax mov si, offset capital mov ax, 0 mov es, ax mov di, 200h mov cx, offset capitalend-offset capital cld rep movsb mov ax, 0 mov es, ax mov word ptr es:[7ch*4], 200h mov word ptr es:[7ch*4+2], 0 mov ax, 4c00h int 21h capital: push cx push si change: mov cl, [si] mov ch, 0 jcxz ok and byte ptr [si], 11011111b inc si jmp short change ok: pop si pop cx iret capitalend: nop code ends end start 在中断例程 capital 中用到了寄存器 si 和 cx，编写中断例程和编写子程序的时候具有同样的问题，就是要避免寄存器的冲突。应该注意例程中用到的寄存器的值的保存和恢复。 ","date":"2023-11-15","objectID":"/posts/computer_architecture/assemply_language/assemply_language_13/:2:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— INT指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_13/#案例2编写安装中断-7ch-的中断例程"},{"categories":["计算机体系结构"],"content":" 3 对 int、iret 和栈的深入理解问题：用 7ch 中断例程完成 loop 指令的功能。 loop s 的执行需要两个信息，循环次数和到 s 的位移，所以，7ch 中断例程要完成 loop 指令的功能，也需要这两个信息作为参数。我们用 cx 存放循环次数，用 bx 存放位移。 应用举例：在屏幕中间显示 80 个 “!”。应用代码如下： text assume cs:code code segment start: mov ax, 0b800h mov es, ax mov di, 160*12 mov bx, offset s-offset se ; 设置从标号 se 到标号 s 的转移位移 mov cx, 80 s: mov byte ptr es:[di], '!' add di, 2 int 7ch ; 如果 (cx)!=0，转移到标号 s 处 se: nop mov ax, 4c00h int 21h code ends end start 分析：为了模拟 loop 指令，7ch 中断例程应具备下面的功能： dec cx； 如果 (cx)!=0，转到标号 s 处执行，否则向下执行。 int 7ch 引发中断过程后，进入 7ch 中断例程，在中断过程中，当前的标志寄存器、CS 和 IP 都要压栈，此时压入的 CS 和 IP 中的内容，分别是调用程序的段地址(可以认为是标号 s 的段地址)和 int 7ch 后一条指令的偏移地址(即标号 se 的偏移地址)。在中断例程中，可以从栈里取得标号 s 的段地址和标号 se 的偏移地址，用标号 se 的偏移地址加上 bx 中存放的转移位移就可以得到标号 s 的偏移地址。利用 iret 指令，我们将栈中的 se 的偏移地址加上 bx 中的转移位移，则栈中的 se 的偏移地址就变为了 s 的偏移地址。我们再使用 iret 指令，用栈中的内容设置 CS、IP，从而实现转移到标号 s 处。 7ch 中断例程如下： text lp: push bp mov bp, sp dec cx jcxz lpret add [bp+2], bx ; [bp+2] 存储的是 IP 的值 lpret: pop bp iret 因为要访问栈，使用了 bp，在程序开始处将 bp 入栈保存，结束时出栈恢复。当要修改栈中 se 的偏移地址的时候，栈中的情况为：栈顶处是 bp 原来的数值，下面是 se 的偏移地址，再下面是 s 的段地址，再下面是标志寄存器的值。而此时，bp 中栈顶的偏移地址，所以 ((ss)*16+(bp)+2) 处为 se 的偏移地址，将它加上 bx 中的转移位移就变为 s 的偏移地址。最后用 iret 出栈返回，CS:IP 即从标号 s 处开始执行指令。 技巧 bp 为基址寄存器，一般在函数中用来保存进入函数时的 sp 的栈顶基址。 每次子函数调用时，系统在开始时都会保存这个两个指针并在函数结束时恢复 sp 和 bp 的值。 text sub: push bp ; 保存父函数 bp 指针 mov bp, sp ; bp 指向 sp 的基地址 ; 此时，如果该函数有参数，则 ; [bp+4] 是子函数的第一个参数， ; [bp+6] 是子函数的第二个参数。 mov sp, bp ; 将原 sp 指针传回 sp pop bp ; 恢复原 bp 的值 ret ; 退出子函数 ","date":"2023-11-15","objectID":"/posts/computer_architecture/assemply_language/assemply_language_13/:3:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— INT指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_13/#对-intiret-和栈的深入理解"},{"categories":["计算机体系结构"],"content":" 4 BIOS 和 DOS 所提供的中断例程在系统板的 ROM 中存放着一套程序，称为 BIOS (基本输入输出系统)，BIOS 中主要包含以下几部分内容： 硬件系统的检测和初始化程序； 外部中断和内部中断的中断例程； 用于对硬件设备进行 IO 操作的中断例程； 其他和硬件系统相关的中断例程。 操作系统 DOS 也提供了中断例程，从操作系统的角度来看，DOS 的中断例程就是操作系统向程序员提供的编程资源。 程序员在编程的时候，可以用 int 指令直接调用 BIOS 和 DOS 提供的中断例程，来完成某些工作。 ","date":"2023-11-15","objectID":"/posts/computer_architecture/assemply_language/assemply_language_13/:4:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— INT指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_13/#bios-和-dos-所提供的中断例程"},{"categories":["计算机体系结构"],"content":" 5 BIOS 和 DOS 中断例程的安装过程BIOS 和 DOS 提供的中断例程的安装过程如下： 开机后，CPU 一加电，初始化 (CS)=OFFFFH，(IP)=0，自动从 FFFF:0 单元开始执行程序。FFFF:0 处有一条转跳指令，CPU 执行该指令后，转去执行 BIOS 中的硬件系统检测和初始化程序； 初始化程序将建立 BIOS 所支持的中断向量，即将 BIOS 提供的中断例程的入口地址登记在中断向量表中。对于 BIOS 所提供的中断例程，只需将入口地址登记在中断向量表中即可，因为它们是固化到 ROM 中的程序，一直在内存中存在； 硬件系统检测和初始化完成后，调用 int 19h 进行操作系统的引导。从此将计算机交由操作系统控制； DOS 启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。 ","date":"2023-11-15","objectID":"/posts/computer_architecture/assemply_language/assemply_language_13/:5:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— INT指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_13/#bios-和-dos-中断例程的安装过程"},{"categories":["计算机体系结构"],"content":" 6 21h 号中断例程int 21h 中断例程是 DOS 提供的中断例程，其中包含了 DOS 提供给程序员在编程时调用的子程序。 text mov ah, 4ch ; 程序返回 mov al, 0 ; 返回值 int 21h (ah)=4ch 表示调用第 21h 号中断例程的 4ch 号子程序，功能为程序返回，可以提供返回值作为参数。 ","date":"2023-11-15","objectID":"/posts/computer_architecture/assemply_language/assemply_language_13/:6:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— INT指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_13/#21h-号中断例程"},{"categories":["计算机体系结构"],"content":"汇编语言 —— 内中断","date":"2023-11-13","objectID":"/posts/computer_architecture/assemply_language/assemply_language_12/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 内中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_12/"},{"categories":["计算机体系结构"],"content":"任何一个通用的 CPU，比如 8086，都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从 CPU 外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。这种特殊的信息，我们可以称其为：中断信息。中断的意思是指，CPU 不再接着(刚执行完的指令)向下执行，而是转去处理这个特殊信息。 中断信息是对几个具有先后顺序的硬件操作所产生的事件的统一描述。“中断信息” 是要求 CPU 马上进行某种处理，并向所要进行的该种处理提供了必备的参数的通知信息。中断信息可以来自 CPU 的内部和外部，这里我们主要讨论来自于 CPU 内部的中断信息。 ","date":"2023-11-13","objectID":"/posts/computer_architecture/assemply_language/assemply_language_12/:0:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 内中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_12/#"},{"categories":["计算机体系结构"],"content":" 1 内中断的产生对于 8086CPU，当 CPU 内部有下面的情况发生的时候，将产生相应的中断信息： 除法错误，比如，执行 div 指令产生的除法溢出； 单步执行； 执行 into 指令； 执行 int 指令。 中断信息的来源称为中断源，上述的 4 种中断源，在 8086CPU 中的中断类型码如下： 除法错误：0 单步执行：1 执行 into 指令：4 执行 int 指令，该指令的格式为 int n，指令中的 n 为字节型立即数，是提供给 CPU 的中断类型码。 中断类型码为一个字节型数据，可以表示 256 种中断信息的来源。 ","date":"2023-11-13","objectID":"/posts/computer_architecture/assemply_language/assemply_language_12/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 内中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_12/#内中断的产生"},{"categories":["计算机体系结构"],"content":" 2 中断处理程序CPU 在收到中断信息后，应该转去执行该中断信息的处理程序。若要 8086CPU 执行某处的程序，就要将 CS:IP 指向它的入口(即程序第一条指令的地址)。 可见首要的问题是，CPU 在收到中断信息后，如何根据中断信息确定其处理程序的入口。 ","date":"2023-11-13","objectID":"/posts/computer_architecture/assemply_language/assemply_language_12/:2:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 内中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_12/#中断处理程序"},{"categories":["计算机体系结构"],"content":" 3 中断向量表CPU 用 8 位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。 中断向量表就是中断向量的列表。中断向量就是中断处理程序的入口地址。因此，中断向量表，就是中断处理程序入口地址的列表。 CPU 用中断类型码，通过查找中断向量表，就可以得到中断处理程序的入口地址。 中断向量表在内存中存放，对于 8086PC 机，中断向量表指定放在内存地址 0 处。从内存 0000:0000 到 0000:03FF 的 1024 个单元中存放着中断向量表。 在中断向量表中，一个表项存放一个中断向量，也就是一个中断处理程序的入口地址。这个入口地址包括段地址和偏移地址，所以一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。 ","date":"2023-11-13","objectID":"/posts/computer_architecture/assemply_language/assemply_language_12/:3:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 内中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_12/#中断向量表"},{"categories":["计算机体系结构"],"content":" 4 中断过程由上面的讲解可知，可以用中断类型码，在中断向量表中找到中断处理程序的入口。找到这个入口地址的最终目的是用它设置 CS 和 IP，使 CPU 执行中断处理程序。用中断类型码找到中断向量，并用它设置 CS 和 IP，这个工作是由 CPU 的硬件自动完成的。CPU 硬件完成这个工作的过程被称为中断过程。 CPU 收到中断信息后，要对中断信息进行处理，首先将引发中断过程。硬件在完成中断过程后，CS:IP 将指向中断处理程序的入口，CPU 开始执行中断处理程序。 技巧 有一个问题需要考虑，CPU 在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令。所以在中断过程中，在设置 CS:IP 之前，还要将原来的 CS 和 IP 的值保存起来。在使用 call 指令调用子程序时有同样的问题，子程序执行后还要返回到原来的执行点继续执行，所以，call 指令先保存当前 CS 和 IP 的值，然后再设置 CS 和 IP。 下面是 8086CPU 在收到中断信息后，所引发的中断过程： (从中断信息中)取得中断类型码； 标志寄存器的值入栈(因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)； 设置标志寄存器的第 8 位 TF 和第 9 位 IF 的值为0(这一步的目的后面将介绍)； CS 的内容入栈； IP 的内容入栈； 从内存地址为 中断类型码x4 和 中断类型码x4+2 的两个字单元中读取中断处理程序的入口地址设置 IP 和 CS。 CPU 在收到中断信息之后，如果处理该中断信息，就完成一个由硬件自动执行的中断过程(程序员无法改变这个过程中所要做的工作)。中断过程的主要任务就是用中断类型码在中断向量表中找到中断处理程序的入口地址，设置 CS 和 IP。完成后，CPU 还要回过头来继续执行被中断的程序，所以要在设置 CS、IP 之前，先将它们的值保存起来。可以看到 CPU 将它们保存在栈中。在中断过程中还要做的一个工作就是设置标志寄存器的 TF、IF 位（下一章中进行讨论）。因为在执行完中断处理程序后，需要恢复在进入中断处理程序之前的 CPU 现场(某一时刻，CPU 中各个寄存器的值)。所以应该在修改标记寄存器之前，将 它的值入栈保存。 ","date":"2023-11-13","objectID":"/posts/computer_architecture/assemply_language/assemply_language_12/:4:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 内中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_12/#中断过程"},{"categories":["计算机体系结构"],"content":" 5 中断处理程序和 iret 指令中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤： 保存用到的寄存器； 处理中断； 恢复用到的寄存器； 用 iret 指令返回。 iret 通常和硬件自动完成的中断过程配合使用。在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP，而 iret 的出栈顺序是 IP、CS、标志寄存器，刚好和其相对应，实现了用执行中断处理程序前的 CPU 现场恢复标志寄存器和 CS、IP 的工作。 iret 指令执行后，CPU 回到执行中断处理程序前的执行点继续执行程序。 ","date":"2023-11-13","objectID":"/posts/computer_architecture/assemply_language/assemply_language_12/:5:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 内中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_12/#中断处理程序和-iret-指令"},{"categories":["计算机体系结构"],"content":" 6 除法错误中断的处理当 CPU 执行 div 等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为 0 的中断信息，CPU 将检测到这个信息，然后引发中断过程，转去执行 0 号中断所对应的中断处理程序。 系统对 0 号中断的处理 可以看到，当 CPU 执行 div bh 时，发生了除法溢出错误，产生 0 号中断信息，从而引发中断过程，CPU 执行 0 号中断处理程序。我们从图中可以看出系统中的 0 号中断处理程序的功能：显示提示信息“Divide overflow” 后，返回到操作系统中。 ","date":"2023-11-13","objectID":"/posts/computer_architecture/assemply_language/assemply_language_12/:6:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 内中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_12/#除法错误中断的处理"},{"categories":["计算机体系结构"],"content":" 7 编程处理 0 号中断编程：当发生除法溢出时，在屏幕中间显示 “overflow!”，返回 DOS。 ","date":"2023-11-13","objectID":"/posts/computer_architecture/assemply_language/assemply_language_12/:7:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 内中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_12/#编程处理-0-号中断"},{"categories":["计算机体系结构"],"content":" 7.1 分析(1) 当发生除法溢出的时候，产生 0 号中断信息，从而引发中断过程。 此时，CPU 将进行以下工作： 取得中断类型码 0； 标志寄存器入栈，TF、IF 设置为 0； CS、IP 入栈； (IP)=(0x4), (CS)=(0x4+2)。 (2) 当中断 0 发生时，CPU 将转去执行中断处理程序。 只要按如下步骤编写中断处理程序，当中断 0 发生时，即可显示 “overflow!”： 相关处理； 向显示缓冲区送字符串 “overflow!”； 返回 DOS。 我们将这段程序称为：do0。 (3) do0 应存放在内存中的什么地方？ 我们只需找到一块别的程序不会用到的内存区，将 do0 传送到其中即可。 一般情况下，从 0000:0200 至 0000:02FF 的 256 个字节的空间所对应的中断向量表项都是空的，操作系统和其他应用程序都不占用。 我们可以将 do0 传送到内存 0000:0200 处。 (4) 将 do0 的入口地址，即 0000:0200 登记在中断向量表的对应表项中。 因为除法溢出对应的中断类型码为 0，它的中断处理程序的入口地址应该从 0x4 地址单元开始存放，段地址存放在 0x4+2 字单元中，偏移地址存放在 0x4 字单元中。也就是说要将 do0 的段地址 0 存放在 0000:0002 字单元中，将偏移地址 200H 存放在 0000:0000 字单元中。 综上，我们需要做以下事情： 编写可以显示“overflow!”的中断处理程序：do0； 将 do0 送入内存 0000:0200 处； 将 do0 的入口地址 0000:0200 存储在中断向量表 0 号表项中。 ","date":"2023-11-13","objectID":"/posts/computer_architecture/assemply_language/assemply_language_12/:7:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 内中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_12/#分析"},{"categories":["计算机体系结构"],"content":" 7.2 安装 do0 中断处理程序安装 do0 中断处理程序，就是将 do0 的代码送入 0:200 处，可以使用 movsb 指令完成安装。程序如下： text assume cs:code code segment start: mov ax, cs mov ds, ax mov si, offset do0 ; 设置 ds:si 指向源地址 mov ax, 0 mov es, ax mov di, 200h ; 设置 es:di 指向目的地址 0:200 mov cx, offset do0end-offset do0 ; 设置 cx 为传输长度 cld ; 设置传输方向为正 rep movsb ; TODO 设置中断向量表 mov ax, 4c00h int 21h do0: ; TODO 显示字符串“overflow!” mov ax, 4c00h int 21h do0end: nop code ends end start 警告 此处的代码仅仅是将代码 do0 传入 0:200 处，并未执行 do0！ 此处我们利用编译器来计算 do0 的长度，offset do0end-offset do0，“_” 是编译器识别的运算符号，编译器可以用它来进行两个常数的减法。 汇编编译器可以处理表达式。比如，指令：mov ax，(5+3)*5/10，被编译器处理为指令：mov ax, 4。 ","date":"2023-11-13","objectID":"/posts/computer_architecture/assemply_language/assemply_language_12/:7:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 内中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_12/#安装-do0-中断处理程序"},{"categories":["计算机体系结构"],"content":" 7.3 编写 do0 程序do0 程序的主要任务是显示字符串，这里特别需要注意字符串“overflow!”存放的位置，程序如下： text assume cs:code code segment start: mov ax, cs mov ds, ax mov si, offset do0 ; 设置 ds:si 指向源地址 mov ax, 0 mov es, ax mov di, 200h ; 设置 es:di 指向目的地址 mov cx, offset do0end-offset do0 ; 设置 cx 为传输长度 cld ; 设置传输方向为正 rep movsb ; TODO 设置中断向量表 mov ax, 4c00h int 21h do0: jmp short do0start db \"overflow!\" do0start: mov ax, cs mov ds, ax mov si, 202h ; 设置 ds:si 指向字符串 mov ax, 0b800h mov es, ax mov di, 12*160+36*2 ; 设置 es:di 指向显存空间的中间位置 mov cx, 9 ; 设置 cx 为字符串长度 s: mov al, [si] mov es:[di], al inc si add di, 2 loop s ; 循环将字符串写入显存 mov ax, 4c00h int 21h do0end: nop code ends end start 此处将“overflow!”存放到 do0 程序中，而不是存放到 data 段中，是因为如果存放到 data 段中，在执行完 start 代码后返回，它锁占用的内存空间会被系统释放，其中存放的“overflow!”信息也可能被别的信息覆盖，所以需要将字符串存放在一段不会被覆盖的空间中。此处的代码会随着代码段 do0 的转移，将字符串存入 0:202h 地址处（因为 0:200h 处的指令为 jmp short do0start，这条指令占两个字节，所以“overflow!”的偏移地址为 202h）。 ","date":"2023-11-13","objectID":"/posts/computer_architecture/assemply_language/assemply_language_12/:7:3","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 内中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_12/#编写-do0-程序"},{"categories":["计算机体系结构"],"content":" 7.4 设置中断向量下面，将 do0 的入口地址 0:200，写入中断向量表的 0 号表项中，使 do0 成为 0 号中断的中断处理程序。 0 号表项的地址为 0:0，其中 0:0 字单元存放偏移地址，0:2 字单元存放段地址。程序如下： text mov ax, 0 mov es, ax mov word ptr es:[0*4], 200h mov word ptr es:[0*4+2], 0 ","date":"2023-11-13","objectID":"/posts/computer_architecture/assemply_language/assemply_language_12/:7:4","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 内中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_12/#设置中断向量"},{"categories":["计算机体系结构"],"content":" 8 单步中断CPU 在执行完一条指令之后，如果检测到标志寄存器的 TF 位为 1，则产生单步中断，引发中断过程。单步中断的中断类型码为 1，则它所引发的中断过程如下： 取得中断类型码 1； 标志寄存器入栈，TF、IF 设置为 0； CS、IP 入栈； (IP)=(1x4), (CS)=(1x4+2)。 如果 TF=1，则执行一条指令后，CPU 就要转去执行 1 号中断处理程序。CPU 为什么要提供这样的功能呢？ CPU 提供单步中断功能的原因就是，为单步跟踪程序的执行过程，提供了实现机制。 在使用 Debug 的 t 命令的时候，Debug 如何能让 CPU 在执行一条指令后，就显示各个寄存器的状态？ Debug 利用了 CPU 提供的单步中断功能。首先，Debug 提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令。然后，在使用 t 命令执行指令时，Debug 将 TF 设置 1，使得CPU 工作于单步中断方式下，则在 CPU 执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器中的内容被显示在屏幕上，并且等待输入命令。 当 TF=1 时，CPU 在执行完一条指令后将引发单步中断，转去执行中断处理程序。注意，中断处理程序也是由一条条指令组成的，如果在执行中断处理程序之前，TF=1，则 CPU 在执行完中断处理程序的第一条指令后，又要产生单步中断，则又要转去执行单步中断的中断处理程序，在执行完中断处理程序的第一条指令后，又要产生单步中断，则又要转去执行单步中断的中断处理程序······ CPU 不能让这种情况发生，解决的办法就是，在进入中断处理程序之前，设置 TF=0。从而避免 CPU 在执行中断处理程序的时候发生单步中断。这就是为什么在中断过程中有 TF=0 这个步骤。 ","date":"2023-11-13","objectID":"/posts/computer_architecture/assemply_language/assemply_language_12/:8:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 内中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_12/#单步中断"},{"categories":["计算机体系结构"],"content":" 9 响应中断的特殊情况一般情况下，CPU 在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。可是，在有些情况下，CPU 在执行完当前指令后，即便是发生中断，也不会响应。 在执行完向 ss 寄存器传送数据的指令后，即便是发生中断，CPU 也不会响应。这样做的主要原因是，ss:sp 联合指向栈顶，而对它们的设置应该连续完成。如果在执行完设置 ss 的指令后，CPU 响应中断，引发中断过程，要在栈中压入标志寄存器、CS 和 IP 的值。而 ss 改变，sp 并未改变，ss:sp 指向的不是正确的栈顶，将引起错误。所以 CPU 在执行完设置 ss 的指令后，不响应中断。这给连续设置 ss 和 sp 指向正确的栈顶提供了一个时机。我们应该利用这个特性，将设置 ss 和 sp 的指令连续存放，使得设置 sp 的指令紧接着设置 ss 的指令执行，而在此之间，CPU 不会引发中断过程。 ","date":"2023-11-13","objectID":"/posts/computer_architecture/assemply_language/assemply_language_12/:9:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 内中断","uri":"/posts/computer_architecture/assemply_language/assemply_language_12/#响应中断的特殊情况"},{"categories":["计算机体系结构"],"content":"汇编语言 —— 标志寄存器","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/"},{"categories":["计算机体系结构"],"content":"CPU 内部的寄存器中，有一种特殊的寄存器(对于不同的处理机，个数和结构都可能不同)具有以下 3 种作用： 用来存储相关指令的某些执行结果； 用来为 CPU 执行相关指令提供行为依据； 用来控制 CPU 的相关工作方式。 8086CPU 的标志寄存器结构如下图： 8086CPU 的标志寄存器结构 ","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/:0:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/#"},{"categories":["计算机体系结构"],"content":" 1 ZF 标志flag 的第 6 位是 ZF，零标志位。它记录相关指令执行后，其结果是否为 0。如果结果为 0，那么 ZF=1；如果结果不为 0，那么 ZF=0。 示例 指令： text mov ax, 1 sub ax, 1 执行后，结果为 0，则 ZF=1。 指令： text mov ax, 2 sub ax, 1 执行后，结果不为 0，则 ZF=0。 技巧 在 8086CPU 的指令集中，有的指令的执行是影响标志寄存器的，比如：add、sub、mul、div、inc、or、and 等，它们大都是运算指令(进行逻辑或算术运算);有的指令的执行对标志寄存器没有影响，比如，mov、push、pop 等，它们大都是传送指令。 ","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/#zf-标志"},{"categories":["计算机体系结构"],"content":" 2 PF 标志Flag 的第 2 位是 PF，奇偶标志位。它记录相关指令执行后，其结果的所有 bit 位中 1 的个数是否为偶数。如果 1 的个数为偶数，PF=1，如果为奇数，那么 PF=0。 示例 指令： text mov al, 1 add al, 10 执行后，结果为 00001011B，其中有 3 个 1，则 PF=0。 指令： text mov al, 1 or al, 2 执行后，结果为 00000011B，其中有 2 个 1，则 PF=1。 ","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/:2:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/#pf-标志"},{"categories":["计算机体系结构"],"content":" 3 SF 标志Flag 的第 7 位是 SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果结果为负，SF=1；如果非负，SF=0。 SF 标志，是 CPU 对有符号数运算结果的一种记录，它记录数据的正负。如果我们将数据当作无符号数来运算，SF 的值则没有意义，虽然相关的指令影响了它的值。 示例 指令： text mov al, 10000001B add al, 1 执行后，结果为 10000010B，SF=1，表示：如果指令进行的是有符号数运算，那么结果为负。 指令： text mov al, 10000001B add al, 01111111B 执行后，结果为 0，SF=0，表示：如果指令进行的是有符号数运算，那么结果为非负。 ","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/:3:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/#sf-标志"},{"categories":["计算机体系结构"],"content":" 4 CF 标志Flag 的第 0 位是 CF，进位标志位。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。 对于位数为 N 的无符号数来说，其对应的二进制信息的最高位，即第 N-1 位，就是它的最高有效位，而假想存在的第 N 位，就是相对于最高有效位的更高位。 假想的更高位 当两个数据相加的时候， 有可能产生从最高有效位向更高位的进位。比如，两个 8 位数据：98H+98H，将产生进位。由于这个进位值在 8 位数中无法保存，CPU 在运算的时候记录在一个特殊的寄存器的某一位上，8086CPU 就用 Flag 的 CF 位来记录这个进位值。 示例 指令： text mov al, 98H add al, al ; 执行后: (al)=30H，CF=1，CF 记录了从最高有效位向更高位的进位值 add al, al ; 执行后: (al)=60H，CF=0，CF 记录了从最高有效位向更高位的进位值 当两个数据做减法的时候，有可能向更高位借位。比如，两个 8 位数据：97H-98H，将产生借位，借位后，相当于计算 197H-98H，Flag 的 CF 位也可以用来记录这个借位值。 示例 指令： text mov al, 97H sub al, 98H ; 执行后: (al)=FFH，CF=1，CF 记录了向更高位的借位值 sub al, al ; 执行后: (al)=0，CF=0，CF 记录了向更高位的借位值 ","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/:4:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/#cf-标志"},{"categories":["计算机体系结构"],"content":" 5 OF 标志在进行有符号数运算的时候，如结果超过了机器所能表示的范围称为溢出。 Flag 的第 11 位是 OF，溢出标志位。 一般情况下，OF 记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1；如果没有，OF=0。 一定要注意 CF 和 OF 的区别：CF 是对无符号数运算有意义的标志位，而 OF 是对有符号数运算有意义的标志位。 示例 指令： text mov al, 98 add al, 99 add 指令执行后：CF=0，OF=1。 CPU 在执行 add 等指令的时候，就包含了两种含义：无符号数运算和有符号数运算。对于无符号数运算，CPU 用 CF 位来记录是否产生了进位；对于有符号数运算，CPU 用 OF 位来记录是否产生了溢出。 ","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/:5:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/#of-标志"},{"categories":["计算机体系结构"],"content":" 6 ADC 指令adc 是带进位加法指令，它利用了 CF 位上记录的进位值。 比如指令adc ax, bx实现的功能是：(ax)=(ax)+(bx)+CF。 CPU 提供 adc 指令的目的，是来进行加法的第二步运算的。adc 指令和 add 指令相配合就可以对更大的数据进行加法运算。 在执行 adc 指令的时候加上的 CF 的值的含义，是由 adc 指令前面的指令决定的，也就是说，关键在于所加上的 CF 值是被什么指令设置的。显然，如果 CF 的值是被 sub 指令设置的，那么它的含义就是借位值；如果是被 add 指令设置的，那么它的含义就是进位值。 示例 编程，计算 1EF0001000FH+2010001EF0H，结果放在 ax（高16位），bx（次高16位），cx（低16位）中。 计算分 3 步进行： 先将低 16 位相加，完成后，CF 中记录本次相加的进位值; 再将次高 16 位和 CF(来自低 16 位的进位值)相加，完成后，CF 中记录本次相加的进位值; 最后高 16 位和 CF(来自次高 16 位的进位值)相加，完成后，CF 中记录本次相加的进位值。 程序如下： text mov ax, 001EH mov bx, 0F000H mov cx, 1000H add cx, 1EF0H adc bx, 1000H adc ax, 0020H ","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/:6:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/#adc-指令"},{"categories":["计算机体系结构"],"content":" 7 SBB 指令sbb 是带借位减法指令，它利用了 CF 位上记录的借位值。 比如指令sbb ax, bx实现的功能是：(ax)=(ax)-(bx)-CF。 sbb 指令执行后，将对 CF 进行设置。利用 sbb 指令可以对任意大的数据进行减法运算。 示例 计算 003E1000H-00202000H，结果放在 ax,bx 中。 程序如下： text mov bx, 1000H mov ax, 003ЕН sub bx, 2000H sbb ax, 0020H ","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/:7:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/#sbb-指令"},{"categories":["计算机体系结构"],"content":" 8 CMP 指令cmp 是比较指令，cmp 的功能相当于减法指令，只是不保存结果。cmp 指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。 比如，指令cmp ax, ax，做 (ax)-(ax) 的运算，结果为 0，但并不在 ax 中保存，仅影响 flag 的相关各位。指令执行后：ZF=1, PF=1, SF=0, CF=0, OF=0。 示例 CMP 指令——无符号数运算 我们通过 cmp 指令执行后，相关标志位的值就可以看出比较的结果。以 cmp ax, bx 为例： 如果 (ax)=(bx) 则 (ax)-(bx)=0，所以：ZF=1； 如果 (ax)!=(bx) 则 (ax)-(bx)!=0，所以：ZF=0； 如果 (ax)\u003c(bx) 则 (ax)-(bx) 将产生借位，所以：CF=1； 如果 (ax)≥(bx) 则 (ax)-(bx) 不必借位，所以：CF=0：如果 (ax)\u003e(bx) 则 (ax)-(bx) 既不必借位，结果又不为 0，所以：CF=0 并且 ZF=0； 如果 (ax)≤(bx) 则 (ax)-(bx)既可能借位，结果可能为 0，所以：CF=1 或 ZF=1。 CPU 在执行 cmp 指令的时候，也包含两种含义：进行无符号数运算和进行有符号数运算。所以利用 cmp 指令可以对无符号数进行比较，也可以对有符号数进行比较。 示例 CMP 指令——有符号数运算 我们通过 cmp 指令执行后，考查 SF (得知实际结果的正负)的同时考查 OF (得知有没有溢出)，就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果。以 cmp ah, bh 为例： 如果 SF=1，OF=0 OF=0，说明没有溢出，逻辑上真正结果的正负 == 实际结果的正负； 因 SF=1，实际结果为负，所以逻辑上真正的结果为负，所以(ah)\u003c(bh)。 如果 SF=1，OF=1 OF=1，说明有溢出，逻辑上真正结果的正负 != 实际结果的正负； 因 SF=1，实际结果为负。 实际结果为负，而又有溢出，这说明是由于溢出导致了实际结果为负，如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正。 因此，SF=1，OF=1，说明 (ah)=(bh)。 如果 SF=0，OF=1 OF=1，说明有溢出，逻辑上真正结果的正负 != 实际结果的正负； 因 SF=0，实际结果非负。而 OF=1 说明有溢出，则结果非 0，所以，实际结果为正。 实际结果为正，而又有溢出，这说明是由于溢出导致了实际结果非负，如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负。 因此，SF=0，OF=1，说明 (ah)\u003c(bh)。 如果 SF=0，而 OF=0 OF=0，说明没有溢出，逻辑上真正结果的正负 = 实际结果的正负； 因 SF=0，实际结果非负，所以逻辑上真正的结果非负，所以 (ah)≥(bh)。 ","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/:8:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/#cmp-指令"},{"categories":["计算机体系结构"],"content":" 9 检测比较结果的条件转移指令除了 jcxz 之外，CPU 还提供了其他条件转移指令，大多数条件转移指令都检测标志寄存器的相关标志位，根据检测的结果来决定是否修改 IP。检测的标志位就是被 cmp 指令影响的那些，表示比较结果的标志位。这些条件转移指令通常都和 cmp 相配合使用。 因为 cmp 指令可以同时进行两种比较，无符号数比较和有符号数比较，所以根据 cmp 指令的比较结果进行转移的指令也分为两种，即根据无符号数的比较结果进行转移的条件转移指令(它们检测 ZF、CF 的值)和根据有符号数的比较结果进行转移的条件转移指令(它们检测 SF、OF 和 ZF 的值)。 下面是常用的根据无符号数的比较结果进行转移的条件转移指令。 指令 含义 检测的相关标志位 je 等于则转移 ZF=1 jne 不等于则转移 ZF=0 jb 低于则转移 CF=1 jnb 不低于则转移 CF=0 ja 高于则转移 CF=0 且 ZF=0 jna 不高于则转移 CF=1 或 ZF=1 ","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/:9:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/#检测比较结果的条件转移指令"},{"categories":["计算机体系结构"],"content":" 10 DF 标志和串传送指令Flag 的第 10 位是 DF，方向标志位。在串处理指令中，控制每次操作后 si、di 的增减： DF=0 每次操作后 si、di 递增; DF=0 每次操作后 si、di 递减。 ","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/:10:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/#df-标志和串传送指令"},{"categories":["计算机体系结构"],"content":" 10.1 movsb 和 movsw 指令功能：执行 movsb 指令相当于进行下面几步操作： ((es)x16+(di))=((ds)x16+(si)) 如果 DF=0 则： (si)=(si)+1 (di)=(di)+1 如果 DF=1 则： (si)=(si)-1 (di)=(di)-1 可以看出，movsb 的功能是将 ds:si 指向的内存单元中的字节送入 es:di 中，然后根据标志寄存器 DF 位的值，将 si 和 di 递增或递减。 当然，也可以传送一个字，使用 movsw 指令。 movsw 的功能是将 ds:si 指向的内存字单元中的字送入 es:di 中，然后根据标志寄存器 df 位的值，将 si 和 di 递增 2 或递减 2。 ","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/:10:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/#movsb-和-movsw-指令"},{"categories":["计算机体系结构"],"content":" 10.2 rep 指令movsb 和 movsw 进行的是串传送操作中的一个步骤，一般来说，movsb 和 movsw 都和 rep 配合使用，格式为：rep movsb 或 rep movsw。 rep 的作用是根据 cx 的值，重复执行后面的串传送指令。由于每执行一次 movsb 指令 si 和 di 都会递增或递减指向后一个单元或前一个单元，则 rep movsb 就可以循环实现(cx)个字符的传送。 ","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/:10:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/#rep-指令"},{"categories":["计算机体系结构"],"content":" 10.3 cld 和 std 指令由于 flag 的 df 位决定着串传送指令执行后，si 和 di 改变的方向，所以 CPU 应该提供 相应的指令来对 df 位进行设置，从而使程序员能够决定传送的方向。 8086CPU 提供下面两条指令对 df 位进行设置： cld 指令：将标志寄存器的 df 位置 0； std 指令：将标志寄存器的 df 位置 1。 ","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/:10:3","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/#cld-和-std-指令"},{"categories":["计算机体系结构"],"content":" 10.4 串传送指令案例例题：编程，用串传送指令，将 data 段中的第一个字符串复制到它后面的空间中。 text data segment db 'Welcome to masm!' db 16 dup (0) data ends 技巧 我们分析一下，使用串传送指令进行数据的传送，需要给它提供一些必要的信息，它们是： 传送的原始位置：ds:si； 传送的目的位置：es:di； 传送的长度：cx； 传送的方向：df。 在这个问题中，这些信息如下： 传送的原始位置：data:0； 传送的目的位置：data:0010； 传送的长度： 16； 传送的方向：因为正向传送(每次串传送指令执行后，si 和 di 递增)比较方便，所以设置 DF=0。 明确上述信息后，编写程序： text mov ax, data mov ds, ax mov si, 0 ; ds:si 指向 data:0 mov es, ax mov di, 16 ; es:di 指向 data:0010 mov cx, 16 ; (cx)=16，rep 循环 16 次 cld ; 设置 DF=0，正向传送 rep movsb ","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/:10:4","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/#串传送指令案例"},{"categories":["计算机体系结构"],"content":" 11 PUSHF 和 POPFpushf 的功能是将标志寄存器的值压栈，而 popf 是从栈中弹出数据，送入标志寄存器中。pushf 和 popf，为直接访问标志寄存器提供了一种方法。 ","date":"2023-11-07","objectID":"/posts/computer_architecture/assemply_language/assemply_language_11/:11:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 标志寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_11/#pushf-和-popf"},{"categories":["系统设计"],"content":"记录使用 WinDBG 排查内存泄漏问题的过程。","date":"2023-10-31","objectID":"/posts/distributed_lock/distributed_lock_05/","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 内存泄漏问题排查","uri":"/posts/distributed_lock/distributed_lock_05/"},{"categories":["系统设计"],"content":" 1 内存泄漏现象在进行性能测试的过程中，发现分布式锁测试程序的内存一直在上涨。起初怀疑是续约线程阻塞未消费续约对象导致续约对象堆积从而使内存上涨，然而事实并没有这么简单。 分布式锁测试 —— 内存暴涨 怀疑分布式锁存在内存泄漏问题，于是获取程序内存 Dump，通过 WinDBG 分析内存问题。 ","date":"2023-10-31","objectID":"/posts/distributed_lock/distributed_lock_05/:1:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 内存泄漏问题排查","uri":"/posts/distributed_lock/distributed_lock_05/#内存泄漏现象"},{"categories":["系统设计"],"content":" 2 内存泄漏排查内存泄漏大部分是因为某些对象仍然存在指针指向它，从而未被垃圾回收器识别并清理。因此排查思路就是： 查找内存中占用内存最大、最多的对象； 排查该对象是否存在 gcroot 指向的路径。 首先使用 !dumpheap -stat 命令查看内存中占用最大或者最多的对象。 内存中占用最大或者最多的对象 可以看到占用内存最多的对象类型是 System.Object[] 类型。 其次使用命令 !DumpHeap /d -mt 000007fef6155e70 查看该类所有对象的地址、大小信息。 最后任意从上一步选择一个对象的地址，使用 !gcroot 0000000008355cc8 命令查看对象的 GC 指针信息。 对象 GC 指针引用信息 这里能够判断是 System.EventHandler 导致的内存泄漏问题。 ","date":"2023-10-31","objectID":"/posts/distributed_lock/distributed_lock_05/:2:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 内存泄漏问题排查","uri":"/posts/distributed_lock/distributed_lock_05/#内存泄漏排查"},{"categories":["系统设计"],"content":" 3 EventHandler 内存泄漏问题EventHandler 导致内存泄漏问题，是 .NET 中一个非常常见的问题。 原因很容易解释：当 EventHandler 被订阅时，事件的发布者通过 EventHandler 委托持有对订阅者的引用（假设委托是一个实例方法）。 如果发布者的生存时间比订阅者长，那么即使没有其他对订阅者的引用，它也会使订阅者保持被引用状态。 如果使用相同的处理程序取消订阅事件，这将删除处理程序和可能的泄漏。然而，这实际上很少是一个问题，因为通常发布者和订阅者无论如何都有大致相同的生命周期。 在这个问题上，由于事件发布者是一个单例，生命周期是整个程序运行时间，事件的订阅者是 DistributedLock 对象，因此发布者一直持有订阅者的引用，从而使得订阅者无法被垃圾回收，导致内存泄漏。 ","date":"2023-10-31","objectID":"/posts/distributed_lock/distributed_lock_05/:3:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 内存泄漏问题排查","uri":"/posts/distributed_lock/distributed_lock_05/#eventhandler-内存泄漏问题"},{"categories":["系统设计"],"content":" 4 参考资料Why and How to avoid Event Handler memory leaks? Are you afraid of event handlers because of C# memory leak? Fear not! ","date":"2023-10-31","objectID":"/posts/distributed_lock/distributed_lock_05/:4:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 内存泄漏问题排查","uri":"/posts/distributed_lock/distributed_lock_05/#参考资料"},{"categories":["中间件技术"],"content":"阅读 Redis 对象 redisObject 相关代码，了解 Redis 中对象的数据结构。","date":"2023-10-17","objectID":"/posts/redis_source_code/redis_source_code_08/","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 对象 (redisObject)","uri":"/posts/redis_source_code/redis_source_code_08/"},{"categories":["中间件技术"],"content":" 1 redisObject 结构体Redis 使用对象来表示数据库中的键和值，每当我们在Redis数据库中新创建一个键值对时，至少会创建两个对象，分别是键值对中的键对象和值对象。键对象总是一个字符串对象，而值对象，则根据使用而不同。而每个对象，在 Redis 中，都是由一个 redisObject（位于 server.h）的结构体来表示，也简称为 robj。 C struct redisObject { unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or * LFU data (least significant 8 bits frequency * and most significant 16 bits access time). */ int refcount; void *ptr; }; 一个 robj 对象包含 5 个字段： type：对象的数据类型，占 4 位，分别对应 Redis 对外暴露的数据类型：字符串、列表、集合、有序集合、哈希、模块、流 encoding：对象内部编码，占 4 位，表示对象的具体底层实现的数据结构 encoding，一个 type 可能会对应多种实现的 encoding，存在不同的内部表达方式，例如字符串对象可以有 embstr / int / raw 三种编码方式 lru：用于做 LRF / LFU 缓存淘汰的，占 24 位 refcount：对象的引用计数，占 4 字节，跟大部分编程语言里的引用计数概念是一致的，它允许一些对象是可以共享的。例如一些小整数就可以提前申明共用作为缓存池，而不用重复创建对象 ptr：指向底层实现数据结构的指针，占 8 字节，例如一个代表 list 的 robj，它的 ptr 可能指向一个 quicklist ","date":"2023-10-17","objectID":"/posts/redis_source_code/redis_source_code_08/:1:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 对象 (redisObject)","uri":"/posts/redis_source_code/redis_source_code_08/#redisobject-结构体"},{"categories":["中间件技术"],"content":" 1.1 创建对象 createObject初始化创建一个 robj，设置一些默认值。encoding 一般在调用方会再次修改这个属性为对应的编码值。 C robj *createObject(int type, void *ptr) { robj *o = zmalloc(sizeof(*o)); o-\u003etype = type; o-\u003eencoding = OBJ_ENCODING_RAW; o-\u003eptr = ptr; o-\u003erefcount = 1; o-\u003elru = 0; return o; } ","date":"2023-10-17","objectID":"/posts/redis_source_code/redis_source_code_08/:1:1","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 对象 (redisObject)","uri":"/posts/redis_source_code/redis_source_code_08/#创建对象-createobject"},{"categories":["中间件技术"],"content":" 1.2 设置 LRU 或者 LFU 策略 C void initObjectLRUOrLFU(robj *o) { // 如果是共享对象，不设置策略 if (o-\u003erefcount == OBJ_SHARED_REFCOUNT) return; /* Set the LRU to the current lruclock (minutes resolution), or * alternatively the LFU counter. */ // 根据 LRU 或者 LFU 策略设置 o-\u003elru 属性 if (server.maxmemory_policy \u0026 MAXMEMORY_FLAG_LFU) { o-\u003elru = (LFUGetTimeInMinutes() \u003c\u003c 8) | LFU_INIT_VAL; } else { o-\u003elru = LRU_CLOCK(); } return; } ","date":"2023-10-17","objectID":"/posts/redis_source_code/redis_source_code_08/:1:2","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 对象 (redisObject)","uri":"/posts/redis_source_code/redis_source_code_08/#设置-lru-或者-lfu-策略"},{"categories":["中间件技术"],"content":" 1.3 共享对象 makeObjectShared C /* Set a special refcount in the object to make it \"shared\": * incrRefCount and decrRefCount() will test for this special refcount * and will not touch the object. This way it is free to access shared * objects such as small integers from different threads without any * mutex. * * A common pattern to create shared objects: * * robj *myobject = makeObjectShared(createObject(...)); * */ robj *makeObjectShared(robj *o) { serverAssert(o-\u003erefcount == 1); o-\u003erefcount = OBJ_SHARED_REFCOUNT; return o; } ","date":"2023-10-17","objectID":"/posts/redis_source_code/redis_source_code_08/:1:3","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 对象 (redisObject)","uri":"/posts/redis_source_code/redis_source_code_08/#共享对象-makeobjectshared"},{"categories":["中间件技术"],"content":" 2 类型和编码","date":"2023-10-17","objectID":"/posts/redis_source_code/redis_source_code_08/:2:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 对象 (redisObject)","uri":"/posts/redis_source_code/redis_source_code_08/#类型和编码"},{"categories":["中间件技术"],"content":" 2.1 类型 C /* The actual Redis Object */ #define OBJ_STRING 0 /* String object. */ #define OBJ_LIST 1 /* List object. */ #define OBJ_SET 2 /* Set object. */ #define OBJ_ZSET 3 /* Sorted set object. */ #define OBJ_HASH 4 /* Hash object. */ /* The \"module\" object type is a special one that signals that the object * is one directly managed by a Redis module. In this case the value points * to a moduleValue struct, which contains the object value (which is only * handled by the module itself) and the RedisModuleType struct which lists * function pointers in order to serialize, deserialize, AOF-rewrite and * free the object. * * Inside the RDB file, module types are encoded as OBJ_MODULE followed * by a 64 bit module type ID, which has a 54 bits module-specific signature * in order to dispatch the loading to the right module, plus a 10 bits * encoding version. */ #define OBJ_MODULE 5 /* Module object. */ #define OBJ_STREAM 6 /* Stream object. */ #define OBJ_TYPE_MAX 7 /* Maximum number of object types */ ","date":"2023-10-17","objectID":"/posts/redis_source_code/redis_source_code_08/:2:1","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 对象 (redisObject)","uri":"/posts/redis_source_code/redis_source_code_08/#类型"},{"categories":["中间件技术"],"content":" 2.2 编码对象的 ptr 指针，指向了对象的底层实现数据结构，这些数据结构则由对象的 encoding 属性决定。encoding 数据记录了对象所使用的具体编码，或者说这个对象使用了什么数据结构作为底层实现。encoding 的值可以是下面列出的常量中的一个。 C /* Objects encoding. Some kind of objects like Strings and Hashes can be * internally represented in multiple ways. The 'encoding' field of the object * is set to one of this fields for this object. */ #define OBJ_ENCODING_RAW 0 /* Raw representation */ #define OBJ_ENCODING_INT 1 /* Encoded as integer */ #define OBJ_ENCODING_HT 2 /* Encoded as hash table */ #define OBJ_ENCODING_ZIPMAP 3 /* No longer used: old hash encoding. */ #define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. */ #define OBJ_ENCODING_ZIPLIST 5 /* No longer used: old list/hash/zset encoding. */ #define OBJ_ENCODING_INTSET 6 /* Encoded as intset */ #define OBJ_ENCODING_SKIPLIST 7 /* Encoded as skiplist */ #define OBJ_ENCODING_EMBSTR 8 /* Embedded sds string encoding */ #define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of listpacks */ #define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */ #define OBJ_ENCODING_LISTPACK 11 /* Encoded as a listpack */ ","date":"2023-10-17","objectID":"/posts/redis_source_code/redis_source_code_08/:2:2","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 对象 (redisObject)","uri":"/posts/redis_source_code/redis_source_code_08/#编码"},{"categories":["中间件技术"],"content":" 3 字符串对象字符串对象，编码可以是 embstr、int 和 raw 这三种中的一种。 ","date":"2023-10-17","objectID":"/posts/redis_source_code/redis_source_code_08/:3:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 对象 (redisObject)","uri":"/posts/redis_source_code/redis_source_code_08/#字符串对象"},{"categories":["中间件技术"],"content":" 3.1 编码过程针对一些字符串对象，Redis 在存储起来之前，会先经历一个编码过程，尝试将它编码转换为更节省内存的 encoding： 检查 type，确保只有 string 类型可以进来 检查 encoding，只会对 raw 和 embstr 进行操作 检查 refcount，因为如果引用计数器大于 1 的共享对象，在多处被引用，如果贸然进行编码，可能会改变 robj 对象指针，这对其他引用来说，是不安全的（要修改所有引用），所以不会对共享过的字符串对象进行编码 为了节省内存尝试进行各种 encoding 的转换 int：试图将字符串转 long 类型，如果能转返回 1，并且将转换后的值存储在 value 里。这里判断参与转换的字符串的长度是要 \u003c= 20，因为一个 long 能表示的范围是 -9223372036854775808 到 9223372036854775807，包含负号的话十进制表示需要 20 个字符 int 共享整数：对于 int 编码如果是小整数，例如现在默认 [0, 10000) 范围里如果能使用共享整数就会使用缓存池里的共享对象，节省这些对象的创建和销毁。不过只在 maxmemory != 0 并且没有使用 LRU / LFU 内存淘汰策略下才会使用共享整数，因为 LRU / LFU 需要记录对象的最后一次访问时间，这样就不能使用共享对象；而 maxmemory = 0 说明不限制内存使用，自然也无内存淘汰策略啥事了 embstr：例如携带非数字字符，不能使用 int 编码，如果字符串长度 \u003c= 44 就使用 embstr 编码字符串，前面有介绍过的 raw：最后没法子只能用 raw 编码，并且尝试回收 sds 空闲空间 C /* Try to encode a string object in order to save space */ robj *tryObjectEncodingEx(robj *o, int try_trim) { long value; sds s = o-\u003eptr; size_t len; /* Make sure this is a string object, the only type we encode * in this function. Other types use encoded memory efficient * representations but are handled by the commands implementing * the type. */ // 确保对象类型是字符串类型 serverAssertWithInfo(NULL,o,o-\u003etype == OBJ_STRING); /* We try some specialized encoding only for objects that are * RAW or EMBSTR encoded, in other words objects that are still * in represented by an actually array of chars. */ // 检查判断 encoding 是否为 RAW 或者 EMBSTR，int 编码的字符串不做处理 if (!sdsEncodedObject(o)) return o; /* It's not safe to encode shared objects: shared objects can be shared * everywhere in the \"object space\" of Redis and may end in places where * they are not handled. We handle them only as values in the keyspace. */ // 共享对象，不做处理 if (o-\u003erefcount \u003e 1) return o; /* Check if we can represent this string as a long integer. * Note that we are sure that a string larger than 20 chars is not * representable as a 32 nor 64 bit integer. */ len = sdslen(s); // 尝试将字符串转换为 long 类型，如果能够转换返回 1，并将转换的值存储在 value 里 if (len \u003c= 20 \u0026\u0026 string2l(s,len,\u0026value)) { /* This object is encodable as a long. Try to use a shared object. * Note that we avoid using shared integers when maxmemory is used * because every object needs to have a private LRU field for the LRU * algorithm to work well. */ // 如果没开启 maxmemory，或者缓存淘汰策略没有使用 LRU/LFU // 且 value 值在 [0, OBJ_SHARED_INTEGERS) 之间 // 使用 Redis 的小整数缓存，节约内存空间 if ((server.maxmemory == 0 || !(server.maxmemory_policy \u0026 MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) \u0026\u0026 value \u003e= 0 \u0026\u0026 value \u003c OBJ_SHARED_INTEGERS) { decrRefCount(o); return shared.integers[value]; } else { // 无法使用共享对象 if (o-\u003eencoding == OBJ_ENCODING_RAW) { // 编码为 RAW，释放原本的 sds，赋值 ptr，转换编码为 int sdsfree(o-\u003eptr); o-\u003eencoding = OBJ_ENCODING_INT; o-\u003eptr = (void*) value; return o; } else if (o-\u003eencoding == OBJ_ENCODING_EMBSTR) { // 编码为 EMBSTR，减少 o 的引用计数 // 因为 EMBSTR 编码 robj 和 sds 内存是连续的 // RAW 编码格式可以直接释放 sds 赋值 ptr // EMBSTR 只能调用方法重新根据整数创建字符串对象 robj decrRefCount(o); return createStringObjectFromLongLongForValue(value); } } } /* If the string is small and is still RAW encoded, * try the EMBSTR encoding which is more efficient. * In this representation the object and the SDS string are allocated * in the same chunk of memory to save space and cache misses. */ // 如果 len \u003c= 44 且 encoding 为 RAW，将它转为 EMBSTR if (len \u003c= OBJ_ENCODING_EMBSTR_SIZE_LIMIT) { robj *emb; if (o-\u003eencoding == OBJ_ENCODING_EMBSTR) return o; // 创建 EMBSTR 字符串对象，释放原本的 o 对象 emb = createEmbeddedStringObject(s,sdslen(s)); decrRefCount(o); return emb; } /* We can't encode the object... * Do the last try, and at least optimize the SDS string inside */ if (try_trim) // 尝试缩减 sds 里的空闲空间来节约内存 trimStringObjectIfNeeded(o, 0); /* Return the original object. */ return o; } ","date":"2023-10-17","objectID":"/posts/redis_source_code/redis_source_code_08/:3:1","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 对象 (redisObject)","uri":"/posts/redis_source_code/redis_source_code_08/#编码过程"},{"categories":["中间件技术"],"content":" 3.2 createEmbeddedStringObject如果字符串长度 \u003c= 44，会调用这个方法，用于生成更节省空间的字符串对象。 C ","date":"2023-10-17","objectID":"/posts/redis_source_code/redis_source_code_08/:3:2","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 对象 (redisObject)","uri":"/posts/redis_source_code/redis_source_code_08/#createembeddedstringobject"},{"categories":["中间件技术"],"content":"阅读 Redis 整数集合 intset 相关代码，了解 Redis 中整数集合的实现。","date":"2023-10-12","objectID":"/posts/redis_source_code/redis_source_code_07/","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 整数集合 (intset)","uri":"/posts/redis_source_code/redis_source_code_07/"},{"categories":["中间件技术"],"content":"在 Redis 7.2 以前， set 数据类型底层实现的数据结构为 intset 或者 hashtable。Redis 7.2 中给 set 增加了 listpack 编码方式。当 set 中的元素都是整数并且元素数目较少的时候，会使用 intset 作为底层实现，否则会使用 hashtable 或者 listpack 来作为底层实现。 intset 是 Redis 用来保存整数值的集合抽象数据结构，它可以保存类型为 int16_t、int32_t 或者 int64_t 的整数值（设置多个类型来节省内存，当整数元素超过编码范围区间时，会进行类型升级扩容，此时升级的时间复杂度为 O(N) ），并且保证集合中不会出现重复元素。各个元素在 intset 里是按照从小到大的有序的存储（里面的搜索是用的二分查找，时间复杂度为 O(log N)），并且不包含重复值。 ","date":"2023-10-12","objectID":"/posts/redis_source_code/redis_source_code_07/:0:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 整数集合 (intset)","uri":"/posts/redis_source_code/redis_source_code_07/#"},{"categories":["中间件技术"],"content":" 1 intset 结构体定义intset 包含两部分，header 元数据（encoding、length）和实际的整数数组。 C #define INTSET_ENC_INT16 (sizeof(int16_t)) #define INTSET_ENC_INT32 (sizeof(int32_t)) #define INTSET_ENC_INT64 (sizeof(int64_t)) typedef struct intset { uint32_t encoding; // 数据编码，表示 intset 每个整数用几个字节来编码存储 uint32_t length; // 元素个数，即 contents 数组长度 int8_t contents[]; // 柔性数组，存放实际数据，数据项不重复，且升序排序 } intset; ","date":"2023-10-12","objectID":"/posts/redis_source_code/redis_source_code_07/:1:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 整数集合 (intset)","uri":"/posts/redis_source_code/redis_source_code_07/#intset-结构体定义"},{"categories":["中间件技术"],"content":" 2 intset 编码升级Redis 中 intset 是可以存储三种类型的整数，在小的时候都是用小的编码，当插入新元素比较过 intset 的 encoding 后，发现插入元素类型更大时，就会去进行整个 intset 结构的升级。即将 contents 里面的所有元素，类型都从小类型升级为大类型。 intset 不支持降级。 ","date":"2023-10-12","objectID":"/posts/redis_source_code/redis_source_code_07/:2:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 整数集合 (intset)","uri":"/posts/redis_source_code/redis_source_code_07/#intset-编码升级"},{"categories":["中间件技术"],"content":" 3 源码","date":"2023-10-12","objectID":"/posts/redis_source_code/redis_source_code_07/:3:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 整数集合 (intset)","uri":"/posts/redis_source_code/redis_source_code_07/#源码"},{"categories":["中间件技术"],"content":" 3.1 intsetSearch 查找元素 C /* Search for the position of \"value\". Return 1 when the value was found and * sets \"pos\" to the position of the value within the intset. Return 0 when * the value is not present in the intset and sets \"pos\" to the position * where \"value\" can be inserted. */ // 搜索指定值 value 在 intset 中的位置 // 找到则返回 1，并设置 pos 值为指定位置下标 // 否则返回 0，并设置 pos 值为可插入位置 static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) { int min = 0, max = intrev32ifbe(is-\u003elength)-1, mid = -1; int64_t cur = -1; /* The value can never be found when the set is empty */ if (intrev32ifbe(is-\u003elength) == 0) { if (pos) *pos = 0; return 0; } else { /* Check for the case where we know we cannot find the value, * but do know the insert position. */ // 根据 intset 最大值和最小值，快速判断元素是否存在 if (value \u003e _intsetGet(is,max)) { if (pos) *pos = intrev32ifbe(is-\u003elength); return 0; } else if (value \u003c _intsetGet(is,0)) { if (pos) *pos = 0; return 0; } } // 二分查找 while(max \u003e= min) { mid = ((unsigned int)min + (unsigned int)max) \u003e\u003e 1; cur = _intsetGet(is,mid); if (value \u003e cur) { min = mid+1; } else if (value \u003c cur) { max = mid-1; } else { break; } } if (value == cur) { // 如果找到了，设置 pos 指针，返回 1 if (pos) *pos = mid; return 1; } else { // 没找到，设置 pos 指针为可插入位置，返回 0 if (pos) *pos = min; return 0; } } ","date":"2023-10-12","objectID":"/posts/redis_source_code/redis_source_code_07/:3:1","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 整数集合 (intset)","uri":"/posts/redis_source_code/redis_source_code_07/#intsetsearch-查找元素"},{"categories":["中间件技术"],"content":" 3.2 intsetAdd 添加元素 C /* Insert an integer in the intset */ intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 1; /* Upgrade encoding if necessary. If we need to upgrade, we know that * this value should be either appended (if \u003e 0) or prepended (if \u003c 0), * because it lies outside the range of existing values. */ // 如果 intset 需要进行编码升级，调用 intsetUpgradeAndAdd 方法 if (valenc \u003e intrev32ifbe(is-\u003eencoding)) { /* This always succeeds, so we don't need to curry *success. */ return intsetUpgradeAndAdd(is,value); } else { /* Abort if the value is already present in the set. * This call will populate \"pos\" with the right position to insert * the value when it cannot be found. */ // 如果查找到该元素，元素已存在，插入失败 if (intsetSearch(is,value,\u0026pos)) { if (success) *success = 0; return is; } // 进行插入，对 intset 扩容 is = intsetResize(is,intrev32ifbe(is-\u003elength)+1); // 如果 pos == is-\u003elength 就不用进行内存移动，直接在数组最后插入 if (pos \u003c intrev32ifbe(is-\u003elength)) intsetMoveTail(is,pos,pos+1); } // 在 pos 下标插入 value 元素，is-\u003econtents[pos] = value，并且维护 is-\u003elength 长度 _intsetSet(is,pos,value); is-\u003elength = intrev32ifbe(intrev32ifbe(is-\u003elength)+1); return is; } ","date":"2023-10-12","objectID":"/posts/redis_source_code/redis_source_code_07/:3:2","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 整数集合 (intset)","uri":"/posts/redis_source_code/redis_source_code_07/#intsetadd-添加元素"},{"categories":["中间件技术"],"content":" 3.3 intsetUpgradeAndAdd 升级并添加元素 C /* Upgrades the intset to a larger encoding and inserts the given integer. */ static intset *intsetUpgradeAndAdd(intset *is, int64_t value) { uint8_t curenc = intrev32ifbe(is-\u003eencoding); uint8_t newenc = _intsetValueEncoding(value); int length = intrev32ifbe(is-\u003elength); int prepend = value \u003c 0 ? 1 : 0; /* First set new encoding and resize */ is-\u003eencoding = intrev32ifbe(newenc); is = intsetResize(is,intrev32ifbe(is-\u003elength)+1); /* Upgrade back-to-front so we don't overwrite values. * Note that the \"prepend\" variable is used to make sure we have an empty * space at either the beginning or the end of the intset. */ while(length--) _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc)); /* Set the value at the beginning or the end. */ if (prepend) _intsetSet(is,0,value); else _intsetSet(is,intrev32ifbe(is-\u003elength),value); is-\u003elength = intrev32ifbe(intrev32ifbe(is-\u003elength)+1); return is; } ","date":"2023-10-12","objectID":"/posts/redis_source_code/redis_source_code_07/:3:3","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 整数集合 (intset)","uri":"/posts/redis_source_code/redis_source_code_07/#intsetupgradeandadd-升级并添加元素"},{"categories":["中间件技术"],"content":" 3.4 intsetMoveTail 移动元素intsetMoveTail 方法将 from 对应位置往后的元素，移动到 to 位置。 C static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) { void *src, *dst; // is-\u003elength - from 算出这个位置往后有多少个元素，即要移动的元素个数 uint32_t bytes = intrev32ifbe(is-\u003elength)-from; // 获取当前的编码 uint32_t encoding = intrev32ifbe(is-\u003eencoding); if (encoding == INTSET_ENC_INT64) { // 获取 from 的起始地址，即移动范围的初始地址 src = (int64_t*)is-\u003econtents+from; // 获取 to 的起始地址，即需要移动到的目的地初始地址 dst = (int64_t*)is-\u003econtents+to; // 元素个数 * 元素大小，计算要移动的总字节数 bytes *= sizeof(int64_t); } else if (encoding == INTSET_ENC_INT32) { src = (int32_t*)is-\u003econtents+from; dst = (int32_t*)is-\u003econtents+to; bytes *= sizeof(int32_t); } else { src = (int16_t*)is-\u003econtents+from; dst = (int16_t*)is-\u003econtents+to; bytes *= sizeof(int16_t); } // 将 src 位置往后 bytes 个字节，移动到 dst 位置 memmove(dst,src,bytes); } ","date":"2023-10-12","objectID":"/posts/redis_source_code/redis_source_code_07/:3:4","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 整数集合 (intset)","uri":"/posts/redis_source_code/redis_source_code_07/#intsetmovetail-移动元素"},{"categories":["中间件技术"],"content":" 3.5 intsetRemove 删除元素 C /* Delete integer from intset */ intset *intsetRemove(intset *is, int64_t value, int *success) { // 获取 value 类型 uint8_t valenc = _intsetValueEncoding(value); uint32_t pos; if (success) *success = 0; // 如果删除整数的类型 \u003e 当前编码类型，不存在 // 二分查找判断元素是否存在，存在才进行删除，否则直接返回 if (valenc \u003c= intrev32ifbe(is-\u003eencoding) \u0026\u0026 intsetSearch(is,value,\u0026pos)) { uint32_t len = intrev32ifbe(is-\u003elength); /* We know we can delete */ if (success) *success = 1; /* Overwrite value with tail and update length */ // 如果 pos 插入位置小雨 intset 长度，即在中间删除 // 调用 intsetMoveTail 函数，将 pos+1 位置开始的元素，移动到 pos 的位置上 if (pos \u003c (len-1)) intsetMoveTail(is,pos+1,pos); // 覆盖后，删除了目标元素，对 intset 进行缩容，并更新 intset 长度 is = intsetResize(is,len-1); is-\u003elength = intrev32ifbe(len-1); } return is; } ","date":"2023-10-12","objectID":"/posts/redis_source_code/redis_source_code_07/:3:5","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 整数集合 (intset)","uri":"/posts/redis_source_code/redis_source_code_07/#intsetremove-删除元素"},{"categories":["计算机体系结构"],"content":"汇编语言 —— CALL和RET指令","date":"2023-09-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_10/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— CALL和RET指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_10/"},{"categories":["计算机体系结构"],"content":"call 和 ret 指令都是转移指令，它们都修改 IP，或同时修改CS 和 IP。它们经常被共同用来实现子程序的设计。 ","date":"2023-09-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_10/:0:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— CALL和RET指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_10/#"},{"categories":["计算机体系结构"],"content":" 1 ret 和 retfret 指令用栈中的数据，修改 IP 的内容，从而实现近转移； retf 指令用栈中的数据，修改 CS 和 IP 的内容，从而实现远转移。 技巧 CPU 执行 ret 指令时，相当于进行： text pop IP CPU 执行 retf 指令时，相当于进行： text pop IP pop CS ","date":"2023-09-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_10/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— CALL和RET指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_10/#ret-和-retf"},{"categories":["计算机体系结构"],"content":" 2 call 指令CPU 执行 call 指令时，进行两步操作: 将当前的 IP 或 CS和IP 压入栈中； 转移。 ","date":"2023-09-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_10/:2:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— CALL和RET指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_10/#call-指令"},{"categories":["计算机体系结构"],"content":" 2.1 依据位移进行转移的 call 指令格式：call 标号 (将当前的 IP 压栈后，转到标号处执行指令) 位移 = 标号处的地址 - call指令后的第一个字节的地址，由编译程序在编译时算出。 技巧 CPU 执行 “call 标号” 指令时，相当于进行： text push IP jmp near ptr 标号 ","date":"2023-09-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_10/:2:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— CALL和RET指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_10/#依据位移进行转移的-call-指令"},{"categories":["计算机体系结构"],"content":" 2.2 转移的目的地址在指令中的 call 指令格式：call far ptr 标号 技巧 CPU 执行 “call far ptr 标号” 指令时，相当于进行： text push CS push IP jmp far ptr 标号 ","date":"2023-09-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_10/:2:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— CALL和RET指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_10/#转移的目的地址在指令中的-call-指令"},{"categories":["计算机体系结构"],"content":" 2.3 转移地址在寄存器中的 call 指令格式：call 16位reg 技巧 CPU 执行 “call 16位reg” 指令时，相当于进行： text push IP jmp 16位reg ","date":"2023-09-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_10/:2:3","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— CALL和RET指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_10/#转移地址在寄存器中的-call-指令"},{"categories":["计算机体系结构"],"content":" 2.4 转移地址在内存中的 call 指令格式： call word ptr 内存单元地址 call dword ptr 内存单元地址 技巧 CPU 执行 “call word ptr 内存单元地址” 指令时，相当于进行： text push IP jmp word ptr 内存单元地址 CPU 执行 “call dword ptr 内存单元地址” 指令时，相当于进行： text push CS push IP jmp dword ptr 内存单元地址 ","date":"2023-09-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_10/:2:4","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— CALL和RET指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_10/#转移地址在内存中的-call-指令"},{"categories":["计算机体系结构"],"content":" 3 call 和 ret 的配合使用可以利用 call 和 ret 来实现子程序的机制。子程序的框架如下： text assume cs:code code segment main: ... call sub1 ; 调用子程序 sub1 ... ... mov ax, 4c00H int 21H sub1: ; 子程序 sub1 开始 ... call sub2 ; 调用子程序 sub2 ... ... ret ; 子程序 sub1 返回 sub2: ; 子程序 sub2 开始 ... ... ret ; 子程序 sub2 返回 code ends end main ","date":"2023-09-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_10/:3:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— CALL和RET指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_10/#call-和-ret-的配合使用"},{"categories":["计算机体系结构"],"content":" 4 mul 指令格式：mul reg 或 mul 内存单元 8位乘法：两个乘数一个默认在 AL 中，另一个放在 8 位 reg 或内存字节单元中，结果默认放在 AX 中； 16位乘法：两个乘数一个默认在 AX 中，另一个放在 16 位 reg 或内存字单元中，结果高位默认在 DX 中存放，低位在 AX 中存放。 ","date":"2023-09-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_10/:4:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— CALL和RET指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_10/#mul-指令"},{"categories":["计算机体系结构"],"content":" 5 子程序设计中的相关问题和解决方法","date":"2023-09-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_10/:5:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— CALL和RET指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_10/#子程序设计中的相关问题和解决方法"},{"categories":["计算机体系结构"],"content":" 5.1 参数和结果传递的问题此处讨论的问题是：应该如何存储子程序需要的参数和产生的返回值？ 用寄存器来存储参数和结果是最常使用的方法，对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作恰恰相反： 调用者将参数送入参数寄存器，从结果寄存器中取到返回值； 子程序从参数寄存器中取到参数，将返回值送入结果寄存器。 示例 编程，计算 data 段中第一组数据的 3 次方，结果保存在后面一组 dword 单元中。 text assume cs:code data segment dw 1,2,3,4,5,6,7,8 dd 0,0,0,0,0,0,0,0 data ends code segment start: mov ax, data mov ds, ax mov si, 0 ; ds:si 指向第一组 word 单元 mov di, 16 ; ds:di 指向第二组 dword 单元 mov cx, 8 s: mov bx, [si] ; 将子程序 cube 参数存入 bx 中 call cube mov [di], ax ; 取出 ax 中的值 mov [di].2, dx ; 取出 dx 中的值 add si, 2 ; ds:si 指向下一个 word 单元 add di, 4 ; ds:di 指向下一个 dword 单元 loop s mov ax, 4c00h int 21h cube: mov ax, bx mul bx mul bx ret ; 计算结果存放在 dx 和 ax 中 code ends end start ","date":"2023-09-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_10/:5:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— CALL和RET指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_10/#参数和结果传递的问题"},{"categories":["计算机体系结构"],"content":" 5.2 批量数据的传递 5.2.1 使用内存空间传递参数前面的例程中，子程序 cube 只有一个参数，放在 bx 中。如果有两个参数，那么可以用两个寄存器来放，可是如果需要传递的数据有 N 个，该怎样存放呢？ 在这种时候，我们将批量数据放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。 示例 编程，设计一个子程序，将一个全是字母的字符串转化为大写。 这个子程序需要知道两件事，字符串的内容和字符串的长度。 由于字符串中的字母可能很多，不便将整个字符串中的所有字母传递给子程序，我们可以将字符串在内存中的首地址存放在寄存器中传递给子程序。 因为子程序中需要循环，循环的次数是字符串的长度，我们可以将字符串的长度放到 cx 中传递给子程序。 text assume cs:code data segment db 'conversation' data ends code segment start: mov ax, data mov ds, ax mov si, 0 ; ds:si 指向数据所在空间首地址 mov cx, 12 ; cx 存放字符串长度 call capital mov ax, 4c00h int 21h capital: and byte ptr [si], 11011111b inc si loop capital ret code ends end start 5.2.2 使用栈传递参数除了用寄存器传递参数外，还有一种通用的方法是用栈来传递参数。 这种技术和高级语言编译器的工作原理密切相关。用栈传递参数的原理十分简单，就是由调用者将需要传递给子程序的参数压入栈中，子程序从栈中取得参数。 示例 编程，编写一个子程序，计算 (a-b)^3，a、b 为字型数据。 因为用栈传递参数，所以调用者在调用程序的时候要向栈中压入参数，子程序在返回的时候可以用 ret n 指令将栈顶指针修改为调用前的值。 text main: mov ax, 1 push ax ; 压入 b mov ax, 3 push ax ; 压入 a call cube ; 压入 IP，调用 cube 子程序 mov ax, 4c00h int 21h cube: push bp ; 栈中暂存 bp 的值 mov bp, sp ; 子程序中使用 bp 作为栈顶指针 mov ax, [bp+4] ; 栈中 a 的值送入 ax sub ax, [bp+6] ; 减栈中 b 的值 mov bp, ax mul bp mul bp pop bp ; 还原 bp 值 ret 4 ; 调用子程序前压入了两个参数，所以用 ret 4 返回 技巧 指令 “ret n” 的含义用汇编语法描述为： text pop ip add sp, n 既然用栈传递参数和高级语言编译器的工作原理密切相关，我们通过一个 C 语言程序编译后的汇编语言程序，看一下栈在参数传递中的应用。 信息 注意：在 C 语言中，局部变量也在栈中存储。 C void add(int, int, int); main() { int a = 1; int b = 2; int c = 0; add(a, b, c); c++; } void add(int a, int b, int c) { c = a + b; } 编译后的汇编程序 text main: mov bp, sp sub sp, 6 mov word ptr [bp-6], 0001 ; int a = 1 mov word ptr [bp-4], 0002 ; int b = 2 mov word prt [bp-2], 0003 ; int c = 0 push [bp-2] push [bp-4] push [bp-6] ; 传入参数 call add add: push bp mov bp, sp mov ax, [bp+4] add ax, [bp+6] ; 计算 a + b mov [bp+8], ax ; c = a + b mov sp, bp pop bp ret 6 可以观察到，子程序并未改变主程序中的 c 局部变量的值。 ","date":"2023-09-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_10/:5:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— CALL和RET指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_10/#批量数据的传递"},{"categories":["计算机体系结构"],"content":" 5.2 批量数据的传递 5.2.1 使用内存空间传递参数前面的例程中，子程序 cube 只有一个参数，放在 bx 中。如果有两个参数，那么可以用两个寄存器来放，可是如果需要传递的数据有 N 个，该怎样存放呢？ 在这种时候，我们将批量数据放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。 示例 编程，设计一个子程序，将一个全是字母的字符串转化为大写。 这个子程序需要知道两件事，字符串的内容和字符串的长度。 由于字符串中的字母可能很多，不便将整个字符串中的所有字母传递给子程序，我们可以将字符串在内存中的首地址存放在寄存器中传递给子程序。 因为子程序中需要循环，循环的次数是字符串的长度，我们可以将字符串的长度放到 cx 中传递给子程序。 text assume cs:code data segment db 'conversation' data ends code segment start: mov ax, data mov ds, ax mov si, 0 ; ds:si 指向数据所在空间首地址 mov cx, 12 ; cx 存放字符串长度 call capital mov ax, 4c00h int 21h capital: and byte ptr [si], 11011111b inc si loop capital ret code ends end start 5.2.2 使用栈传递参数除了用寄存器传递参数外，还有一种通用的方法是用栈来传递参数。 这种技术和高级语言编译器的工作原理密切相关。用栈传递参数的原理十分简单，就是由调用者将需要传递给子程序的参数压入栈中，子程序从栈中取得参数。 示例 编程，编写一个子程序，计算 (a-b)^3，a、b 为字型数据。 因为用栈传递参数，所以调用者在调用程序的时候要向栈中压入参数，子程序在返回的时候可以用 ret n 指令将栈顶指针修改为调用前的值。 text main: mov ax, 1 push ax ; 压入 b mov ax, 3 push ax ; 压入 a call cube ; 压入 IP，调用 cube 子程序 mov ax, 4c00h int 21h cube: push bp ; 栈中暂存 bp 的值 mov bp, sp ; 子程序中使用 bp 作为栈顶指针 mov ax, [bp+4] ; 栈中 a 的值送入 ax sub ax, [bp+6] ; 减栈中 b 的值 mov bp, ax mul bp mul bp pop bp ; 还原 bp 值 ret 4 ; 调用子程序前压入了两个参数，所以用 ret 4 返回 技巧 指令 “ret n” 的含义用汇编语法描述为： text pop ip add sp, n 既然用栈传递参数和高级语言编译器的工作原理密切相关，我们通过一个 C 语言程序编译后的汇编语言程序，看一下栈在参数传递中的应用。 信息 注意：在 C 语言中，局部变量也在栈中存储。 C void add(int, int, int); main() { int a = 1; int b = 2; int c = 0; add(a, b, c); c++; } void add(int a, int b, int c) { c = a + b; } 编译后的汇编程序 text main: mov bp, sp sub sp, 6 mov word ptr [bp-6], 0001 ; int a = 1 mov word ptr [bp-4], 0002 ; int b = 2 mov word prt [bp-2], 0003 ; int c = 0 push [bp-2] push [bp-4] push [bp-6] ; 传入参数 call add add: push bp mov bp, sp mov ax, [bp+4] add ax, [bp+6] ; 计算 a + b mov [bp+8], ax ; c = a + b mov sp, bp pop bp ret 6 可以观察到，子程序并未改变主程序中的 c 局部变量的值。 ","date":"2023-09-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_10/:5:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— CALL和RET指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_10/#使用内存空间传递参数"},{"categories":["计算机体系结构"],"content":" 5.2 批量数据的传递 5.2.1 使用内存空间传递参数前面的例程中，子程序 cube 只有一个参数，放在 bx 中。如果有两个参数，那么可以用两个寄存器来放，可是如果需要传递的数据有 N 个，该怎样存放呢？ 在这种时候，我们将批量数据放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。 示例 编程，设计一个子程序，将一个全是字母的字符串转化为大写。 这个子程序需要知道两件事，字符串的内容和字符串的长度。 由于字符串中的字母可能很多，不便将整个字符串中的所有字母传递给子程序，我们可以将字符串在内存中的首地址存放在寄存器中传递给子程序。 因为子程序中需要循环，循环的次数是字符串的长度，我们可以将字符串的长度放到 cx 中传递给子程序。 text assume cs:code data segment db 'conversation' data ends code segment start: mov ax, data mov ds, ax mov si, 0 ; ds:si 指向数据所在空间首地址 mov cx, 12 ; cx 存放字符串长度 call capital mov ax, 4c00h int 21h capital: and byte ptr [si], 11011111b inc si loop capital ret code ends end start 5.2.2 使用栈传递参数除了用寄存器传递参数外，还有一种通用的方法是用栈来传递参数。 这种技术和高级语言编译器的工作原理密切相关。用栈传递参数的原理十分简单，就是由调用者将需要传递给子程序的参数压入栈中，子程序从栈中取得参数。 示例 编程，编写一个子程序，计算 (a-b)^3，a、b 为字型数据。 因为用栈传递参数，所以调用者在调用程序的时候要向栈中压入参数，子程序在返回的时候可以用 ret n 指令将栈顶指针修改为调用前的值。 text main: mov ax, 1 push ax ; 压入 b mov ax, 3 push ax ; 压入 a call cube ; 压入 IP，调用 cube 子程序 mov ax, 4c00h int 21h cube: push bp ; 栈中暂存 bp 的值 mov bp, sp ; 子程序中使用 bp 作为栈顶指针 mov ax, [bp+4] ; 栈中 a 的值送入 ax sub ax, [bp+6] ; 减栈中 b 的值 mov bp, ax mul bp mul bp pop bp ; 还原 bp 值 ret 4 ; 调用子程序前压入了两个参数，所以用 ret 4 返回 技巧 指令 “ret n” 的含义用汇编语法描述为： text pop ip add sp, n 既然用栈传递参数和高级语言编译器的工作原理密切相关，我们通过一个 C 语言程序编译后的汇编语言程序，看一下栈在参数传递中的应用。 信息 注意：在 C 语言中，局部变量也在栈中存储。 C void add(int, int, int); main() { int a = 1; int b = 2; int c = 0; add(a, b, c); c++; } void add(int a, int b, int c) { c = a + b; } 编译后的汇编程序 text main: mov bp, sp sub sp, 6 mov word ptr [bp-6], 0001 ; int a = 1 mov word ptr [bp-4], 0002 ; int b = 2 mov word prt [bp-2], 0003 ; int c = 0 push [bp-2] push [bp-4] push [bp-6] ; 传入参数 call add add: push bp mov bp, sp mov ax, [bp+4] add ax, [bp+6] ; 计算 a + b mov [bp+8], ax ; c = a + b mov sp, bp pop bp ret 6 可以观察到，子程序并未改变主程序中的 c 局部变量的值。 ","date":"2023-09-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_10/:5:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— CALL和RET指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_10/#使用栈传递参数"},{"categories":["计算机体系结构"],"content":" 5.3 寄存器冲突的问题子程序中使用的寄存器，很可能在主程序中也要使用，造成了寄存器使用上的冲突。那么如何来避免这种冲突呢？ 解决这个问题的简洁方法是，在子程序的开始将子程序中所有用到的寄存器中的内容都保存起来，在子程序返回前再恢复。可以用栈来保存寄存器中的内容。 以后我们编写子程序的标准框架如下： text 子程序开始： 子程序中使用的寄存器入栈 子程序内容 子程序中使用的寄存器出栈 返回（ret、retf） 示例 编程，将 data 段中的字符串全部转化为大写。 程序要处理的字符串以 0 作为结尾符，子程序可以一次读取每个字符串进行检测，如果不是 0，就进行大写转化；如果是 0，就结束处理。由于可通过检测 0 而知道是否已经处理完字符串，所以子程序可以不需要字符串的长度作为参数。可以用 jcxz 来检测 0。 text assume cs:code data segment db 'word', 0 db 'unix', 0 db 'wind', 0 db 'good', 0 data ends code segment start: mov ax, data mov ds, ax mov bx, 0 ; ds:bx 指向每个字符串首地址 mov cx, 4 s: mov si, bx ; ds:si 指向单个字符 call capital add bx, 5 loop s mov ax, 4c00h int 21h capital: push cx ; 子程序中使用的寄存器入栈 push si change: ; 子程序内容 mov cl, [si] mov ch, 0 jcxz ok and byte ptr [si], 11011111b inc si jmp short change ok: pop si ; 子程序中使用的寄存器出栈 pop cx ; 注意寄存器入栈和出栈的顺序 ret ","date":"2023-09-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_10/:5:3","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— CALL和RET指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_10/#寄存器冲突的问题"},{"categories":["计算机体系结构"],"content":"汇编语言 —— 转移指令的原理","date":"2023-09-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_09/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 转移指令的原理","uri":"/posts/computer_architecture/assemply_language/assemply_language_09/"},{"categories":["计算机体系结构"],"content":"可以修改 IP，或同时修改 CS 和 IP 的指令统称为转移指令。 8086CPU 的转移行为有以下几类。 只修改 IP 时，称为段内转移，比如： jmp ax。 同时修改 CS 和 IP 时，称为段间转移，比如： jmp 1000:0。 由于转移指令对 IP 的修改范围不同，段内转移又分为：短转移和近转移。 短转移 IP 的修改范围为 -128~127。 近转移 IP 的修改范围为 -32768~32767。 8086CPU 的转移指令分为以下几类。 无条件转移指令(如:jmp) 条件转移指令 循环指令(如: loop) 过程 中断 我们主要通过深入学习无条件转移指令 jmp 来理解 CPU 执行转移指令的基本原理。 ","date":"2023-09-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_09/:0:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 转移指令的原理","uri":"/posts/computer_architecture/assemply_language/assemply_language_09/#"},{"categories":["计算机体系结构"],"content":" 1 操作符 offset操作符 offset 在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。 示例 在如下的程序中 offset 操作符取得了标号 start 和 s 的偏移地址 0 和 3。 text assume cs:codesg codesg segment start: mov ax, offset start ; 相当于 mov ax, 0 s: mov ax, offset s ; 相当于 mov ax, 3 (第一条指令长度为 3 字节) codesg ends end start ","date":"2023-09-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_09/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 转移指令的原理","uri":"/posts/computer_architecture/assemply_language/assemply_language_09/#操作符-offset"},{"categories":["计算机体系结构"],"content":" 2 jmp 指令jmp 为无条件转移指令，可以只修改 IP，也可以同时修改 CS 和 IP。 jmp 指令要给出两种信息: 转移的目的地址 转移的距离(段间转移、段内短转移、段内近转移) ","date":"2023-09-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_09/:2:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 转移指令的原理","uri":"/posts/computer_architecture/assemply_language/assemply_language_09/#jmp-指令"},{"categories":["计算机体系结构"],"content":" 2.1 依据位移进行转移的 jmp 指令jmp short 标号 这种格式的 jmp 指令实现的是段内短转移。它对 IP 的修改范围为 -128~127。 text assume cs:codesg codesg segment start: mov ax, O jmp short s ; 段内短转移 add ax, 1 s: inc ax codesg ends end start 上述代码在 Debug 中翻译为机器码，可以看到机器码中不包含转移目的地址而是 “EB 03”。 段内短转移程序机器码 这是因为 CPU在执行 jmp 指令的时候并不需要转移的目的地址。在 “jmp short 标号〞指令所对应的机器码中，并不包含转移的目的地址，而包含的是转移的位移。这个位移，是编译器根据汇编指令中的 “标号” 计算出来的，计算方法如下图所示： 转移位移的计算方法 “jmp short 标号” 的功能为:(IP)=(IP)+8位位移。 8 位位移 = 标号处的地址-jmp 指令后的第一个字节的地址； short 指明此处的位移为 8 位位移； 8 位位移的范围为 -128~127，用补码表示； 8 位位移由编译程序在编译时算出。 “jmp near ptr 标号” 格式的命令，它实现的是段内近转移。功能为：(IP)=(IP)+16位位移。 16 位位移 = 标号处的地址-jmp指令后的第一个字节的地址； near ptr 指明此处的位移为 16 位位移，迸行的是段内近转移； 16 位位移的范围为 -32768~32767，用补码表示; 16 位位移由编译程序在编译时算出。 ","date":"2023-09-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_09/:2:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 转移指令的原理","uri":"/posts/computer_architecture/assemply_language/assemply_language_09/#依据位移进行转移的-jmp-指令"},{"categories":["计算机体系结构"],"content":" 2.2 转移的目的地址在指令中的 jmp 指令“jmp far ptr 标号” 实现的是段间转移，又称为远转移。 text assume cs:codesg codesg segment start: mov ax, 0 mov bx, 0 jmp far ptr s ; 段间转移 db 256 dup (0) s: add ax,1 inc ax codesg ends end start 在 Debug 中将上述代码翻译成机器码，结果如下图所示： 段间转移程序机器码 代码 “jmp far ptr s” 所对应的机器码: “EA 0B 01 BD 0B”，其中包含转移的目的地址。“0B 01 BD 0B” 是目的地址在指令中的存储顺序，高地址的 “BD 0B” 是转移的段地址：“0BBDH”，低地址的 “0B 01” 是偏移地址: “010BH”。 ","date":"2023-09-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_09/:2:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 转移指令的原理","uri":"/posts/computer_architecture/assemply_language/assemply_language_09/#转移的目的地址在指令中的-jmp-指令"},{"categories":["计算机体系结构"],"content":" 2.3 转移地址在寄存器中的 jmp 指令指令格式：jmp 16位 reg 功能:(IP)=(16 位 reg) ","date":"2023-09-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_09/:2:3","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 转移指令的原理","uri":"/posts/computer_architecture/assemply_language/assemply_language_09/#转移地址在寄存器中的-jmp-指令"},{"categories":["计算机体系结构"],"content":" 2.4 转移地址在内存中的jmp 指令转移地址在内存中的 jmp 指令有两种格式： jmp word ptr 内存单元地址(段内转移) 功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。 text mov ax, 0123H mov ds:[0],ax jmp word ptr ds:[0] ; 执行后 IP = 0123H jmp dword ptr 内存单元地址(段间转移) 功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。 text mov ax, 0123H mov ds:[0],ax mov word ptr ds:[2], 0 jmp dword ptr ds:[0] ; 执行后 CS = 0000H，IP = 0123H ","date":"2023-09-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_09/:2:4","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 转移指令的原理","uri":"/posts/computer_architecture/assemply_language/assemply_language_09/#转移地址在内存中的jmp-指令"},{"categories":["计算机体系结构"],"content":" 3 jcxz 指令jcxz 指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对 IP 的修改范围都为：-128~127。 格式：jcxz 标号。 操作：当 (cx)=0 时，IP=(IP)+8位位移。当 (cx)!=0 时，什么也不做 (程序向下执行)。 jcxz 指令的 C语言描述 可以用以下 C语言代码来描述 jcxz 指令的功能： if ((cx)==0) jmp short 标号 ","date":"2023-09-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_09/:3:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 转移指令的原理","uri":"/posts/computer_architecture/assemply_language/assemply_language_09/#jcxz-指令"},{"categories":["计算机体系结构"],"content":" 4 loop 指令loop 指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对 IP 的修改范围都为： -128~127。 loop 指令的 C语言描述 可以用以下 C语言代码来描述 loop 指令的功能： text (cx)-- if((cx) != 0) jmp short 标号 ","date":"2023-09-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_09/:4:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 转移指令的原理","uri":"/posts/computer_architecture/assemply_language/assemply_language_09/#loop-指令"},{"categories":["计算机体系结构"],"content":" 5 实验 9 text assume cs:code, es:data, ss:stack data segment db 'welcome to masm!' db 02H, 24H, 71H ; 颜色 data ends stack segment db 10 dup (0) stack ends code segment start: mov ax, data mov es, ax mov di, 0 ; es:di -\u003e data mov si, 16 ; es:si -\u003e 颜色 mov ax, 0B800H mov ds, ax mov bx, 0720H ; ds:bx -\u003e 缓冲区 mov ax, stack mov ss, ax mov sp, 0 mov cx, 3 ; 三行 row: push cx mov cx, 16 ; 每行 16 个字符 col: mov al, es:[di] mov ds:[bx], al mov ah, es:[si] mov ds:[bx+1], ah inc di add bx, 2 loop col add bx, 128 ; bx 指向下一行的起始地址 mov di, 0 inc si ; 下一个颜色 pop cx loop row mov ax, 4c00H int 21H code ends end start ","date":"2023-09-17","objectID":"/posts/computer_architecture/assemply_language/assemply_language_09/:5:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 转移指令的原理","uri":"/posts/computer_architecture/assemply_language/assemply_language_09/#实验-9"},{"categories":["计算机体系结构"],"content":"汇编语言 —— 数据处理的两个基本问题","date":"2023-09-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_08/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 数据处理的两个基本问题","uri":"/posts/computer_architecture/assemply_language/assemply_language_08/"},{"categories":["计算机体系结构"],"content":"本章对前面的所有内容是具有总结性的。 计算机是进行数据处理、运算的机器，那么有两个基本的问题就包含在其中： 处理的数据在什么地方？ 要处理的数据有多长？ ","date":"2023-09-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_08/:0:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 数据处理的两个基本问题","uri":"/posts/computer_architecture/assemply_language/assemply_language_08/#"},{"categories":["计算机体系结构"],"content":" 1 定位处理的数据","date":"2023-09-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_08/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 数据处理的两个基本问题","uri":"/posts/computer_architecture/assemply_language/assemply_language_08/#定位处理的数据"},{"categories":["计算机体系结构"],"content":" 1.1 bx, si, di 和 bp对这四个寄存器进行一个总结： 在 8086CPU 中，只有这 4 个寄存器可以用在 “[…]” 中来进行内存单元的寻址； 在 “[…]” 中，这 4 个寄存器可以单个出现，或只能以 4 种组合出现： bx 和 si bx 和 di bp 和 si bp 和 di 只要在 “[…]” 中使用寄存器 bp，而指令中没有显性地给出段地址，段地址就默认在 ss 中。 ","date":"2023-09-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_08/:1:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 数据处理的两个基本问题","uri":"/posts/computer_architecture/assemply_language/assemply_language_08/#bx-si-di-和-bp"},{"categories":["计算机体系结构"],"content":" 1.2 汇编语言中数据位置的表达汇编语言中用 3 个概念来表达数据的位置： 立即数(idata)：直接包含在机器指令中的数据(执行前在 CPU 的指令缓冲器中)； 寄存器：指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名； 段地址(SA)和偏移地址(EA)：指令要处理的数据在内存中，在汇编指令中可用 “[X]” 的格式给出 EA，SA 在某个段寄存器中。 ","date":"2023-09-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_08/:1:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 数据处理的两个基本问题","uri":"/posts/computer_architecture/assemply_language/assemply_language_08/#汇编语言中数据位置的表达"},{"categories":["计算机体系结构"],"content":" 1.3 寻址方式当数据存放在内存中的时候，我们可以用多种方式来给定这个内存单元的偏移地址： 寻址方式小结 ","date":"2023-09-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_08/:1:3","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 数据处理的两个基本问题","uri":"/posts/computer_architecture/assemply_language/assemply_language_08/#寻址方式"},{"categories":["计算机体系结构"],"content":" 2 确定数据的长度8086CPU 的指令，可以处理两种尺寸的数据，byte 和 word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。汇编语言中用以下方法处理： ","date":"2023-09-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_08/:2:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 数据处理的两个基本问题","uri":"/posts/computer_architecture/assemply_language/assemply_language_08/#确定数据的长度"},{"categories":["计算机体系结构"],"content":" 2.1 通过寄存器名指明要处理的数据的尺寸下面的指令中，寄存器指明了指令进行的是字操作。 text mov ax, 1 mov bx, ds:[0] mov ds, ax mov ds:[0], ax inc ax add ax, 1000 下面的指令中，寄存器指明了指令进行的是字节操作。 text mov al, 1 mov al, b1 mov al, ds:[0] mov ds:[0], al inc al add al, 100 ","date":"2023-09-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_08/:2:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 数据处理的两个基本问题","uri":"/posts/computer_architecture/assemply_language/assemply_language_08/#通过寄存器名指明要处理的数据的尺寸"},{"categories":["计算机体系结构"],"content":" 2.2 用操作符指明内存单元的长度在没有寄存器名存在的情况下，用操作符 X ptr 指明内存单元的长度，在汇编指令中可以为 word 或 byte。 下面的指令中，用 word ptr 指明了指令访问的内存单元是一个字单元。 text mov word ptr ds:[0], 1 inc word ptr [bx] inc word ptr ds:[0] add word ptr [bx],2 下面的指令中，用 byte ptr 指明了指令访问的内存单元是一个字节单元。 text mov byte ptr ds:[0], 1 inc byte ptr [bx] inc byte ptr ds:[0] add byte ptr [bx], 2 ","date":"2023-09-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_08/:2:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 数据处理的两个基本问题","uri":"/posts/computer_architecture/assemply_language/assemply_language_08/#用操作符指明内存单元的长度"},{"categories":["计算机体系结构"],"content":" 2.3 其他方法有些指令默认了访问的是字单元还是字节单元，比如，push [1000H] 就不用指明访问的是字单元还是字节单元，因为 push 指令只进行字操作。 ","date":"2023-09-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_08/:2:3","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 数据处理的两个基本问题","uri":"/posts/computer_architecture/assemply_language/assemply_language_08/#其他方法"},{"categories":["计算机体系结构"],"content":" 3 学习三个指令","date":"2023-09-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_08/:3:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 数据处理的两个基本问题","uri":"/posts/computer_architecture/assemply_language/assemply_language_08/#学习三个指令"},{"categories":["计算机体系结构"],"content":" 3.1 div 指令div 是除法指令，使用 div 做除法的时候应注意以下问题： 除数：有 8 位和 16 位两种， 在一个 reg 或内存单元中； 被除数：默认放在 AX 或 (DX 和 AX) 中： 若除数 8 位，被除数则为 16 位，默认在 AX 中存放； 若除数为 16 位，被除数则为 32 位，在 DX 和 AX 中存放，DX 存放高 16 位，AX 存放低 16 位。 结果： 若除数 8 位，则 AL 存储除法操作的商，AH 存储除法操作的余数； 若除数为 16 位，则 AX 存储除法操作的商，DX 存储除法操作的余数。 格式如下： text div reg div 内存单元 16 位除法编程练习 编程，利用除法指令计算 100001 / 100： 首先分析一下，被除数 100001 大于 65535，不能用 ax 寄存器存放，所以只能用 dx 和 ax 两个寄存器联合存放 100001，也就是说要进行 16 位的除法。除数 100 小于 255, 可以在一个 8 位寄存器中存放，但是，因为被除数是 32 位的，除数应为 16 位，所以要用一个 16 位寄存器来存放除数 100。 text mov dx, 1 mov ax, 86A1H ; (dx) * 10000H + (ax) = 100001 mov bx, 100 div bx 8 位除法编程练习 编程，利用除法指令计算 1001 / 100： 首先分析一下，被除数 1001 可用 ax 寄存器存放，除数 100 可用 8 位寄存器存放，也就是说，要进行 8 位的除法。 text mov ax, 1001 mov bl,100 div bl ","date":"2023-09-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_08/:3:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 数据处理的两个基本问题","uri":"/posts/computer_architecture/assemply_language/assemply_language_08/#div-指令"},{"categories":["计算机体系结构"],"content":" 3.2 伪指令 dd前面我们用 db 和 dw 定义字节型数据和字型数据。dd 是用来定义 dword (double word，双字) 型数据的。比如: text data segment db 1 ; 数据为 01H，在 data:0 处，占 1 个字节 dw 1 ; 数据为 0001H，在 data:1 处，占 1 个字 dd 1 ; 数据为 00000001H，在 data:3 处，占 2 个字 data ends ","date":"2023-09-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_08/:3:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 数据处理的两个基本问题","uri":"/posts/computer_architecture/assemply_language/assemply_language_08/#伪指令-dd"},{"categories":["计算机体系结构"],"content":" 3.3 dup 操作符dup 是一个操作符，在汇编语言中同 db、dw、dd 等一样，也是由编译器识别处理的符号。它是和 db、dw、dd 等数据定义伪指令配合使用的，用来进行数据的重复。 text db 3 dup (0) ; 定义了 3 个字节，它们的值都是 0，相当于 db 0,0,0 db 3 dup (0,1,2) ; 定义了 9 个字节，相当于db 0,1,2,0,1,2,0,1,2 db 3 dup ('abc', 'ABC') ; 定义了 18 个字节，相当于 db 'abcABCabcABCabcABC' ","date":"2023-09-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_08/:3:3","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 数据处理的两个基本问题","uri":"/posts/computer_architecture/assemply_language/assemply_language_08/#dup-操作符"},{"categories":["计算机体系结构"],"content":"汇编语言 —— 更灵活的定位内存地址的方法","date":"2023-09-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_07/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 更灵活的定位内存地址的方法","uri":"/posts/computer_architecture/assemply_language/assemply_language_07/"},{"categories":["计算机体系结构"],"content":" 1 大小写转换的问题","date":"2023-09-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_07/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 更灵活的定位内存地址的方法","uri":"/posts/computer_architecture/assemply_language/assemply_language_07/#大小写转换的问题"},{"categories":["计算机体系结构"],"content":" 1.1 and 和 or 指令 and 指令：逻辑与指令，按位进行与运算； or 指令：逻辑或指令，按位进行或运算。 ","date":"2023-09-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_07/:1:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 更灵活的定位内存地址的方法","uri":"/posts/computer_architecture/assemply_language/assemply_language_07/#and-和-or-指令"},{"categories":["计算机体系结构"],"content":" 1.2 ASCII 码一个文本编辑过程中，就包含着按照 ASCII 编码规则进行的编码和解码。在文本编辑过程中，我们按一下键盘的 a 键，就会在屏幕上看到 “a”。 我们按下键盘的 a 键，这个按键的信息被送入计算机，计算机用 ASCII 码的规则对其进行编码，将其转化为 61H 存储在内存的指定空间中；文本编辑软件从内存中取出 61H，将其送到显卡上的显存中；工作在文本模式下的显卡，用 ASCII 码的规则解释显存中的内容， 61H 被当作字符 “a”，显卡驱动显示器，将字符 “a” 的图像画在屏幕上。 ","date":"2023-09-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_07/:1:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 更灵活的定位内存地址的方法","uri":"/posts/computer_architecture/assemply_language/assemply_language_07/#ascii-码"},{"categories":["计算机体系结构"],"content":" 1.3 以字符形式给出的数据在汇编程序中，用 ‘……’ 的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的 ASCII 码。 text assume cs:code, ds:data data segment db 'unTY' ; 相当于 \"db 75H,6EH,49H,58H\" db 'fORK' ; 相当于 \"db 66H,6FH,52H,4BH\" data ends code segment start: ... code ends end start ","date":"2023-09-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_07/:1:3","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 更灵活的定位内存地址的方法","uri":"/posts/computer_architecture/assemply_language/assemply_language_07/#以字符形式给出的数据"},{"categories":["计算机体系结构"],"content":" 1.4 大小写转换要改变一个字母的大小写，实际上就是要改变它所对应的 ASCII 码，一些字母的 ASCII 码如下表所示： 大写 / 小写 大写十六进制 大写二进制 小写十六进制 小写二进制 A / a 41 01000001 61 01100001 B / b 42 01000010 62 01100010 C / c 43 01000011 63 01100011 D / d 44 01000100 64 01100100 E / e 45 01000101 65 01100101 F / f 46 01000110 66 01100110 由上表可以得出大小写字母 ASCII 码的规律： 小写字母的 ASCII 码值比大写字母的 ASCII 码值大 20H； 大写字母 ASCII 码的第 5 位为 0，小写字母的第 5 位为 1，其余各位都一样。 我们通过规律 2，配合 and 和 or 指令，可以实现字母的大小写转换。 text and al, 11011111B ; 将 al 中的 ASCII 码的第 5 位置为 0，变为大写字母 or al, 00100000B ; 将 al 中的 ASCII 码的第 5 位置为 1，变为小写字母 ","date":"2023-09-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_07/:1:4","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 更灵活的定位内存地址的方法","uri":"/posts/computer_architecture/assemply_language/assemply_language_07/#大小写转换"},{"categories":["计算机体系结构"],"content":" 2 更灵活的定位内存地址方法之前，我们使用 [bx] 方式来指明一个内存单元。现在介绍几种更加灵活的定位内存地址的方式。 ","date":"2023-09-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_07/:2:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 更灵活的定位内存地址的方法","uri":"/posts/computer_architecture/assemply_language/assemply_language_07/#更灵活的定位内存地址方法"},{"categories":["计算机体系结构"],"content":" 2.1 [bx + idata][bx + idata] 表示一个内存单元，它的偏移地址为(bx) + idata (bx 中的数值加上 idata)。 指令 mov ax,[bx+200]，表示： 将一个内存单元的内容送入 ax，这个内存单元的长度为 2 个字节(字单元)，存放一个字，偏移地址为 bx 中的数值加上 200，段地址在 ds 中。 该指令也可以写成如下格式： text mov ax, [200+bx] mov ax, 200[bx] mov ax, [bx].200 汇编语言中 [bx + idata] 的表示方式，为高级语言实现数组提供了便利机制： C 语言：a[i] 汇编语言：200[bx] ","date":"2023-09-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_07/:2:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 更灵活的定位内存地址的方法","uri":"/posts/computer_architecture/assemply_language/assemply_language_07/#bx--idata"},{"categories":["计算机体系结构"],"content":" 2.2 [bx + si] 和 [bx + di]si 和 di 是 8086CPU 中和 bx 功能相近的寄存器，区别是 si 和 di 不能够分成两个 8 位寄存器来使用。 表示一个内存单元，它的偏移地址为 (6x)+(si) (即 bx 中的数值加上 si 中的数值)。 指令 mov ax,[bx+si] 表示： 将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节(字单元)，存放一个字，偏移地址为 bx 中的数值加上 si 中的数值，段地址在 ds 中。 该指令也可以写成如下格式：mov ax, [bx][si]。 [bx + di] 含义与 [bx + si] 相同。 ","date":"2023-09-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_07/:2:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 更灵活的定位内存地址的方法","uri":"/posts/computer_architecture/assemply_language/assemply_language_07/#bx--si-和-bx--di"},{"categories":["计算机体系结构"],"content":" 2.3 [bx + si + idata] 和 [bx + di + idata][bx + si + idata] 表示一个内存单元，它的偏移地址为 (bx)+(si)+idata (即 bx 中的数值加上 si 中的数值再加上 idata)。 指令 mov ax, [bx+si+idata] 表示： 将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节(字单元)，存放一个字，偏移地址为 bx 中的数值加上 si 中的数值再加上 idata，段地址在 ds 中。 该指令也可以写成如下格式： text mov ax, [bx+200+si] mov ax, [200+bx+si] mov ax, 200[bx][si] mov ax, [bx].200[si] mov ax, [bx][si].200 [bx + di + idata] 含义与 [bx + si + idata] 相同。 ","date":"2023-09-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_07/:2:3","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 更灵活的定位内存地址的方法","uri":"/posts/computer_architecture/assemply_language/assemply_language_07/#bx--si--idata-和-bx--di--idata"},{"categories":["计算机体系结构"],"content":" 3 不同寻址方式的灵活应用首先对目前学习过的寻址方式做一个小结： [idata] 用一个常量来表示地址，可用于直接定位一个内存单元； [bx] 用一个变量来表示内存地址，可用于间按定位 一个内存单元； [bx+idata] 用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元； [bx+si] 用两个变量表示地址； [bx+si+idata] 用两个变量和一个常量表示地址。 从 [idata] 一直到 [bx+si+idata]，我们可以用更加灵活的方式来定位一个内存单元的地址。这使我们可以从更加结构化的角度来看待所要处理的数据。 ","date":"2023-09-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_07/:3:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 更灵活的定位内存地址的方法","uri":"/posts/computer_architecture/assemply_language/assemply_language_07/#不同寻址方式的灵活应用"},{"categories":["计算机体系结构"],"content":" 3.1 寻址方式编程练习 问题 将 datasg 段中每个单词的前 4 个字母改为大写字母。 text datasg segment db '1. display ' db '2. brows ' db '3. replace ' db '4. modify ' datasg ends 分析：datasg 中的数据的存储结构如下图所示： datasg 中的数据的存储结构 经分析，我们需要进行 4x4 次的二重循环来处理数据： 用 bx 来作变量，定位每行的起始地址，用 si 定位要修改的列，用 [bx+3+si] 的方式来对目标单元进行寻址； 用栈来暂存外层循环的 cx 值。 代码如下： text assume cs:codesg, ss:stacksg, ds:datasg stacksg segment dw 0,0,0,0,0,0,0,0 stacksg ends datasg segment db '1. display ' db '2. brows ' db '3. replace ' db '4. modify ' datasg ends codesg segment start: mov ax, stacksg mov ss, ax mov sp, 16 mov ax, datasg mov ds, ax mov bx, 0 ; bx 定位每行的起始地址 mov cx, 4 s0: push cx ; 将外层循环的 cx 值压栈 mov cx, 4 mov si, 0 ; si 定位相对于起始列(3)要修改的列 s: mov al, [bx+si+3] and al, 11011111B mov [bx+si+3], al inc si loop s add bx, 16 pop cx ; 恢复外层循环 cx loop s0 mov ax, 4c00H int 21H codesg ends end start ","date":"2023-09-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_07/:3:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 更灵活的定位内存地址的方法","uri":"/posts/computer_architecture/assemply_language/assemply_language_07/#寻址方式编程练习"},{"categories":["计算机体系结构"],"content":" 4 重点小结 and、or 指令； 大小写转化的方法； 寻址方式 的意义和应用； 二重循环问题的处理； 栈的应用：一般来说，在需要暂存数据的时候，我们都应该使用栈。 ","date":"2023-09-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_07/:4:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 更灵活的定位内存地址的方法","uri":"/posts/computer_architecture/assemply_language/assemply_language_07/#重点小结"},{"categories":["中间件技术"],"content":"阅读 Redis 快速列表 quicklist 相关代码，了解 Redis 中快速列表的实现。","date":"2023-09-08","objectID":"/posts/redis_source_code/redis_source_code_06/","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 快速列表 (quicklist)","uri":"/posts/redis_source_code/redis_source_code_06/"},{"categories":["中间件技术"],"content":" 1 quicklist 结构体定义","date":"2023-09-08","objectID":"/posts/redis_source_code/redis_source_code_06/:1:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 快速列表 (quicklist)","uri":"/posts/redis_source_code/redis_source_code_06/#quicklist-结构体定义"},{"categories":["中间件技术"],"content":" 1.1 quicklistNodequicklistNode 结构体定义了快速列表结点，它是一个 32 字节的结构体，包含指向前驱结点和后继结点的指针，一个数据指针 entry 指向实际存储数据的 listpack (或者一个压缩过后的 quicklistLZF)，另外还有一些描述结点元数据的成员。 C /* Node, quicklist, and Iterator are the only data structures used currently. */ /* quicklistNode is a 32 byte struct describing a listpack for a quicklist. * We use bit fields keep the quicklistNode at 32 bytes. * count: 16 bits, max 65536 (max lp bytes is 65k, so max count actually \u003c 32k). * encoding: 2 bits, RAW=1, LZF=2. * container: 2 bits, PLAIN=1 (a single item as char array), PACKED=2 (listpack with multiple items). * recompress: 1 bit, bool, true if node is temporary decompressed for usage. * attempted_compress: 1 bit, boolean, used for verifying during testing. * extra: 10 bits, free for future use; pads out the remainder of 32 bits */ typedef struct quicklistNode { // 前驱结点指针 8 bytes struct quicklistNode *prev; // 后继结点指针 8 bytes struct quicklistNode *next; // 数据指针，指向 listpack 或者 quicklistLZF，8 bytes unsigned char *entry; // entry 占用字节大小 4 bytes size_t sz; /* entry size in bytes */ // 16 bits，listpack 里的结点数量 unsigned int count : 16; /* count of items in listpack */ // 2 bits，listpack 编码方式， RAW 表示原始 listpack， LZF 表示压缩后的 listpack unsigned int encoding : 2; /* RAW==1 or LZF==2 */ // 2 bits，表示 entry 中的元素类别是 PLAIN 还是 PACKED unsigned int container : 2; /* PLAIN==1 or PACKED==2 */ // 1 bit，表示该结点在之前是否压缩过 unsigned int recompress : 1; /* was this node previous compressed? */ // 1 bit，表示该结点数据能否被压缩 unsigned int attempted_compress : 1; /* node can't compress; too small */ // 1 bit，标记该结点不进行压缩 unsigned int dont_compress : 1; /* prevent compression of entry that will be used later */ // 9 bits，用于扩展 unsigned int extra : 9; /* more bits to steal for future usage */ } quicklistNode; ","date":"2023-09-08","objectID":"/posts/redis_source_code/redis_source_code_06/:1:1","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 快速列表 (quicklist)","uri":"/posts/redis_source_code/redis_source_code_06/#quicklistnode"},{"categories":["中间件技术"],"content":" 1.2 quicklistLZFquicklistLZF 是 quicklistNode 中的 listpack 压缩后的结构： sz：指 compressed 数组的长度； compressed：柔性数组，存储着 listpack 被压缩后的具体的字节数组。 C /* quicklistLZF is a 8+N byte struct holding 'sz' followed by 'compressed'. * 'sz' is byte length of 'compressed' field. * 'compressed' is LZF data with total (compressed) length 'sz' * NOTE: uncompressed length is stored in quicklistNode-\u003esz. * When quicklistNode-\u003eentry is compressed, node-\u003eentry points to a quicklistLZF */ // quicklistLZF 是一个 8+N 字节大小的结构体 // 压缩后的 listpack 大小存储在 LZF-\u003esz 中，未压缩的长度存储在 quicklistNode-\u003esz 中 typedef struct quicklistLZF { size_t sz; /* LZF size in bytes*/ char compressed[]; } quicklistLZF; ","date":"2023-09-08","objectID":"/posts/redis_source_code/redis_source_code_06/:1:2","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 快速列表 (quicklist)","uri":"/posts/redis_source_code/redis_source_code_06/#quicklistlzf"},{"categories":["中间件技术"],"content":" 1.3 quicklistBookmarkquicklistBookmark 会作为 quicklist 结构体的最后一个成员，是一个柔性数组。在需要迭代一个很长的 quicklist 时，可以利用此结构实现部分迭代。 C /* Bookmarks are padded with realloc at the end of of the quicklist struct. * They should only be used for very big lists if thousands of nodes were the * excess memory usage is negligible, and there's a real need to iterate on them * in portions. * When not used, they don't add any memory overhead, but when used and then * deleted, some overhead remains (to avoid resonance). * The number of bookmarks used should be kept to minimum since it also adds * overhead on node deletion (searching for a bookmark to update). */ typedef struct quicklistBookmark { quicklistNode *node; char *name; } quicklistBookmark; ","date":"2023-09-08","objectID":"/posts/redis_source_code/redis_source_code_06/:1:3","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 快速列表 (quicklist)","uri":"/posts/redis_source_code/redis_source_code_06/#quicklistbookmark"},{"categories":["中间件技术"],"content":" 1.4 quicklistquicklist 是一个 40 字节大小的结构体(64 位操作系统下)，同时也是一个双向链表。 C /* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist. * 'count' is the number of total entries. * 'len' is the number of quicklist nodes. * 'compress' is: 0 if compression disabled, otherwise it's the number * of quicklistNodes to leave uncompressed at ends of quicklist. * 'fill' is the user-requested (or default) fill factor. * 'bookmarks are an optional feature that is used by realloc this struct, * so that they don't consume memory when not used. */ typedef struct quicklist { // 8 bytes，头指针 quicklistNode *head; // 8 bytes，尾指针 quicklistNode *tail; // 8 bytes，所有 listpacks 中所有结点总数 unsigned long count; /* total count of all entries in all listpacks */ // 8 bytes，快速列表结点数 unsigned long len; /* number of quicklistNodes */ // 16 bits (64 位操作系统)，每个结点的填充因数 signed int fill : QL_FILL_BITS; /* fill factor for individual nodes */ // 16 bits (64 位操作系统)，两端结点不压缩的深度 unsigned int compress : QL_COMP_BITS; /* depth of end nodes not to compress;0=off */ // 4 bits，bookmarks 数组大小 unsigned int bookmark_count: QL_BM_BITS; // 柔性数组，用于重新分配 quicklist 空间，不使用时不消耗内存 quicklistBookmark bookmarks[]; } quicklist; fill 和 compress 成员可以通过配置文件配置： fill 成员对应配置：list-max-listpack-size -5: 每个 quidklistNode 结点的 listpack 字节大小不能超过 64 Kb -4: 每个 quidklistNode 结点的 listpack 字节大小不能超过 32 Kb -3: 每个 quidklistNode 结点的 listpack 字节大小不能超过 16 Kb -2: 每个 quidklistNode 结点的 listpack 字节大小不能超过 8 Kb -1: 每个 quidklistNode 结点的 listpack 字节大小不能超过 4 Kb 整数表示 listpack 结构最多包含的 entry 个数 compress 成员对应配置：list-compress-depth，表示压缩结点的深度 0 表示不压缩 1 表示 quicklist 列表的两端各有 1 个节点不压缩，中间的节点压缩 2 表示 quicklist 列表的两端各有 2 个节点不压缩，中间的节点压缩 以此类推 ","date":"2023-09-08","objectID":"/posts/redis_source_code/redis_source_code_06/:1:4","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 快速列表 (quicklist)","uri":"/posts/redis_source_code/redis_source_code_06/#quicklist"},{"categories":["中间件技术"],"content":" 1.5 quicklistIterquicklistIter 是快速列表的迭代器，用于遍历 quicklist。 C typedef struct quicklistIter { // 迭代的 quicklist quicklist *quicklist; // 当前迭代的 quicklistNode quicklistNode *current; // 当前迭代的 listpack 中的 element 的指针 unsigned char *zi; /* points to the current element */ // 当前 listpack 的偏移量 long offset; /* offset in current listpack */ // 迭代方向 int direction; } quicklistIter; ","date":"2023-09-08","objectID":"/posts/redis_source_code/redis_source_code_06/:1:5","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 快速列表 (quicklist)","uri":"/posts/redis_source_code/redis_source_code_06/#quicklistiter"},{"categories":["中间件技术"],"content":" 1.6 quicklistEntryquicklistEntry 用来描述一个 listpack 的 一个 element。 C typedef struct quicklistEntry { // 指向 listpack element 所属 quicklist const quicklist *quicklist; // 指向 listpack element 所属 quicklistNode quicklistNode *node; // 指向 listpack element 所属 listpack unsigned char *zi; // 若 listpack element 保存类型为字符串类型，value 和 sz 保存该值 unsigned char *value; // 若 listpack element 保存类型为整形，longval 保存该值 long long longval; size_t sz; // 标识 listpack element 在所处 listpack (即 zi 所指向的 listpack) 中的偏移量 // 表示该 element 是该 listpack 的第几个元素 int offset; } quicklistEntry; ","date":"2023-09-08","objectID":"/posts/redis_source_code/redis_source_code_06/:1:6","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 快速列表 (quicklist)","uri":"/posts/redis_source_code/redis_source_code_06/#quicklistentry"},{"categories":["中间件技术"],"content":" 2 quicklist API","date":"2023-09-08","objectID":"/posts/redis_source_code/redis_source_code_06/:2:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 快速列表 (quicklist)","uri":"/posts/redis_source_code/redis_source_code_06/#quicklist-api"},{"categories":["中间件技术"],"content":" 2.1 quicklistNewquicklistNew 创建一个赋默认值的 quicklist： 调用 quicklistCreate 创建一个空的快速列表； 为快速列表设置默认值： 设置每个结点的默认填充因数； 设置每个结点的默认压缩深度。 返回快速列表 C /* Create a new quicklist with some default parameters. */ quicklist *quicklistNew(int fill, int compress) { quicklist *quicklist = quicklistCreate(); quicklistSetOptions(quicklist, fill, compress); return quicklist; } /* Create a new quicklist. * Free with quicklistRelease(). */ quicklist *quicklistCreate(void) { struct quicklist *quicklist; quicklist = zmalloc(sizeof(*quicklist)); quicklist-\u003ehead = quicklist-\u003etail = NULL; quicklist-\u003elen = 0; quicklist-\u003ecount = 0; quicklist-\u003ecompress = 0; quicklist-\u003efill = -2; quicklist-\u003ebookmark_count = 0; return quicklist; } void quicklistSetOptions(quicklist *quicklist, int fill, int depth) { quicklistSetFill(quicklist, fill); quicklistSetCompressDepth(quicklist, depth); } #define FILL_MAX ((1 \u003c\u003c (QL_FILL_BITS-1))-1) void quicklistSetFill(quicklist *quicklist, int fill) { if (fill \u003e FILL_MAX) { fill = FILL_MAX; } else if (fill \u003c -5) { fill = -5; } quicklist-\u003efill = fill; } #define COMPRESS_MAX ((1 \u003c\u003c QL_COMP_BITS)-1) void quicklistSetCompressDepth(quicklist *quicklist, int compress) { if (compress \u003e COMPRESS_MAX) { compress = COMPRESS_MAX; } else if (compress \u003c 0) { compress = 0; } quicklist-\u003ecompress = compress; } ","date":"2023-09-08","objectID":"/posts/redis_source_code/redis_source_code_06/:2:1","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 快速列表 (quicklist)","uri":"/posts/redis_source_code/redis_source_code_06/#quicklistnew"},{"categories":["中间件技术"],"content":" 2.2 _quicklistInsert_quicklistInsert 以一个已存在的 listpack entry 前或后插入一个 entry 结点： 当前 quicklistNode 结点的 listpack 可以插入 插入已存在的 entry 前 (after = 0) 插入已存在的 entry 后 (after = 1) 如果当前 quicklistNode 结点的 listpack 由于 fill 的配置，无法继续插入 已存在的 entry 是 quicklistNode 的头结点，当前 quicklistNode 结点的前驱指针不为空，并且 after = 0 前驱结点可以插入，因此插在前驱结点的尾部 前驱结点不可以插入，因此要在当前结点和前驱结点之间创建一个新结点保存要插入的 entry 已存在的 entry 是 quicklistNode 的头结点，当前 quicklistNode 结点的前驱指针不为空，并且 after = 1 后继结点可以插入，因此插在后继结点的头部 后继结点不可以插入，因此要在当前结点和后继结点之间创建一个新结点保存要插入的 entry 以上情况都不满足，当前结点是满的，且需要将 entry 插入在 listpack 中间位置，则需要分割当前 quicklistNode 结点，然后插入到其中一个新结点，如果条件允许，还会进行结点两侧小结点的合并 C /* Insert a new entry before or after existing entry 'entry'. * * If after==1, the new value is inserted after 'entry', otherwise * the new value is inserted before 'entry'. */ REDIS_STATIC void _quicklistInsert(quicklistIter *iter, quicklistEntry *entry, void *value, const size_t sz, int after) { // 插入 entry 的目标 quicklist quicklist *quicklist = iter-\u003equicklist; // full：当前结点是否已满 // at_tail：entry 在当前结点尾部 // at_head：entry 在当前结点头部 // avail_next：下一个结点可插入 // avail_prev：上一个结点可插入 int full = 0, at_tail = 0, at_head = 0, avail_next = 0, avail_prev = 0; int fill = quicklist-\u003efill; // 当前 entry 所属 quicklistNode quicklistNode *node = entry-\u003enode; quicklistNode *new_node = NULL; if (!node) { /* we have no reference node, so let's create only node in the list */ // entry 没有所属 quicklistNode，因此需要在快速列表中创建一个结点 D(\"No node given!\"); if (unlikely(isLargeElement(sz))) { // sz 超过阈值，向 quicklist 插入一个 PlainNode（quicklist-\u003econtainer = 1） __quicklistInsertPlainNode(quicklist, quicklist-\u003etail, value, sz, after); return; } // 创建一个新的空结点 new_node = quicklistCreateNode(); // 创建一个新 listpack，将 sz 大小的 value 插入 listpack // 新结点的 entry 指向新的 listpack new_node-\u003eentry = lpPrepend(lpNew(0), value, sz); // 向 quicklist 插入新结点 __quicklistInsertNode(quicklist, NULL, new_node, after); // 更新维护相关计数器 new_node-\u003ecount++; quicklist-\u003ecount++; return; } /* Populate accounting flags for easier boolean checks later */ if (!_quicklistNodeAllowInsert(node, fill, sz)) { D(\"Current node is full with count %d with requested fill %d\", node-\u003ecount, fill); // 通过填充因数 fill 判断能否将 sz 大小的数据插入 node 中 // 不能插入，则标记 full = 1 full = 1; } // entry-\u003eoffset：listpack element 在 listpack 中的偏移量 // node-\u003ecount：quicklistNode 中元素个数 // 如果 after = 1，listpack element 在所处 listpack 最后 // 则标记 at_tail = 1 表示 entry 在当前 listpack 最后 // 如果 quicklistNode 的下一个结点允许插入 // 则标记 avail_next = 1 if (after \u0026\u0026 (entry-\u003eoffset == node-\u003ecount - 1 || entry-\u003eoffset == -1)) { D(\"At Tail of current listpack\"); at_tail = 1; if (_quicklistNodeAllowInsert(node-\u003enext, fill, sz)) { D(\"Next node is available.\"); avail_next = 1; } } if (!after \u0026\u0026 (entry-\u003eoffset == 0 || entry-\u003eoffset == -(node-\u003ecount))) { D(\"At Head\"); at_head = 1; if (_quicklistNodeAllowInsert(node-\u003eprev, fill, sz)) { D(\"Prev node is available.\"); avail_prev = 1; } } // 处理大元素(PLAIN NODE) if (unlikely(isLargeElement(sz))) { if (QL_NODE_IS_PLAIN(node) || (at_tail \u0026\u0026 after) || (at_head \u0026\u0026 !after)) { __quicklistInsertPlainNode(quicklist, node, value, sz, after); } else { quicklistDecompressNodeForUse(node); new_node = _quicklistSplitNode(node, entry-\u003eoffset, after); quicklistNode *entry_node = __quicklistCreatePlainNode(value, sz); __quicklistInsertNode(quicklist, node, entry_node, after); __quicklistInsertNode(quicklist, entry_node, new_node, after); quicklist-\u003ecount++; } return; } /* Now determine where and how to insert the new element */ // 此后的代码是决定在哪里插入和如何插入的代码 if (!full \u0026\u0026 after) { // 当前结点没有满，且是后插入，则直接将新 entry 插入到当前 entry 后 D(\"Not full, inserting after current position.\"); // 如果结点压缩，则将当前结点解压，并设置 recompress = 1 quicklistDecompressNodeForUse(node); node-\u003eentry = lpInsertString(node-\u003eentry, value, sz, entry-\u003ezi, LP_AFTER, NULL); node-\u003ecount++; // 更新 node-\u003esz quicklistNodeUpdateSz(node); // 如果结点需要重新压缩，则进行重新压缩 quicklistRecompressOnly(node); } else if (!full \u0026\u0026 !after) { // 当前结点未满，并且是前插入，测直接将新 entry 插入到当前 entry 前 D(\"Not full, inserting before current position.\"); quicklistDecompressNodeForUse(n","date":"2023-09-08","objectID":"/posts/redis_source_code/redis_source_code_06/:2:2","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 快速列表 (quicklist)","uri":"/posts/redis_source_code/redis_source_code_06/#_quicklistinsert"},{"categories":["中间件技术"],"content":" 2.3 quicklistPushquicklistPush 方法向 quicklist 头尾两端插入元素，根据 where 参数选择向头结点添加还是尾结点添加元素。代码以向头结点添加元素来做分析。 C /* Wrapper to allow argument-based switching between HEAD/TAIL pop */ void quicklistPush(quicklist *quicklist, void *value, const size_t sz, int where) { /* The head and tail should never be compressed (we don't attempt to decompress them) */ if (quicklist-\u003ehead) assert(quicklist-\u003ehead-\u003eencoding != QUICKLIST_NODE_ENCODING_LZF); if (quicklist-\u003etail) assert(quicklist-\u003etail-\u003eencoding != QUICKLIST_NODE_ENCODING_LZF); if (where == QUICKLIST_HEAD) { quicklistPushHead(quicklist, value, sz); } else if (where == QUICKLIST_TAIL) { quicklistPushTail(quicklist, value, sz); } } /* Add new entry to head node of quicklist. * * Returns 0 if used existing head. * Returns 1 if new head created. */ // 如果添加结点后未改变头结点指针，返回 0 // 如果添加结点后创建了一个新的头结点，返回 1 int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) { quicklistNode *orig_head = quicklist-\u003ehead; // 处理大元素 if (unlikely(isLargeElement(sz))) { __quicklistInsertPlainNode(quicklist, quicklist-\u003ehead, value, sz, 0); return 1; } if (likely( _quicklistNodeAllowInsert(quicklist-\u003ehead, quicklist-\u003efill, sz))) { // 当前结点允许插入元素，向头结点 listpack 头部插入元素，更新头结点大小 quicklist-\u003ehead-\u003eentry = lpPrepend(quicklist-\u003ehead-\u003eentry, value, sz); quicklistNodeUpdateSz(quicklist-\u003ehead); } else { // 创建新结点 quicklistNode *node = quicklistCreateNode(); node-\u003eentry = lpPrepend(lpNew(0), value, sz); quicklistNodeUpdateSz(node); _quicklistInsertNodeBefore(quicklist, quicklist-\u003ehead, node); } // 维护结点数量 quicklist-\u003ecount++; quicklist-\u003ehead-\u003ecount++; return (orig_head != quicklist-\u003ehead); } 2.3.1 _quicklistNodeAllowInsert_quicklistNodeAllowInsert 方法判断 quicklistNode 是否允许插入新的元素。 C /* Maximum estimate of the listpack entry overhead. * Although in the worst case(sz \u003c 64), we will waste 6 bytes in one * quicklistNode, but can avoid memory waste due to internal fragmentation * when the listpack exceeds the size limit by a few bytes (e.g. being 16388). */ #define SIZE_ESTIMATE_OVERHEAD 8 // 判断 node 结点是否允许插入 REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node, const int fill, const size_t sz) { // node 结点为空，不允许插入 if (unlikely(!node)) return 0; // 如果 node 是 PLAIN 类型结点，或者 sz 太大，不允许插入 if (unlikely(QL_NODE_IS_PLAIN(node) || isLargeElement(sz))) return 0; /* Estimate how many bytes will be added to the listpack by this one entry. * We prefer an overestimation, which would at worse lead to a few bytes * below the lowest limit of 4k (see optimization_level). * Note: No need to check for overflow below since both `node-\u003esz` and * `sz` are to be less than 1GB after the plain/large element check above. */ // 估计添加元素后结点的大小，超过限制则不允许插入 size_t new_sz = node-\u003esz + sz + SIZE_ESTIMATE_OVERHEAD; if (unlikely(quicklistNodeExceedsLimit(fill, new_sz, node-\u003ecount + 1))) return 0; return 1; } ","date":"2023-09-08","objectID":"/posts/redis_source_code/redis_source_code_06/:2:3","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 快速列表 (quicklist)","uri":"/posts/redis_source_code/redis_source_code_06/#quicklistpush"},{"categories":["中间件技术"],"content":" 2.3 quicklistPushquicklistPush 方法向 quicklist 头尾两端插入元素，根据 where 参数选择向头结点添加还是尾结点添加元素。代码以向头结点添加元素来做分析。 C /* Wrapper to allow argument-based switching between HEAD/TAIL pop */ void quicklistPush(quicklist *quicklist, void *value, const size_t sz, int where) { /* The head and tail should never be compressed (we don't attempt to decompress them) */ if (quicklist-\u003ehead) assert(quicklist-\u003ehead-\u003eencoding != QUICKLIST_NODE_ENCODING_LZF); if (quicklist-\u003etail) assert(quicklist-\u003etail-\u003eencoding != QUICKLIST_NODE_ENCODING_LZF); if (where == QUICKLIST_HEAD) { quicklistPushHead(quicklist, value, sz); } else if (where == QUICKLIST_TAIL) { quicklistPushTail(quicklist, value, sz); } } /* Add new entry to head node of quicklist. * * Returns 0 if used existing head. * Returns 1 if new head created. */ // 如果添加结点后未改变头结点指针，返回 0 // 如果添加结点后创建了一个新的头结点，返回 1 int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) { quicklistNode *orig_head = quicklist-\u003ehead; // 处理大元素 if (unlikely(isLargeElement(sz))) { __quicklistInsertPlainNode(quicklist, quicklist-\u003ehead, value, sz, 0); return 1; } if (likely( _quicklistNodeAllowInsert(quicklist-\u003ehead, quicklist-\u003efill, sz))) { // 当前结点允许插入元素，向头结点 listpack 头部插入元素，更新头结点大小 quicklist-\u003ehead-\u003eentry = lpPrepend(quicklist-\u003ehead-\u003eentry, value, sz); quicklistNodeUpdateSz(quicklist-\u003ehead); } else { // 创建新结点 quicklistNode *node = quicklistCreateNode(); node-\u003eentry = lpPrepend(lpNew(0), value, sz); quicklistNodeUpdateSz(node); _quicklistInsertNodeBefore(quicklist, quicklist-\u003ehead, node); } // 维护结点数量 quicklist-\u003ecount++; quicklist-\u003ehead-\u003ecount++; return (orig_head != quicklist-\u003ehead); } 2.3.1 _quicklistNodeAllowInsert_quicklistNodeAllowInsert 方法判断 quicklistNode 是否允许插入新的元素。 C /* Maximum estimate of the listpack entry overhead. * Although in the worst case(sz \u003c 64), we will waste 6 bytes in one * quicklistNode, but can avoid memory waste due to internal fragmentation * when the listpack exceeds the size limit by a few bytes (e.g. being 16388). */ #define SIZE_ESTIMATE_OVERHEAD 8 // 判断 node 结点是否允许插入 REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node, const int fill, const size_t sz) { // node 结点为空，不允许插入 if (unlikely(!node)) return 0; // 如果 node 是 PLAIN 类型结点，或者 sz 太大，不允许插入 if (unlikely(QL_NODE_IS_PLAIN(node) || isLargeElement(sz))) return 0; /* Estimate how many bytes will be added to the listpack by this one entry. * We prefer an overestimation, which would at worse lead to a few bytes * below the lowest limit of 4k (see optimization_level). * Note: No need to check for overflow below since both `node-\u003esz` and * `sz` are to be less than 1GB after the plain/large element check above. */ // 估计添加元素后结点的大小，超过限制则不允许插入 size_t new_sz = node-\u003esz + sz + SIZE_ESTIMATE_OVERHEAD; if (unlikely(quicklistNodeExceedsLimit(fill, new_sz, node-\u003ecount + 1))) return 0; return 1; } ","date":"2023-09-08","objectID":"/posts/redis_source_code/redis_source_code_06/:2:3","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 快速列表 (quicklist)","uri":"/posts/redis_source_code/redis_source_code_06/#_quicklistnodeallowinsert"},{"categories":["中间件技术"],"content":" 2.4 quicklistPopquicklistPop 方法 C /* Default pop function * * Returns malloc'd value from quicklist */ int quicklistPop(quicklist *quicklist, int where, unsigned char **data, size_t *sz, long long *slong) { unsigned char *vstr = NULL; size_t vlen = 0; long long vlong = 0; if (quicklist-\u003ecount == 0) return 0; int ret = quicklistPopCustom(quicklist, where, \u0026vstr, \u0026vlen, \u0026vlong, _quicklistSaver); if (data) *data = vstr; if (slong) *slong = vlong; if (sz) *sz = vlen; return ret; } /* pop from quicklist and return result in 'data' ptr. Value of 'data' * is the return value of 'saver' function pointer if the data is NOT a number. * * If the quicklist element is a long long, then the return value is returned in * 'sval'. * * Return value of 0 means no elements available. * Return value of 1 means check 'data' and 'sval' for values. * If 'data' is set, use 'data' and 'sz'. Otherwise, use 'sval'. */ int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data, size_t *sz, long long *sval, void *(*saver)(unsigned char *data, size_t sz)) { unsigned char *p; unsigned char *vstr; unsigned int vlen; long long vlong; int pos = (where == QUICKLIST_HEAD) ? 0 : -1; if (quicklist-\u003ecount == 0) return 0; if (data) *data = NULL; if (sz) *sz = 0; if (sval) *sval = -123456789; quicklistNode *node; if (where == QUICKLIST_HEAD \u0026\u0026 quicklist-\u003ehead) { node = quicklist-\u003ehead; } else if (where == QUICKLIST_TAIL \u0026\u0026 quicklist-\u003etail) { node = quicklist-\u003etail; } else { return 0; } /* The head and tail should never be compressed */ assert(node-\u003eencoding != QUICKLIST_NODE_ENCODING_LZF); if (unlikely(QL_NODE_IS_PLAIN(node))) { if (data) *data = saver(node-\u003eentry, node-\u003esz); if (sz) *sz = node-\u003esz; quicklistDelIndex(quicklist, node, NULL); return 1; } p = lpSeek(node-\u003eentry, pos); vstr = lpGetValue(p, \u0026vlen, \u0026vlong); if (vstr) { if (data) *data = saver(vstr, vlen); if (sz) *sz = vlen; } else { if (data) *data = NULL; if (sval) *sval = vlong; } quicklistDelIndex(quicklist, node, \u0026p); return 1; } ","date":"2023-09-08","objectID":"/posts/redis_source_code/redis_source_code_06/:2:4","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 快速列表 (quicklist)","uri":"/posts/redis_source_code/redis_source_code_06/#quicklistpop"},{"categories":["中间件技术"],"content":"阅读 Redis 跳表 zskiplist 相关代码，了解 Redis 中跳表的实现。","date":"2023-08-25","objectID":"/posts/redis_source_code/redis_source_code_05/","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 跳表 (zskiplist)","uri":"/posts/redis_source_code/redis_source_code_05/"},{"categories":["中间件技术"],"content":" 1 Redis 跳表的实现Redis 中的跳表实现基于 William Pugh 的论文 Skip Lists: A Probabilistic Alternative to Balanced Trees 实现的，但做了如下修改： 允许分数 score 重复； 比较操作不仅会比较 score，还会比较成员数据（如果 score 相同的话）； 最底层链表结点有反向指针，是一个双向链表，能够支持从尾到头遍历跳表。 Redis 跳表的结构 ","date":"2023-08-25","objectID":"/posts/redis_source_code/redis_source_code_05/:1:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 跳表 (zskiplist)","uri":"/posts/redis_source_code/redis_source_code_05/#redis-跳表的实现"},{"categories":["中间件技术"],"content":" 1.1 跳表的结构定义zskiplistNode 是跳表结点的结构体： ele：存储成员字符串； score：结点的分值，当 score 相同时，会使用 ele 排序，整体是升序； backward：指向前驱结点的指针，可以实现从表尾向表头方向的遍历，一个结点只有第一层有前驱结点； level：层级数组，每个数组元素代表跳表的一层，每一层包含指向后驱结点的指针和跨度，跳表结点的层数是随机的； forward：指向后继结点，可以实现从表头向表尾方向的遍历； span：记录当前结点和后继结点之间跨越了多少个结点。 C typedef struct zskiplistNode { sds ele; double score; struct zskiplistNode *backward; struct zskiplistLevel { struct zskiplistNode *forward; unsigned long span; } level[]; } zskiplistNode; zskiplist 是跳表的结构体： header、tail 指针指向跳表的头、尾结点； length 记录跳表结点个数； level 记录跳表的层级，即目前跳表中层数最高的那个数据结点的层级，遍历的时候从这个层级开始遍历。 C typedef struct zskiplist { struct zskiplistNode *header, *tail; unsigned long length; int level; } zskiplist; zset 数据结构，在数据量较少时，使用 listpack 实现；一般情况为跳表。 zset 由一个字典和一个跳表组成： 字典结构保存成员和分数的映射关系，查询单独成员分数的时间复杂度 O(1)； 跳表结构保存存储有序的数据。 C typedef struct zset { dict *dict; zskiplist *zsl; } zset; ","date":"2023-08-25","objectID":"/posts/redis_source_code/redis_source_code_05/:1:1","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 跳表 (zskiplist)","uri":"/posts/redis_source_code/redis_source_code_05/#跳表的结构定义"},{"categories":["中间件技术"],"content":" 2 跳表 API","date":"2023-08-25","objectID":"/posts/redis_source_code/redis_source_code_05/:2:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 跳表 (zskiplist)","uri":"/posts/redis_source_code/redis_source_code_05/#跳表-api"},{"categories":["中间件技术"],"content":" 2.1 zslCreatezslCreate 创建一个空跳表。 C /* Create a new skiplist. */ zskiplist *zslCreate(void) { int j; zskiplist *zsl; zsl = zmalloc(sizeof(*zsl)); zsl-\u003elevel = 1; zsl-\u003elength = 0; // 创建哨兵结点，一个 32 层高的空结点 zsl-\u003eheader = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL); for (j = 0; j \u003c ZSKIPLIST_MAXLEVEL; j++) { zsl-\u003eheader-\u003elevel[j].forward = NULL; zsl-\u003eheader-\u003elevel[j].span = 0; } zsl-\u003eheader-\u003ebackward = NULL; zsl-\u003etail = NULL; return zsl; } ","date":"2023-08-25","objectID":"/posts/redis_source_code/redis_source_code_05/:2:1","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 跳表 (zskiplist)","uri":"/posts/redis_source_code/redis_source_code_05/#zslcreate"},{"categories":["中间件技术"],"content":" 2.2 zslCreateNodezslCreateNode 创建一个跳表结点。 C /* Create a skiplist node with the specified number of levels. * The SDS string 'ele' is referenced by the node after the call. */ zskiplistNode *zslCreateNode(int level, double score, sds ele) { zskiplistNode *zn = zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel)); zn-\u003escore = score; zn-\u003eele = ele; return zn; } ","date":"2023-08-25","objectID":"/posts/redis_source_code/redis_source_code_05/:2:2","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 跳表 (zskiplist)","uri":"/posts/redis_source_code/redis_source_code_05/#zslcreatenode"},{"categories":["中间件技术"],"content":" 2.3 zslGetRankzslGetRank 获取结点排名。结点排名 rank 是通过结点 span 跨度计算出来的。 C /* Find the rank for an element by both score and key. * Returns 0 when the element cannot be found, rank otherwise. * Note that the rank is 1-based due to the span of zsl-\u003eheader to the * first element. */ unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) { zskiplistNode *x; unsigned long rank = 0; int i; x = zsl-\u003eheader; // 从顶层开始搜索 for (i = zsl-\u003elevel-1; i \u003e= 0; i--) { while (x-\u003elevel[i].forward \u0026\u0026 (x-\u003elevel[i].forward-\u003escore \u003c score || (x-\u003elevel[i].forward-\u003escore == score \u0026\u0026 sdscmp(x-\u003elevel[i].forward-\u003eele,ele) \u003c= 0))) { // span 累加计算 rank rank += x-\u003elevel[i].span; x = x-\u003elevel[i].forward; } /* x might be equal to zsl-\u003eheader, so test if obj is non-NULL */ // 目标结点存在，返回 rank if (x-\u003eele \u0026\u0026 x-\u003escore == score \u0026\u0026 sdscmp(x-\u003eele,ele) == 0) { return rank; } } // 没有找到结点，返回 0 return 0; } ","date":"2023-08-25","objectID":"/posts/redis_source_code/redis_source_code_05/:2:3","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 跳表 (zskiplist)","uri":"/posts/redis_source_code/redis_source_code_05/#zslgetrank"},{"categories":["中间件技术"],"content":" 2.4 范围查找针对范围查找，zrangespec 结构体存储查找范围 min / max 和是否包含 min / max 的信息，并使用一些辅助函数进行范围判断： zslValueGteMin：根据 spec-\u003eminex 判断 value 是否满足下界要求； zslValueLteMax：根据 spec-\u003emaxex 判断 value 是否满足上界要求； zslIsInRange：判断跳表是否存在有在 range 范围内的结点。 C /* Struct to hold an inclusive/exclusive range spec by score comparison. */ typedef struct { double min, max; int minex, maxex; /* are min or max exclusive? */ } zrangespec; // 如果 spec-\u003eminex 成立，判断 value \u003e spec-\u003emin 否则判断 value \u003e= spec-\u003emin int zslValueGteMin(double value, zrangespec *spec) { return spec-\u003eminex ? (value \u003e spec-\u003emin) : (value \u003e= spec-\u003emin); } int zslValueLteMax(double value, zrangespec *spec) { return spec-\u003emaxex ? (value \u003c spec-\u003emax) : (value \u003c= spec-\u003emax); } /* Returns if there is a part of the zset is in range. */ int zslIsInRange(zskiplist *zsl, zrangespec *range) { zskiplistNode *x; /* Test for ranges that will always be empty. */ // range 范围非法，返回 0 if (range-\u003emin \u003e range-\u003emax || (range-\u003emin == range-\u003emax \u0026\u0026 (range-\u003eminex || range-\u003emaxex))) return 0; // 如果尾结点为空 或者 尾结点值比范围内最小值还大，返回 0 x = zsl-\u003etail; if (x == NULL || !zslValueGteMin(x-\u003escore,range)) return 0; // 如果头结点为空 或者 头结点值比范围内最大值还小，返回 0 x = zsl-\u003eheader-\u003elevel[0].forward; if (x == NULL || !zslValueLteMax(x-\u003escore,range)) return 0; return 1; } zslFirstInRange 和 zslLastInRange 两个方法分别实现了查找 range 分数范围内的第一个结点或者最后一个结点。 C /* Find the first node that is contained in the specified range. * Returns NULL when no element is contained in the range. */ // 查找跳表 zsl 在 range 范围内的第一个结点 zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) { zskiplistNode *x; int i; /* If everything is out of range, return early. */ if (!zslIsInRange(zsl,range)) return NULL; x = zsl-\u003eheader; for (i = zsl-\u003elevel-1; i \u003e= 0; i--) { /* Go forward while *OUT* of range. */ // 结点不在范围内，一直向前 while (x-\u003elevel[i].forward \u0026\u0026 !zslValueGteMin(x-\u003elevel[i].forward-\u003escore,range)) x = x-\u003elevel[i].forward; } /* This is an inner range, so the next node cannot be NULL. */ x = x-\u003elevel[0].forward; serverAssert(x != NULL); /* Check if score \u003c= max. */ if (!zslValueLteMax(x-\u003escore,range)) return NULL; return x; } /* Find the last node that is contained in the specified range. * Returns NULL when no element is contained in the range. */ // 查找跳表 zsl 在 range 范围内的最后一个结点 zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) { zskiplistNode *x; int i; /* If everything is out of range, return early. */ if (!zslIsInRange(zsl,range)) return NULL; x = zsl-\u003eheader; for (i = zsl-\u003elevel-1; i \u003e= 0; i--) { /* Go forward while *IN* range. */ // 结点在范围内，一直向前 while (x-\u003elevel[i].forward \u0026\u0026 zslValueLteMax(x-\u003elevel[i].forward-\u003escore,range)) x = x-\u003elevel[i].forward; } /* This is an inner range, so this node cannot be NULL. */ serverAssert(x != NULL); /* Check if score \u003e= min. */ if (!zslValueGteMin(x-\u003escore,range)) return NULL; return x; } ","date":"2023-08-25","objectID":"/posts/redis_source_code/redis_source_code_05/:2:4","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 跳表 (zskiplist)","uri":"/posts/redis_source_code/redis_source_code_05/#范围查找"},{"categories":["中间件技术"],"content":" 2.5 zslInsertzslInsert 向跳表中插入结点： 查找到要插入结点的位置，update 数组记录搜索路径； 创建结点，插入到对应位置； 维护每一层指针关系、跨度等信息。 C /* Insert a new node in the skiplist. Assumes the element does not already * exist (up to the caller to enforce that). The skiplist takes ownership * of the passed SDS string 'ele'. */ zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) { // updata 数组记录搜索路径 zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x; // rank 数组记录每一层 span 总和 unsigned long rank[ZSKIPLIST_MAXLEVEL]; int i, level; serverAssert(!isnan(score)); x = zsl-\u003eheader; for (i = zsl-\u003elevel-1; i \u003e= 0; i--) { /* store rank that is crossed to reach the insert position */ // 跳表最高层 rank 初始化为 0，下层 rank 初始化为上一层结果 rank[i] = i == (zsl-\u003elevel-1) ? 0 : rank[i+1]; while (x-\u003elevel[i].forward \u0026\u0026 (x-\u003elevel[i].forward-\u003escore \u003c score || (x-\u003elevel[i].forward-\u003escore == score \u0026\u0026 sdscmp(x-\u003elevel[i].forward-\u003eele,ele) \u003c 0))) { // 计算本层到插入结点位置 span 总和 rank[i] += x-\u003elevel[i].span; x = x-\u003elevel[i].forward; } // 记录每一层最接近插入结点的结点 update[i] = x; } /* we assume the element is not already inside, since we allow duplicated * scores, reinserting the same element should never happen since the * caller of zslInsert() should test in the hash table if the element is * already inside or not. */ // 生成随机 level level = zslRandomLevel(); // 如果新的层高大于跳表本身的层高，维护新层数据（rank 和 update） if (level \u003e zsl-\u003elevel) { for (i = zsl-\u003elevel; i \u003c level; i++) { rank[i] = 0; update[i] = zsl-\u003eheader; update[i]-\u003elevel[i].span = zsl-\u003elength; } zsl-\u003elevel = level; } // 创建新结点 x = zslCreateNode(level,score,ele); // 维护每一层的链表和跨度 for (i = 0; i \u003c level; i++) { x-\u003elevel[i].forward = update[i]-\u003elevel[i].forward; update[i]-\u003elevel[i].forward = x; /* update span covered by update[i] as x is inserted here */ x-\u003elevel[i].span = update[i]-\u003elevel[i].span - (rank[0] - rank[i]); update[i]-\u003elevel[i].span = (rank[0] - rank[i]) + 1; } /* increment span for untouched levels */ // 由于新增结点的原因，上层的跨度都需要加一 for (i = level; i \u003c zsl-\u003elevel; i++) { update[i]-\u003elevel[i].span++; } // 设置新结点 backward 为 update[0] // 若插入的新结点是跳表的第一个插入的结点，就指向 NULL x-\u003ebackward = (update[0] == zsl-\u003eheader) ? NULL : update[0]; if (x-\u003elevel[0].forward) // 维护后继结点的 backward 指针指向自己 x-\u003elevel[0].forward-\u003ebackward = x; else // 新结点没有后继结点，说明是链表最后一个结点，设置为跳表尾结点 zsl-\u003etail = x; // 维护跳表长度 zsl-\u003elength++; return x; } 随机生成结点层级的方法如下： 在跳表论文中，对于一个新结点我们期望晋升的概率为 50%。不过在 Redis 中，晋升概率为 25%。所以 Redis 中的跳表更加扁平化，层级相对较低，从概率上讲相当于一颗四叉树。ZSKIPLIST_P 值越大，跳表会越高，内存占用会越大，时间会越快，反之亦然。Redis 如此设置晋升概率是在空间和时间上做出权衡，避免消耗过多的内存，也能相对保证时间效率。 C #define ZSKIPLIST_MAXLEVEL 32 /* Should be enough for 2^64 elements */ #define ZSKIPLIST_P 0.25 /* Skiplist P = 1/4 */ /* Returns a random level for the new skiplist node we are going to create. * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL * (both inclusive), with a powerlaw-alike distribution where higher * levels are less likely to be returned. */ int zslRandomLevel(void) { static const int threshold = ZSKIPLIST_P*RAND_MAX; int level = 1; while (random() \u003c threshold) level += 1; return (level\u003cZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL; } ","date":"2023-08-25","objectID":"/posts/redis_source_code/redis_source_code_05/:2:5","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 跳表 (zskiplist)","uri":"/posts/redis_source_code/redis_source_code_05/#zslinsert"},{"categories":["中间件技术"],"content":" 2.6 zslDeletezslDelete 查找并删除结点： 查找到要插入结点的位置，update 数组记录搜索路径； 删除结点； 维护每一层指针关系、跨度等信息。 C /* Delete an element with matching score/element from the skiplist. * The function returns 1 if the node was found and deleted, otherwise * 0 is returned. * * If 'node' is NULL the deleted node is freed by zslFreeNode(), otherwise * it is not freed (but just unlinked) and *node is set to the node pointer, * so that it is possible for the caller to reuse the node (including the * referenced SDS string at node-\u003eele). */ int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) { zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x; int i; // 搜素删除结点位置，维护 update 数组 x = zsl-\u003eheader; for (i = zsl-\u003elevel-1; i \u003e= 0; i--) { while (x-\u003elevel[i].forward \u0026\u0026 (x-\u003elevel[i].forward-\u003escore \u003c score || (x-\u003elevel[i].forward-\u003escore == score \u0026\u0026 sdscmp(x-\u003elevel[i].forward-\u003eele,ele) \u003c 0))) { x = x-\u003elevel[i].forward; } update[i] = x; } /* We may have multiple elements with the same score, what we need * is to find the element with both the right score and object. */ // 删除结点 x = x-\u003elevel[0].forward; if (x \u0026\u0026 score == x-\u003escore \u0026\u0026 sdscmp(x-\u003eele,ele) == 0) { zslDeleteNode(zsl, x, update); // 如果 node 为 NULL 释放结点内存 // 否则将 node 指针指向需要删除的结点 if (!node) zslFreeNode(x); else *node = x; return 1; } return 0; /* not found */ } /* Internal function used by zslDelete, zslDeleteRangeByScore and * zslDeleteRangeByRank. */ void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) { int i; // 从底层到高层遍历，维护 update 数组 // update 数组指向删除结点，就维护指针和跨度 // 否则仅仅维护跨度 for (i = 0; i \u003c zsl-\u003elevel; i++) { if (update[i]-\u003elevel[i].forward == x) { update[i]-\u003elevel[i].span += x-\u003elevel[i].span - 1; update[i]-\u003elevel[i].forward = x-\u003elevel[i].forward; } else { update[i]-\u003elevel[i].span -= 1; } } if (x-\u003elevel[0].forward) { // 维护后退指针 x-\u003elevel[0].forward-\u003ebackward = x-\u003ebackward; } else { zsl-\u003etail = x-\u003ebackward; } // 更新跳表层数，如果 header-\u003eforward 没有指向结点，说明该层为空，跳表层数减一 while(zsl-\u003elevel \u003e 1 \u0026\u0026 zsl-\u003eheader-\u003elevel[zsl-\u003elevel-1].forward == NULL) zsl-\u003elevel--; // 结点数量减一 zsl-\u003elength--; } ","date":"2023-08-25","objectID":"/posts/redis_source_code/redis_source_code_05/:2:6","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 跳表 (zskiplist)","uri":"/posts/redis_source_code/redis_source_code_05/#zsldelete"},{"categories":["中间件技术"],"content":"阅读 Redis 紧凑列表 listpack 相关代码，了解 Redis 中紧凑列表的实现。","date":"2023-08-24","objectID":"/posts/redis_source_code/redis_source_code_04/","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 紧凑列表 (listpack)","uri":"/posts/redis_source_code/redis_source_code_04/"},{"categories":["中间件技术"],"content":" 1 紧凑列表的结构 紧凑列表的结构 紧凑列表更加详细的结构，可以参考 listpack 规格设计。 ","date":"2023-08-24","objectID":"/posts/redis_source_code/redis_source_code_04/:1:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 紧凑列表 (listpack)","uri":"/posts/redis_source_code/redis_source_code_04/#紧凑列表的结构"},{"categories":["中间件技术"],"content":" 1.1 紧凑列表元数据 total bytes: 32 bit 无符号整数，存储 listpack 的字节大小； num elements: 16 bit 无符号整数，存储 listpack 结点个数； listpack end byte: 一个字节，值为 0xFF。 1.1.1 紧凑列表元数据的宏定义 LP_HDR_SIZE: 表示一个 listpack header 部分的字节大小； LP_HDR_NUMELE_UNKNOWN: 因为 listpack 里记录结点数量只用了两个字节存储，最大能记录 65535 个结点。当结点个数超过了这个限制，就会将 num elements 设置为 LP_HDR_NUMELE_UNKNOWN，表示结点数量未知，真实的结点数量需要遍历 listpack 才能获取到。 lpGetTotalBytes: 从 listpack 的前四个字节里，获取 listpack 占用的字节数，时间复杂度 O(1)； lpGetNumElements：从 listpack 的第五个和第六个字节里，获取 listpack 的结点数量，时间复杂度O(1) ； lpSetTotalBytes：设置 listpack 占用的字节数； lpSetNumElements：设置 listpack 的结点数量。 C #define LP_HDR_SIZE 6 /* 32 bit total len + 16 bit number of elements. */ #define LP_HDR_NUMELE_UNKNOWN UINT16_MAX #define LP_EOF 0xFF #define lpGetTotalBytes(p) (((uint32_t)(p)[0]\u003c\u003c0) | \\ ((uint32_t)(p)[1]\u003c\u003c8) | \\ ((uint32_t)(p)[2]\u003c\u003c16) | \\ ((uint32_t)(p)[3]\u003c\u003c24)) #define lpGetNumElements(p) (((uint32_t)(p)[4]\u003c\u003c0) | \\ ((uint32_t)(p)[5]\u003c\u003c8)) #define lpSetTotalBytes(p,v) do { \\ (p)[0] = (v)\u00260xff; \\ (p)[1] = ((v)\u003e\u003e8)\u00260xff; \\ (p)[2] = ((v)\u003e\u003e16)\u00260xff; \\ (p)[3] = ((v)\u003e\u003e24)\u00260xff; \\ } while(0) #define lpSetNumElements(p,v) do { \\ (p)[4] = (v)\u00260xff; \\ (p)[5] = ((v)\u003e\u003e8)\u00260xff; \\ } while(0) ","date":"2023-08-24","objectID":"/posts/redis_source_code/redis_source_code_04/:1:1","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 紧凑列表 (listpack)","uri":"/posts/redis_source_code/redis_source_code_04/#紧凑列表元数据"},{"categories":["中间件技术"],"content":" 1.1 紧凑列表元数据 total bytes: 32 bit 无符号整数，存储 listpack 的字节大小； num elements: 16 bit 无符号整数，存储 listpack 结点个数； listpack end byte: 一个字节，值为 0xFF。 1.1.1 紧凑列表元数据的宏定义 LP_HDR_SIZE: 表示一个 listpack header 部分的字节大小； LP_HDR_NUMELE_UNKNOWN: 因为 listpack 里记录结点数量只用了两个字节存储，最大能记录 65535 个结点。当结点个数超过了这个限制，就会将 num elements 设置为 LP_HDR_NUMELE_UNKNOWN，表示结点数量未知，真实的结点数量需要遍历 listpack 才能获取到。 lpGetTotalBytes: 从 listpack 的前四个字节里，获取 listpack 占用的字节数，时间复杂度 O(1)； lpGetNumElements：从 listpack 的第五个和第六个字节里，获取 listpack 的结点数量，时间复杂度O(1) ； lpSetTotalBytes：设置 listpack 占用的字节数； lpSetNumElements：设置 listpack 的结点数量。 C #define LP_HDR_SIZE 6 /* 32 bit total len + 16 bit number of elements. */ #define LP_HDR_NUMELE_UNKNOWN UINT16_MAX #define LP_EOF 0xFF #define lpGetTotalBytes(p) (((uint32_t)(p)[0]\u003c\u003c0) | \\ ((uint32_t)(p)[1]\u003c\u003c8) | \\ ((uint32_t)(p)[2]\u003c\u003c16) | \\ ((uint32_t)(p)[3]\u003c\u003c24)) #define lpGetNumElements(p) (((uint32_t)(p)[4]\u003c\u003c0) | \\ ((uint32_t)(p)[5]\u003c\u003c8)) #define lpSetTotalBytes(p,v) do { \\ (p)[0] = (v)\u00260xff; \\ (p)[1] = ((v)\u003e\u003e8)\u00260xff; \\ (p)[2] = ((v)\u003e\u003e16)\u00260xff; \\ (p)[3] = ((v)\u003e\u003e24)\u00260xff; \\ } while(0) #define lpSetNumElements(p,v) do { \\ (p)[4] = (v)\u00260xff; \\ (p)[5] = ((v)\u003e\u003e8)\u00260xff; \\ } while(0) ","date":"2023-08-24","objectID":"/posts/redis_source_code/redis_source_code_04/:1:1","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 紧凑列表 (listpack)","uri":"/posts/redis_source_code/redis_source_code_04/#紧凑列表元数据的宏定义"},{"categories":["中间件技术"],"content":" 1.2 紧凑列表结点 encoding type: 结点数据对应的编码方式，包含编码类型、数据字节数等信息； element data: 结点实际数据内容； element total len: 记录 encoding type 和 element data 占用的字节总数，不包含自身长度，反向遍历中使用。 ","date":"2023-08-24","objectID":"/posts/redis_source_code/redis_source_code_04/:1:2","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 紧凑列表 (listpack)","uri":"/posts/redis_source_code/redis_source_code_04/#紧凑列表结点"},{"categories":["中间件技术"],"content":" 1.3 紧凑列表结点结构体每个紧凑列表存储的都是一个字符串或者整数: 当存储字符串时，sval 存储字符串数据，slen 存储字符串长度； 当存储整数时，lval 存储整数数据，sval 为 NULL。 C /* Each entry in the listpack is either a string or an integer. */ typedef struct { /* When string is used, it is provided with the length (slen). */ unsigned char *sval; uint32_t slen; /* When integer is used, 'sval' is NULL, and lval holds the value. */ long long lval; } listpackEntry; ","date":"2023-08-24","objectID":"/posts/redis_source_code/redis_source_code_04/:1:3","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 紧凑列表 (listpack)","uri":"/posts/redis_source_code/redis_source_code_04/#紧凑列表结点结构体"},{"categories":["中间件技术"],"content":" 2 紧凑列表 API","date":"2023-08-24","objectID":"/posts/redis_source_code/redis_source_code_04/:2:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 紧凑列表 (listpack)","uri":"/posts/redis_source_code/redis_source_code_04/#紧凑列表-api"},{"categories":["中间件技术"],"content":" 2.1 lpNewlpNew 创建一个空的 listpack，capacity 为申请的字节数。 C /* Create a new, empty listpack. * On success the new listpack is returned, otherwise an error is returned. * Pre-allocate at least `capacity` bytes of memory, * over-allocated memory can be shrunk by `lpShrinkToFit`. * */ unsigned char *lpNew(size_t capacity) { // 一个空的 listpack 最少需要分配 LP_HDR_SIZE+1 字节， 即 LP_HDR_SIZE + LP_EOF unsigned char *lp = lp_malloc(capacity \u003e LP_HDR_SIZE+1 ? capacity : LP_HDR_SIZE+1); if (lp == NULL) return NULL; // 设置空 listpack 的字节大小 lpSetTotalBytes(lp,LP_HDR_SIZE+1); // 设置结点个数 lpSetNumElements(lp,0); // 为 EOF 赋值 lp[LP_HDR_SIZE] = LP_EOF; return lp; } ","date":"2023-08-24","objectID":"/posts/redis_source_code/redis_source_code_04/:2:1","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 紧凑列表 (listpack)","uri":"/posts/redis_source_code/redis_source_code_04/#lpnew"},{"categories":["中间件技术"],"content":" 2.2 lpSkiplpSkip 跳过当前结点，返回下一个结点。 C /* Skip the current entry returning the next. It is invalid to call this * function if the current element is the EOF element at the end of the * listpack, however, while this function is used to implement lpNext(), * it does not return NULL when the EOF element is encountered. */ unsigned char *lpSkip(unsigned char *p) { // 获取结点大小，不包括 backlen unsigned long entrylen = lpCurrentEncodedSizeUnsafe(p); // 获取当前结点的 backlen 大小，合起来为当前结点实际占用字节数 entrylen += lpEncodeBacklen(NULL,entrylen); // 跳过当前结点 p += entrylen; return p; } ","date":"2023-08-24","objectID":"/posts/redis_source_code/redis_source_code_04/:2:2","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 紧凑列表 (listpack)","uri":"/posts/redis_source_code/redis_source_code_04/#lpskip"},{"categories":["中间件技术"],"content":" 2.3 lpNextlpNext 返回后继结点，如果已经是 listpack 的末尾，返回 NULL。 C /* If 'p' points to an element of the listpack, calling lpNext() will return * the pointer to the next element (the one on the right), or NULL if 'p' * already pointed to the last element of the listpack. */ unsigned char *lpNext(unsigned char *lp, unsigned char *p) { assert(p); p = lpSkip(p); if (p[0] == LP_EOF) return NULL; lpAssertValidEntry(lp, lpBytes(lp), p); return p; } ","date":"2023-08-24","objectID":"/posts/redis_source_code/redis_source_code_04/:2:3","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 紧凑列表 (listpack)","uri":"/posts/redis_source_code/redis_source_code_04/#lpnext"},{"categories":["中间件技术"],"content":" 2.4 lpPrevlpPrev 返回前驱结点，如果已经是 listpack 的首结点，返回 NULL。 C /* If 'p' points to an element of the listpack, calling lpPrev() will return * the pointer to the previous element (the one on the left), or NULL if 'p' * already pointed to the first element of the listpack. */ unsigned char *lpPrev(unsigned char *lp, unsigned char *p) { assert(p); // 现在 p 指向的是 listpack 的第一个结点，返回 NULL if (p-lp == LP_HDR_SIZE) return NULL; // 指向前一个结点的 backlen p--; /* Seek the first backlen byte of the last element. */ // 解析 backlen 的值，获取 encoding + content 字节数 uint64_t prevlen = lpDecodeBacklen(p); // 获得前驱结点总占用字节数 prevlen += lpEncodeBacklen(NULL,prevlen); // p 指针向前偏移 prevlen-1 个字节，指向前驱结点（之前已经向前偏移了一个字节） p -= prevlen-1; /* Seek the first byte of the previous entry. */ lpAssertValidEntry(lp, lpBytes(lp), p); return p; } ","date":"2023-08-24","objectID":"/posts/redis_source_code/redis_source_code_04/:2:4","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 紧凑列表 (listpack)","uri":"/posts/redis_source_code/redis_source_code_04/#lpprev"},{"categories":["中间件技术"],"content":" 2.5 lpLengthlpLength 获取结点数量。如果元素个数为 LP_HDR_NUMELE_UNKNOWN，会遍历整个 listpack 获取长度。 C /* Return the number of elements inside the listpack. This function attempts * to use the cached value when within range, otherwise a full scan is * needed. As a side effect of calling this function, the listpack header * could be modified, because if the count is found to be already within * the 'numele' header field range, the new value is set. */ unsigned long lpLength(unsigned char *lp) { uint32_t numele = lpGetNumElements(lp); if (numele != LP_HDR_NUMELE_UNKNOWN) return numele; /* Too many elements inside the listpack. We need to scan in order * to get the total number. */ uint32_t count = 0; unsigned char *p = lpFirst(lp); while(p) { count++; p = lpNext(lp,p); } /* If the count is again within range of the header numele field, * set it. */ if (count \u003c LP_HDR_NUMELE_UNKNOWN) lpSetNumElements(lp,count); return count; } ","date":"2023-08-24","objectID":"/posts/redis_source_code/redis_source_code_04/:2:5","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 紧凑列表 (listpack)","uri":"/posts/redis_source_code/redis_source_code_04/#lplength"},{"categories":["中间件技术"],"content":" 2.6 lpInsertlpInsert 向 listpack 中插入一个结点。 这是一个核心函数，lpPrepend、lpAppend、lpReplace、lpDelete 都是调用 lpInsert 函数，实现向前插入一个结点、向后插入一个结点、替换结点、用空替换结点（删除）等功能。 C /* Insert, delete or replace the specified string element 'elestr' of length * 'size' or integer element 'eleint' at the specified position 'p', with 'p' * being a listpack element pointer obtained with lpFirst(), lpLast(), lpNext(), * lpPrev() or lpSeek(). * * The element is inserted before, after, or replaces the element pointed * by 'p' depending on the 'where' argument, that can be LP_BEFORE, LP_AFTER * or LP_REPLACE. * * If both 'elestr' and `eleint` are NULL, the function removes the element * pointed by 'p' instead of inserting one. * If `eleint` is non-NULL, 'size' is the length of 'eleint', the function insert * or replace with a 64 bit integer, which is stored in the 'eleint' buffer. * If 'elestr` is non-NULL, 'size' is the length of 'elestr', the function insert * or replace with a string, which is stored in the 'elestr' buffer. * * Returns NULL on out of memory or when the listpack total length would exceed * the max allowed size of 2^32-1, otherwise the new pointer to the listpack * holding the new element is returned (and the old pointer passed is no longer * considered valid) * * If 'newp' is not NULL, at the end of a successful call '*newp' will be set * to the address of the element just added, so that it will be possible to * continue an interaction with lpNext() and lpPrev(). * * For deletion operations (both 'elestr' and 'eleint' set to NULL) 'newp' is * set to the next element, on the right of the deleted one, or to NULL if the * deleted element was the last one. */ unsigned char *lpInsert(unsigned char *lp, unsigned char *elestr, unsigned char *eleint, uint32_t size, unsigned char *p, int where, unsigned char **newp) { unsigned char intenc[LP_MAX_INT_ENCODING_LEN]; unsigned char backlen[LP_MAX_BACKLEN_SIZE]; uint64_t enclen; /* The length of the encoded element. */ // elestr 和 eleint 都为 NULL，则实际上是删除元素 int delete = (elestr == NULL \u0026\u0026 eleint == NULL); /* when deletion, it is conceptually replacing the element with a * zero-length element. So whatever we get passed as 'where', set * it to LP_REPLACE. */ // 删除元素就是使用 NULL 替换元素，因此设置为 LP_REPLACE if (delete) where = LP_REPLACE; /* If we need to insert after the current element, we just jump to the * next element (that could be the EOF one) and handle the case of * inserting before. So the function will actually deal with just two * cases: LP_BEFORE and LP_REPLACE. */ // 如果是 LP_AFTER 表示在当前结点后面插入元素， // 则指向当前结点的后继结点，并将 where 替换为 LP_BEFORE // 这样之后的代码只需要考虑 LP_BEFORE 和 LP_REPLACE 了。 if (where == LP_AFTER) { p = lpSkip(p); where = LP_BEFORE; ASSERT_INTEGRITY(lp, p); } /* Store the offset of the element 'p', so that we can obtain its * address again after a reallocation. */ // 记录下当前 p 在 lp 下的偏移量，这样在 listpack 内存重新分配后也能狗定位到 p unsigned long poff = p-lp; int enctype; if (elestr) { /* Calling lpEncodeGetType() results into the encoded version of the * element to be stored into 'intenc' in case it is representable as * an integer: in that case, the function returns LP_ENCODING_INT. * Otherwise if LP_ENCODING_STR is returned, we'll have to call * lpEncodeString() to actually write the encoded string on place later. * * Whatever the returned encoding is, 'enclen' is populated with the * length of the encoded element. */ // lpEncodeGetType 对插入元素内容进行编码，返回编码类型 // 编码类型为 LP_ENCODING_INT 或者 LP_ENCODING_STR // 对于 LP_ENCODING_INT 编码， encoding 会被写入到 intenc 变量中 // 无论是什么编码，都会将元素的长度 (encoding + content) 写入到 enclen 变量中 enctype = lpEncodeGetType(elestr,size,intenc,\u0026enclen); if (enctype == LP_ENCODING_INT) eleint = intenc; } else if (eleint) { enctype = LP_ENCODING_INT; enclen = size; /* 'size' is the length of the encoded integer element. */ } else { enctype = -1; enclen = 0; } /* We need to also encode the backward-parsable length of the element * and append it to the end: this allows to traverse the listpack from * the end to the start. */ // 根据","date":"2023-08-24","objectID":"/posts/redis_source_code/redis_source_code_04/:2:6","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 紧凑列表 (listpack)","uri":"/posts/redis_source_code/redis_source_code_04/#lpinsert"},{"categories":["计算机体系结构"],"content":"汇编语言 —— 包含多个段的程序","date":"2023-08-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_06/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 包含多个段的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_06/"},{"categories":["计算机体系结构"],"content":"在操作系统中，合法地通过操作系统取得的空间都是安全的。程序取得所需空间的方法有两种： 在加载程序的时候为程序分配； 在执行的过程中向系统申请（不讨论）； 我们通过在源程序中定义段来进行内存空间的获取。 ","date":"2023-08-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_06/:0:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 包含多个段的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_06/#"},{"categories":["计算机体系结构"],"content":" 1 将数据、代码、栈放入不同的段为何要将数据、代码、栈放入不同的段？ 把它们放到一个段中使程序显得混乱； 如果数据、栈和代码需要的空间超过 64KB，就不能放在一个段中(8086 模式的限制，一个段的容量不能大于 64KB)。 如下面的程序所示，这个程序将数据段定义的数据逆序存放。 text assume cs:code, ds:data, ss:stack data segment dw 0123h, 0456h, 0789h, Oabch, Odefh, Ofedh, Ocbah, 0987h data ends stack segment dw 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 stack ends code segment start: mov ax,stack mov ss,ax mov sp,20h ; 设置栈顶 ss:sp 指向 stack:20 mov ax,data mov ds,ax ; ds 指向 data 段 mov bx, O ; ds:bx 指向 data 段中的第一个单元 mov cx,8 s: push [bx] add bx,2 loop s mov bx,O mov cx,8 sO: pop [bx] add bx,2 loop sO mov ax,4c00h int 21h code ends end start ; 指明程序入口为 start，程序加载进内存后，CS:IP 指向该入口 ","date":"2023-08-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_06/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 包含多个段的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_06/#将数据代码栈放入不同的段"},{"categories":["计算机体系结构"],"content":" 1.1 定义多个段的方法从代码中可看出，定义多个段只需要对每个段定义不同的段名即可。 ","date":"2023-08-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_06/:1:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 包含多个段的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_06/#定义多个段的方法"},{"categories":["计算机体系结构"],"content":" 1.2 对段地址的引用代码片段：mov ax,stack 和 mov ax,data 都是将名称为 stack 或 data 的段地址送入寄存器 ax。程序中对段名的引用，会被编译器处理为一个表示段地址的数值。 ","date":"2023-08-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_06/:1:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 包含多个段的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_06/#对段地址的引用"},{"categories":["计算机体系结构"],"content":" 1.3 “代码段”、“数据段”、“栈段”完全是我们的安排在上述程序中，定义了三个段，“code”、“data”和“stack”，我们分别安排它们存放代码、数据和栈。这是我们人为的安排： 我们在源程序中为这三个段起了具有含义的名称，数据段“data” ，代码段“code” ，栈段\"stack\"。但如此命名后 CPU 并不会去执行“code”段中的内容，处理“data”段中的数据，将“stack”当做栈。 伪指令：assume cs:code, ds:data, ss:stack 将cs、ds 和 ss 分别和 code、data、stack 段相连。但 CPU 不会将 cs 指向 code，ds 指向 data, ss 指向 stack，从而按照我们的意图来处理这些段，因为 assume 是伪指令，是由编译器执行的，CPU 并不知道这些伪指令。 若要让 CPU 按照我们的安排行事，需要用机器指令控制它，源程序中只有汇编指令是 CPU 要执行的内容。因此为了将 stack 段作为栈使用，需要设置 ss:sp 指向 stack:20。为了将 data 作为数据段，需要设置 ds 指向 data，用 bx 存放 data 段的偏移地址。 总之，CPU 到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对 CS:IP、SS:SP、DS 等寄存器的设置来决定的。 ","date":"2023-08-23","objectID":"/posts/computer_architecture/assemply_language/assemply_language_06/:1:3","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 包含多个段的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_06/#代码段数据段栈段完全是我们的安排"},{"categories":["中间件技术"],"content":"阅读 Redis 字典 dict 相关代码，了解 Redis 中字典的实现。","date":"2023-08-21","objectID":"/posts/redis_source_code/redis_source_code_03/","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 字典 (dict)","uri":"/posts/redis_source_code/redis_source_code_03/"},{"categories":["中间件技术"],"content":" 1 字典结构定义","date":"2023-08-21","objectID":"/posts/redis_source_code/redis_source_code_03/:1:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 字典 (dict)","uri":"/posts/redis_source_code/redis_source_code_03/#字典结构定义"},{"categories":["中间件技术"],"content":" 1.1 哈希表 dict C struct dict { // 指向字典类型的指针 dictType *type; // 一个包含两个哈希表的数组， (dictEntry **) 指向一个哈希表 dictEntry **ht_table[2]; // 哈希表的节点数量 unsigned long ht_used[2]; // 记录 rehash 的进度 long rehashidx; /* rehashing not in progress if rehashidx == -1 */ /* Keep small vars at end for optimal (minimal) struct padding */ // 记录 rehash 暂停 int16_t pauserehash; /* If \u003e0 rehashing is paused (\u003c0 indicates coding error) */ signed char ht_size_exp[2]; /* exponent of size. (size = 1\u003c\u003cexp) */ void *metadata[]; /* An arbitrary number of bytes (starting at a * pointer-aligned address) of size as defined * by dictType's dictEntryBytes. */ }; ","date":"2023-08-21","objectID":"/posts/redis_source_code/redis_source_code_03/:1:1","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 字典 (dict)","uri":"/posts/redis_source_code/redis_source_code_03/#哈希表-dict"},{"categories":["中间件技术"],"content":" 1.2 哈希表结点 dictEntry C struct dictEntry { void *key; union { void *val; uint64_t u64; int64_t s64; double d; } v; // 指向下一个 dictEntry 的 next 指针，当发生哈希冲突时，使用的链表法串成一个链表 struct dictEntry *next; /* Next entry in the same hash bucket. */ // 任意数量的字节（从指针对齐的地址开始），其大小由 dictType 的 dictEntryMetadataBytes() 返回。 void *metadata[]; /* An arbitrary number of bytes (starting at a * pointer-aligned address) of size as returned * by dictType's dictEntryMetadataBytes(). */ }; typedef struct { void *key; dictEntry *next; } dictEntryNoValue; ","date":"2023-08-21","objectID":"/posts/redis_source_code/redis_source_code_03/:1:2","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 字典 (dict)","uri":"/posts/redis_source_code/redis_source_code_03/#哈希表结点-dictentry"},{"categories":["中间件技术"],"content":" 1.3 字典类型 dictType C typedef struct dictType { // 哈希方法 uint64_t (*hashFunction)(const void *key); // key 拷贝方法 void *(*keyDup)(dict *d, const void *key); // value 拷贝方法 void *(*valDup)(dict *d, const void *obj); // key 比较函数 int (*keyCompare)(dict *d, const void *key1, const void *key2); // key 析构方法 void (*keyDestructor)(dict *d, void *key); // value 析构方法 void (*valDestructor)(dict *d, void *obj); // int (*expandAllowed)(size_t moreMem, double usedRatio); /* Flags */ /* The 'no_value' flag, if set, indicates that values are not used, i.e. the * dict is a set. When this flag is set, it's not possible to access the * value of a dictEntry and it's also impossible to use dictSetKey(). Entry * metadata can also not be used. */ unsigned int no_value:1; /* If no_value = 1 and all keys are odd (LSB=1), setting keys_are_odd = 1 * enables one more optimization: to store a key without an allocated * dictEntry. */ unsigned int keys_are_odd:1; /* TODO: Add a 'keys_are_even' flag and use a similar optimization if that * flag is set. */ /* Allow each dict and dictEntry to carry extra caller-defined metadata. The * extra memory is initialized to 0 when allocated. */ size_t (*dictEntryMetadataBytes)(dict *d); size_t (*dictMetadataBytes)(void); /* Optional callback called after an entry has been reallocated (due to * active defrag). Only called if the entry has metadata. */ void (*afterReplaceEntry)(dict *d, dictEntry *entry); } dictType; ","date":"2023-08-21","objectID":"/posts/redis_source_code/redis_source_code_03/:1:3","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 字典 (dict)","uri":"/posts/redis_source_code/redis_source_code_03/#字典类型-dicttype"},{"categories":["中间件技术"],"content":" 2 字典内存结构// TODO 内存结构图 ","date":"2023-08-21","objectID":"/posts/redis_source_code/redis_source_code_03/:2:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 字典 (dict)","uri":"/posts/redis_source_code/redis_source_code_03/#字典内存结构"},{"categories":["中间件技术"],"content":"阅读 Redis 链表 adlist 相关代码，了解 Redis 中链表的实现。","date":"2023-08-15","objectID":"/posts/redis_source_code/redis_source_code_02/","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 链表 (adlist)","uri":"/posts/redis_source_code/redis_source_code_02/"},{"categories":["中间件技术"],"content":" 1 链表的结构Redis 中链表的结构是这样的：一个 list 结构存储链表的元数据，每个链表结点 listNode 之间通过指针相连，head 与 tail 分别指向链表的头结点和尾结点。 链表的结构 ","date":"2023-08-15","objectID":"/posts/redis_source_code/redis_source_code_02/:1:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 链表 (adlist)","uri":"/posts/redis_source_code/redis_source_code_02/#链表的结构"},{"categories":["中间件技术"],"content":" 2 链表结构定义","date":"2023-08-15","objectID":"/posts/redis_source_code/redis_source_code_02/:2:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 链表 (adlist)","uri":"/posts/redis_source_code/redis_source_code_02/#链表结构定义"},{"categories":["中间件技术"],"content":" 2.1 listNode链表结点 listNode，包含一个前驱结点指针，一个后继结点指针，和一个 void * 指针指向具体的元素。 C typedef struct listNode { // 前驱结点指针 struct listNode *prev; // 后继结点指针 struct listNode *next; // 指向具体元素 void *value; } listNode; ","date":"2023-08-15","objectID":"/posts/redis_source_code/redis_source_code_02/:2:1","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 链表 (adlist)","uri":"/posts/redis_source_code/redis_source_code_02/#listnode"},{"categories":["中间件技术"],"content":" 2.2 listIter链表迭代器 listIter 包含一个指向下一个结点的指针，和遍历方向。 C /* Directions for iterators */ #define AL_START_HEAD 0 #define AL_START_TAIL 1 typedef struct listIter { // 指向下一个结点的指针 listNode *next; // 遍历方向，从头开始还是从尾开始 int direction; } listIter; ","date":"2023-08-15","objectID":"/posts/redis_source_code/redis_source_code_02/:2:2","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 链表 (adlist)","uri":"/posts/redis_source_code/redis_source_code_02/#listiter"},{"categories":["中间件技术"],"content":" 2.3 listlist 结构使用 dup/free/match 函数指针实现多态。不同类型的链表里的链表结点是不同的，多态的使用使得链表能够根据不同的链表结点自定义链表的 dup/free/match 操作。 C typedef struct list { // 链表头结点 listNode *head; // 链表尾结点 listNode *tail; // 链表可以自定义 复制/释放/比较 函数 void *(*dup)(void *ptr); void (*free)(void *ptr); int (*match)(void *ptr, void *key); // 链表结点数量 unsigned long len; } list; 比如在 slowlog 模块中，使用 listSetFreeMethod 设置链表的 free 函数为 slowlogFreeEntry 来释放 slowlog 结点的内存。 C /* Free a slow log entry. The argument is void so that the prototype of this * function matches the one of the 'free' method of adlist.c. * * This function will take care to release all the retained object. */ void slowlogFreeEntry(void *septr) { slowlogEntry *se = septr; int j; for (j = 0; j \u003c se-\u003eargc; j++) decrRefCount(se-\u003eargv[j]); zfree(se-\u003eargv); sdsfree(se-\u003epeerid); sdsfree(se-\u003ecname); zfree(se); } /* Initialize the slow log. This function should be called a single time * at server startup. */ void slowlogInit(void) { server.slowlog = listCreate(); server.slowlog_entry_id = 0; listSetFreeMethod(server.slowlog,slowlogFreeEntry); } ","date":"2023-08-15","objectID":"/posts/redis_source_code/redis_source_code_02/:2:3","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 链表 (adlist)","uri":"/posts/redis_source_code/redis_source_code_02/#list"},{"categories":["中间件技术"],"content":" 3 应用 服务端使用链表来保存所有连接的客户端，连接的从库客户端等。如 server.clients 、server.slaves 慢查询 slowlog 使用链表来存储慢查询条目。server.slowlog ","date":"2023-08-15","objectID":"/posts/redis_source_code/redis_source_code_02/:3:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 链表 (adlist)","uri":"/posts/redis_source_code/redis_source_code_02/#应用"},{"categories":["计算机体系结构"],"content":"汇编语言 —— [BX]和loop指令","date":"2023-08-11","objectID":"/posts/computer_architecture/assemply_language/assemply_language_05/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— [BX]和loop指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_05/"},{"categories":["计算机体系结构"],"content":" 1 [BX]指令 mov ax, [bx] 的功能：bx 中存放的数据作为一个偏移地址 EA，段地址 SA 默认在 ds 中，将 SA:EA 处的数据送入 ax 中。即: (ax)=((ds)*16+(bx))。 指令 mov [bx], ax 的功能：bx 中存放的数据作为一个偏移地址 EA，段地址 SA 默认在 ds 中，将 ax 中的 数据送入内存 SA:EA 处。即: ((ds)*16+(6x))=(ax)。 ","date":"2023-08-11","objectID":"/posts/computer_architecture/assemply_language/assemply_language_05/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— [BX]和loop指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_05/#bx"},{"categories":["计算机体系结构"],"content":" 2 Loop 指令CPU 执行 loop 指令的时候，要进行两步操作： (cx) = (cx) - 1； 判断 cx 中的值，不为零则转至标号执行程序，如果为零则向下执行。 通常我们用 loop 指令来实现循环功能，cx 中存放循环次数。 使用 cx 和 loop 指令配合实现循环功能的要点： 在 cx 中存放循环次数； loop 指令中的标号所标识的地址在前面； 要循环执行的程序段，要写在标号和 loop 指令的中间。 用 cx 和 loop 指令相配合实现循环功能的程序框架如下： text mov cx, 循环次数 s: 循环执行的程序段 loop s 标号 “s” 实际是一个地址，如果在执行 “loop s” 时，cx 减 1 后不为 0，指令 “loop s” 就会把 IP 设置为 “s” 指向的地址，从而使 CS:IP 指向循环执行的程序段。 ","date":"2023-08-11","objectID":"/posts/computer_architecture/assemply_language/assemply_language_05/:2:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— [BX]和loop指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_05/#loop-指令"},{"categories":["计算机体系结构"],"content":" 3 Loop 和 [bx] 的联合应用 问题 编程目标：计算 ffff:0~ffff:b 单元中的数据的和，结果存储在 dx 中。 分析问题： 运算后的结果是否会超出 dx 所能存储的范围? 能否将 ffff:0~ffff:b 中的数据直接累加到 dx 中? 能否将 ffff:0~ffff:b 中的数据累加到 dl 中，并设置 (dh)=0，从而实现累加到 dx 中? 问题解答： ffff:0~ffff:b 内存単元中的数据是字节型数据，范围在 0~255 之间，12 个这样的数据相加，结果不会大于 65535，可以在dx中存放下； ffff:0~ffff:b 中的数据是 8 位的，不能直接加到 16 位寄存器 dx 中； 不行，因为 dl 是 8 位寄存器，能容纳的数据的范围在 0~ 255 之间，ffff:0~ffff:b 中的数据也都是 8 位，如果仅向 dl 中累加 12 个 8 位数据，很有可能造成进位丢失。 编程思路：用一个 16 位寄存器来做中介。将内存单元中的 8 位数据赋值到一个 16 位寄存器 ax 中，再将 ax 中的数据加到 dx 上，从而使两个运算对象的类型匹配并且结果不会超界。 text assume cs:code code segment mov ax, 0ffffh mov ds, ax mov bx, 0 ; 初始化 ds:bx 指向 ffff:0 mov dx, 0 ; 初始化累加寄存器 dx， (dx)=0 mov cx, 12 ; 初始化循环计数寄存器 cx, (cx)=12 s: mov al, [bx] mov ah, 0 add dx, ax ; 间接向 dx 中加上 ((ds)*16+(bx)) 单元的数值 inc bx ; ds:bx 指向下一个单元 loop s mov ax, 4c00h int 21h code ends end ","date":"2023-08-11","objectID":"/posts/computer_architecture/assemply_language/assemply_language_05/:3:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— [BX]和loop指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_05/#loop-和-bx-的联合应用"},{"categories":["计算机体系结构"],"content":" 4 段前缀指令 mov ax, [bx] 中，内存单元的偏移地址由 bx 给出，而段地址默认在 ds 中。我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。比如： mov ax,ds:[bx] mov ax,cs:[bx] mov ax,ss:[bx] mov ax,es:[bx] mov ax,ss:[0] mov ax,cs:[0] … 这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的 “ds:” “cs:” “ss:” “es:〞，在汇编语言中称为段前缀。 ","date":"2023-08-11","objectID":"/posts/computer_architecture/assemply_language/assemply_language_05/:4:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— [BX]和loop指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_05/#段前缀"},{"categories":["计算机体系结构"],"content":" 4.1 一段安全的空间在 8086 模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据或代码。 DOS 方式下， 一般情况，0:200~0:2ff 空间中没有系统或其他程序的数据或代码，以后，我们需要直接向一段内存中写入内容时，就使用 0:200~0:2ff 这段空间。 ","date":"2023-08-11","objectID":"/posts/computer_architecture/assemply_language/assemply_language_05/:4:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— [BX]和loop指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_05/#一段安全的空间"},{"categories":["计算机体系结构"],"content":" 4.2 段前缀的使用编程目标：将内存 ffff:0~ffff:b 单元中的数据复制到 0:200~0:20b 单元中。 问题：如何指定 0:200~0:20b 的段地址？ 使用 0020:0~0020:b 来描述 0:200~0:20b，它们描述的是同一段内存空间。 因为源始单元 ffff:X 和目标单元 0020:X 的偏移地址 X 是变量，将 0:200~0:20b 用 0020:0~0020:b 描述，就是为了使目标单元的偏移地址和源始单元的偏移地址从同一数值又开始。 text assume cs:code code segment mov ax, 0ffffh mov ds, ax ; (ds)=0ffffh mov ax, 20h mov es, ax ; (es)=0020h mov bx, 0 ; (bx)=0，此时 ds:bx 指向 ffff:0，es:bx 指向0020:0 mov cx, 12 ; (cx)=12，循环12次 s: mov dl, [bx] ; (dl)=((ds)*16+(bx))，将 ffff:bx 中的数据送入 dl mov es:[bx], dl ; ((es)*16+(bx))=(dl)，将 dl 中的数据送入 0020:bx inc bx ; (bx)=(bx)+1 loop s mov ax, 4c00h int 21h code ends end 因源始单元 ffff:X 和目标单元 0020:X 相距大于64KB，在不同的 64KB 段里。因此使用 es 存放目标空间 0020:0~0020:b 的段地址，用 ds 存放源始空间 ffff:0~ffff:b 的段地址。 ","date":"2023-08-11","objectID":"/posts/computer_architecture/assemply_language/assemply_language_05/:4:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— [BX]和loop指令","uri":"/posts/computer_architecture/assemply_language/assemply_language_05/#段前缀的使用"},{"categories":["数据结构与算法"],"content":"排序算法的应用","date":"2023-08-09","objectID":"/posts/algs4/algs4_10/","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 排序算法应用","uri":"/posts/algs4/algs4_10/"},{"categories":["数据结构与算法"],"content":"排序有用的一个主要原因是，在一个有序的数组中查找一个元素要比在一个无序的数组中查找简单得多。 ","date":"2023-08-09","objectID":"/posts/algs4/algs4_10/:0:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 排序算法应用","uri":"/posts/algs4/algs4_10/#"},{"categories":["数据结构与算法"],"content":" 1 应该使用哪种排序算法 算法 是否稳定 是否为原地排序 时间复杂度 空间复杂度 选择排序 否 是 N^2 1 插入排序 是 是 介于 N 和 N^2 之间 1 希尔排序 否 是 NlogN? N^1.2? 1 快速排序 否 是 NlogN 1 三向快速排序 否 是 介于 N 和 NlogN 之间 1 归并排序 是 否 NlogN N 堆排序 否 是 NlogN 1 插入排序的效率取决于输入元素的排列情况。 快速排序的运行效率由概率提供保证。三向快速排序的运行效率由概率保证，同时也取决于输入元素的分布情况。 快速排序是最快的通用排序算法。在大多数实际情况中，快速排序是最佳选择。 ","date":"2023-08-09","objectID":"/posts/algs4/algs4_10/:1:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 排序算法应用","uri":"/posts/algs4/algs4_10/#应该使用哪种排序算法"},{"categories":["数据结构与算法"],"content":" 1.1 Java 系统库的排序算法Java 系统库的排序方法 java.util.Arrays.sort() 根据不同的参数类型，代表了一系列的排序算法： 每种原始数据类型都有一个不同的排序方法； 一个适用于所有实现了 Comparable 接口的数据类型的排序方法； 一个适用于实现了比较器 Comparator 的数据类型的排序方法。 对于原始数据类型，系统库使用三向切分的快速排序，牺牲稳定性换取速度和空间；对引用类型使用归并排序，牺牲速度和空间换取稳定性。 ","date":"2023-08-09","objectID":"/posts/algs4/algs4_10/:1:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 排序算法应用","uri":"/posts/algs4/algs4_10/#java-系统库的排序算法"},{"categories":["数据结构与算法"],"content":" 2 问题的归约归约指的是为解决某个问题而发明的算法正好可以用来解决另一种问题。每次用解决问题 B 的方法来解决问题 A 时，就是在将 A 归约为 B。 很多问题的第一想法往往是平方级别的暴力破解。但很多情况下如果先将数据排序，那么解决剩下的问题之需要线性级别的时间了。 以下问题可以归约为排序： 找出重复元素，可以先排序后再遍历数组； 排列、排名问题，比如计算两个排列之间的 Kendall tau 距离； 归约为优先队列，找到输入流中 M 个最大元素，或者将 M 个有序输入流合并为一个有序输入流； 查找一组元素的中位数，可以归约为找到一组数的第 k 小的元素，并使用快速排序的 partition 解决。 ","date":"2023-08-09","objectID":"/posts/algs4/algs4_10/:2:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 排序算法应用","uri":"/posts/algs4/algs4_10/#问题的归约"},{"categories":["计算机体系结构"],"content":"汇编语言 —— 第一个完整的程序","date":"2023-08-06","objectID":"/posts/computer_architecture/assemply_language/assemply_language_04/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 第一个完整的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_04/"},{"categories":["计算机体系结构"],"content":" 1 一个源程序从写出到执行的过程一个汇编语言程序从写出到最终执行的简要过程如下： 编写汇编源程序，生成源程序文件 对源程序进行编译连接，生成可执行文件 在操作系统中，执行可执行文件中的程序 汇编语言程序从写出到执行的过程 ","date":"2023-08-06","objectID":"/posts/computer_architecture/assemply_language/assemply_language_04/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 第一个完整的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_04/#一个源程序从写出到执行的过程"},{"categories":["计算机体系结构"],"content":" 2 一个源程序一段简单的汇编语言源程序： text assume cs:codesg ; 将用作代码段的段 codesg 和 CPU 中的段寄存器 cs 联系起来 codesg segment ; 定义一个段，段的名称为 “codesg”，这个段从此开始 mov ax, 0123H mov bx, 0456H add ax, bx add ax, ax mov ax, 4c00H ; 程序返回 int 21H codesg ends ; 名称为 “codesg” 的段到此结束 end ","date":"2023-08-06","objectID":"/posts/computer_architecture/assemply_language/assemply_language_04/:2:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 第一个完整的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_04/#一个源程序"},{"categories":["计算机体系结构"],"content":" 2.1 伪指令在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。 伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。 2.1.1 segment endssegment 和 ends 是一对成对使用的伪指令。功能是定义一个段，segment 说明一个段开始，ends 说明一个段结束。 一个汇编程序是由多个段组成的，这些段被用来存放代码、 数据或当作栈空问来使用。一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。 2.1.2 endend 是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。 2.1.3 assume编译程序可以将段寄存器和某一个具体的段相联系。 使用 assume 指令可以一段寄存器和程序中的某一个用 segment..ends 定义的段相关联。 ","date":"2023-08-06","objectID":"/posts/computer_architecture/assemply_language/assemply_language_04/:2:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 第一个完整的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_04/#伪指令"},{"categories":["计算机体系结构"],"content":" 2.1 伪指令在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。 伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。 2.1.1 segment endssegment 和 ends 是一对成对使用的伪指令。功能是定义一个段，segment 说明一个段开始，ends 说明一个段结束。 一个汇编程序是由多个段组成的，这些段被用来存放代码、 数据或当作栈空问来使用。一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。 2.1.2 endend 是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。 2.1.3 assume编译程序可以将段寄存器和某一个具体的段相联系。 使用 assume 指令可以一段寄存器和程序中的某一个用 segment..ends 定义的段相关联。 ","date":"2023-08-06","objectID":"/posts/computer_architecture/assemply_language/assemply_language_04/:2:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 第一个完整的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_04/#segment-ends"},{"categories":["计算机体系结构"],"content":" 2.1 伪指令在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。 伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。 2.1.1 segment endssegment 和 ends 是一对成对使用的伪指令。功能是定义一个段，segment 说明一个段开始，ends 说明一个段结束。 一个汇编程序是由多个段组成的，这些段被用来存放代码、 数据或当作栈空问来使用。一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。 2.1.2 endend 是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。 2.1.3 assume编译程序可以将段寄存器和某一个具体的段相联系。 使用 assume 指令可以一段寄存器和程序中的某一个用 segment..ends 定义的段相关联。 ","date":"2023-08-06","objectID":"/posts/computer_architecture/assemply_language/assemply_language_04/:2:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 第一个完整的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_04/#end"},{"categories":["计算机体系结构"],"content":" 2.1 伪指令在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。 伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。 2.1.1 segment endssegment 和 ends 是一对成对使用的伪指令。功能是定义一个段，segment 说明一个段开始，ends 说明一个段结束。 一个汇编程序是由多个段组成的，这些段被用来存放代码、 数据或当作栈空问来使用。一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。 2.1.2 endend 是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。 2.1.3 assume编译程序可以将段寄存器和某一个具体的段相联系。 使用 assume 指令可以一段寄存器和程序中的某一个用 segment..ends 定义的段相关联。 ","date":"2023-08-06","objectID":"/posts/computer_architecture/assemply_language/assemply_language_04/:2:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 第一个完整的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_04/#assume"},{"categories":["计算机体系结构"],"content":" 2.2 源程序中的“程序”源程序中最终由计算机执行、处理的指令或数据，称为程序。程序最先以汇编指令的形式存在源程序中，经编译、 连接后转变为机器码，存储在可执行文件中。 源程序经过编译连接之后称为机器吗 ","date":"2023-08-06","objectID":"/posts/computer_architecture/assemply_language/assemply_language_04/:2:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 第一个完整的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_04/#源程序中的程序"},{"categories":["计算机体系结构"],"content":" 2.3 标号汇编源程序中，除了汇编指令和伪指令外，还有一些标号，比如 “codesg”。一个标号指代了一个地址。 “codesg” 这个标号是代码段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。 ","date":"2023-08-06","objectID":"/posts/computer_architecture/assemply_language/assemply_language_04/:2:3","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 第一个完整的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_04/#标号"},{"categories":["计算机体系结构"],"content":" 2.4 程序返回一个程序 P2 在可执行文件中，则必须有一个正在运行的程序 P1，将 P2 从可执行文件中加载入内存后，将 CPU 的控制权交给 P2，P2 才能得以运行。P2 开始运行后，P1 暂停运行。 而当 P2 运行完毕后，应该将 CPU 的控制权交还给使它得以运行的程序 P1，此后， P1 继续运行。 一个程序结束后，将 CPU 的控制权交还给使它得以运行的程序，我们称这个过程为：程序返回。 总结一下与结束相关的指令： 目的 相关指令 指令性质 指令执行者 通知编译器一个段结束 段名 ends 伪 指 令 编译时，由编译器执行 通知编译器程序结束 end 伪 指 令 编译时，由编译器执行 程序返回 mov ax,4c00H int 21H 汇编指令 执行时，由 CPU 执行 ","date":"2023-08-06","objectID":"/posts/computer_architecture/assemply_language/assemply_language_04/:2:4","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 第一个完整的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_04/#程序返回"},{"categories":["计算机体系结构"],"content":" 3 编译连接编译的作用是通过源程序文件生成包含机器代码的目标文件(.obj 文件)。 连接的作用如下： 当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行 文件; 程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件; 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件(.exe 文件)。 ","date":"2023-08-06","objectID":"/posts/computer_architecture/assemply_language/assemply_language_04/:3:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 第一个完整的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_04/#编译连接"},{"categories":["计算机体系结构"],"content":" 4 执行DOS 中有一个程序 command.com，这个程序在 DOS 中称为命令解释器，也就是 DOS 系统的 shell。 如果用户要执行一个程序，则输入该程序的可执行文件的名称，command 首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置 CS:IP 指向程序的入口。此后，command 暂停运行，CPU 运行程序。程序运行结束后，返回到 command 中，command 再次显示由当前盘符和当前路径组成的提示符，等待用户的输入。 ","date":"2023-08-06","objectID":"/posts/computer_architecture/assemply_language/assemply_language_04/:4:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 第一个完整的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_04/#执行"},{"categories":["计算机体系结构"],"content":" 4.1 程序的加载过程Debug 将程序从可执行文件载入内存后，各个内存器的设置情况入下图： 程序加载后各个寄存器的设置情况 DOS 系统中 EXE 文件中的程序的加载过程入下图： EXE 文件中程序的加载过程 程序从可执行文件加载入内存后，cx 中存放程序的长度； ds 中存放着程序所在内存区的段地址，这个内存区的偏移地址为 0，则程序所在的内存区的地址为 ds:0； 这个内存区的前 256 个字节中存放的是 PSP，DOS 用来和程序进行通信。从 256 字节处向后的空间存放的是程序； cs:ip 指向程序的第一条指令。 ","date":"2023-08-06","objectID":"/posts/computer_architecture/assemply_language/assemply_language_04/:4:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 第一个完整的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_04/#程序的加载过程"},{"categories":["计算机体系结构"],"content":" 5 汇编程序从写出到执行的过程到此，完成了一个汇编程序从写出到执行的全部过程。 汇编程序从写出到执行的过程 ","date":"2023-08-06","objectID":"/posts/computer_architecture/assemply_language/assemply_language_04/:5:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 第一个完整的程序","uri":"/posts/computer_architecture/assemply_language/assemply_language_04/#汇编程序从写出到执行的过程"},{"categories":["数据结构与算法"],"content":"优先队列","date":"2023-08-04","objectID":"/posts/algs4/algs4_09/","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 优先队列","uri":"/posts/algs4/algs4_09/"},{"categories":["数据结构与算法"],"content":" 1 基本优先队列","date":"2023-08-04","objectID":"/posts/algs4/algs4_09/:1:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 优先队列","uri":"/posts/algs4/algs4_09/#基本优先队列"},{"categories":["数据结构与算法"],"content":" 1.1 优先队列 API优先队列最重要的操作是删除最大元素和插入元素。 Text 泛型优先队列的 API public class MaxPQ\u003cKey extends Comparable\u003cKey\u003e\u003e MaxPQ() 创建一个优先队列 MaxPQ(int max) 创建一个初始容量为 max 的优先队列 MaxPQ(Key a) 用 a[] 中的元素创建一个优先队列 void insert(Key v) 向优先队列中插入一个元素 Key max() 返回最大元素 Key delMax() 删除并返回最大元素 boolean isEmpty() 返回队列是否为空 int size() 返回优先队列中的元素个数 ","date":"2023-08-04","objectID":"/posts/algs4/algs4_09/:1:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 优先队列","uri":"/posts/algs4/algs4_09/#优先队列-api"},{"categories":["数据结构与算法"],"content":" 1.2 优先队列的基本实现数据结构二叉堆能够很好地实现优先队列的基本操作。 1.2.1 堆的定义与表示二叉堆：一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）。 堆有序：当一颗二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。 堆的表示 1.2.2 堆的算法优先队列由一个基于堆的完全二叉树表示，存储于数组 pq[1..N] 中，pq[0] 没有使用。 在 insert 中，将 n 加一并把新元素添加在数组最后，然后用 swim 保证堆有序。 在 delMax 中，从 pq[1] 中得到需要返回的元素，然后将 pq[N] 移动到 pq[1]，将 N 减一并用 sink 保证堆有序。 Java public class MaxPQ\u003cKey extends Comparable\u003cKey\u003e\u003e { private Key[] pq; // store items at indices 1 to n private int n; // number of items on priority queue public MaxPQ() { this(1); } public MaxPQ(int initCapacity) { pq = (Key[]) new Object[initCapacity + 1]; n = 0; } public MaxPQ(Key[] keys) { n = keys.length; pq = (Key[]) new Object[keys.length + 1]; for (int i = 0; i \u003c n; i++) pq[i + 1] = keys[i]; for (int k = n / 2; k \u003e= 1; k--) sink(k); } public void insert(Key x) { // double size of array if necessary if (n == pq.length - 1) resize(2 * pq.length); // add x, and percolate it up to maintain heap invariant pq[++n] = x; swim(n); } public Key max() { if (isEmpty()) throw new NoSuchElementException(\"Priority queue underflow\"); return pq[1]; } public Key delMax() { if (isEmpty()) throw new NoSuchElementException(\"Priority queue underflow\"); Key max = pq[1]; exch(1, n--); sink(1); pq[n + 1] = null; // to avoid loitering and help with garbage collection if ((n \u003e 0) \u0026\u0026 (n == (pq.length - 1) / 4)) resize(pq.length / 2); return max; } public boolean isEmpty() { return n == 0; } public int size() { return n; } private void resize(int capacity) { assert capacity \u003e n; Key[] temp = (Key[]) new Object[capacity]; for (int i = 1; i \u003c= n; i++) { temp[i] = pq[i]; } pq = temp; } /*************************************************************************** * Helper functions to restore the heap invariant. ***************************************************************************/ private void swim(int k) { while (k \u003e 1 \u0026\u0026 less(k / 2, k)) { exch(k / 2, k); k = k / 2; } } private void sink(int k) { while (2 * k \u003c= n) { int j = 2 * k; if (j \u003c n \u0026\u0026 less(j, j + 1)) j++; if (!less(k, j)) break; exch(k, j); k = j; } } /*************************************************************************** * Helper functions for compares and swaps. ***************************************************************************/ private boolean less(int v, int w) { return pq[v].compareTo(pq[w]) \u003c 0; } private void exch(int v, int w) { Key swap = pq[v]; pq[v] = pq[w]; pq[w] = swap; } } ","date":"2023-08-04","objectID":"/posts/algs4/algs4_09/:1:2","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 优先队列","uri":"/posts/algs4/algs4_09/#优先队列的基本实现"},{"categories":["数据结构与算法"],"content":" 1.2 优先队列的基本实现数据结构二叉堆能够很好地实现优先队列的基本操作。 1.2.1 堆的定义与表示二叉堆：一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）。 堆有序：当一颗二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。 堆的表示 1.2.2 堆的算法优先队列由一个基于堆的完全二叉树表示，存储于数组 pq[1..N] 中，pq[0] 没有使用。 在 insert 中，将 n 加一并把新元素添加在数组最后，然后用 swim 保证堆有序。 在 delMax 中，从 pq[1] 中得到需要返回的元素，然后将 pq[N] 移动到 pq[1]，将 N 减一并用 sink 保证堆有序。 Java public class MaxPQ","date":"2023-08-04","objectID":"/posts/algs4/algs4_09/:1:2","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 优先队列","uri":"/posts/algs4/algs4_09/#堆的定义与表示"},{"categories":["数据结构与算法"],"content":" 1.2 优先队列的基本实现数据结构二叉堆能够很好地实现优先队列的基本操作。 1.2.1 堆的定义与表示二叉堆：一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）。 堆有序：当一颗二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。 堆的表示 1.2.2 堆的算法优先队列由一个基于堆的完全二叉树表示，存储于数组 pq[1..N] 中，pq[0] 没有使用。 在 insert 中，将 n 加一并把新元素添加在数组最后，然后用 swim 保证堆有序。 在 delMax 中，从 pq[1] 中得到需要返回的元素，然后将 pq[N] 移动到 pq[1]，将 N 减一并用 sink 保证堆有序。 Java public class MaxPQ","date":"2023-08-04","objectID":"/posts/algs4/algs4_09/:1:2","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 优先队列","uri":"/posts/algs4/algs4_09/#堆的算法"},{"categories":["数据结构与算法"],"content":" 1.3 优先队列的应用一个基本的优先队列应用是在庞大的输入中找出最大(最小)的元素。 Java public class TopM { public static void main(String[] args) { int m = Integer.parseInt(args[0]); MinPQ\u003cTransaction\u003e pq = new MinPQ\u003c\u003e(m + 1); while (StdIn.hasNextLine()) { // Create an entry from the next line and put on the PQ. String line = StdIn.readLine(); Transaction transaction = new Transaction(line); pq.insert(transaction); // remove minimum if m+1 entries on the PQ if (pq.size() \u003e m) pq.delMin(); } // top m entries are on the PQ // print entries on PQ in reverse order Stack\u003cTransaction\u003e stack = new Stack\u003c\u003e(); for (Transaction transaction : pq) stack.push(transaction); for (Transaction transaction : stack) StdOut.println(transaction); } } ","date":"2023-08-04","objectID":"/posts/algs4/algs4_09/:1:3","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 优先队列","uri":"/posts/algs4/algs4_09/#优先队列的应用"},{"categories":["数据结构与算法"],"content":" 2 索引优先队列在很多应用中，允许用例引用已经进入优先队列中的元素是有必要的（允许用例访问在优先队列中的任意元素）。 理解这种数据结构的一个方法是：将它看成一个能够快速访问其中最小元素的数组。 ","date":"2023-08-04","objectID":"/posts/algs4/algs4_09/:2:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 优先队列","uri":"/posts/algs4/algs4_09/#索引优先队列"},{"categories":["数据结构与算法"],"content":" 2.1 索引优先队列 API Text 泛型优先队列的 API public class IndexMinPQ\u003cItem extends Comparable\u003cItem\u003e\u003e IndexMinPQ(int maxN) 创建一个最大容量为 maxN 的优先队列 索引的取值范围为 0 至 maxN - 1 void insert(int k, Item item) 插入一个元素，将它和索引 k 相关联 void change(int k, Item item) 将索引 k 的元素设为 item boolean contains(int k) 是否存在索引为 k 的元素 void delete(int k) 删去索引 k 及其相关联的元素 Item min() 返回最小元素 int minIndex() 返回最小元素的索引 int delMin() 删除最小元素并返回它的索引 boolean isEmpty() 返回队列是否为空 int size() 返回优先队列中的元素个数 ","date":"2023-08-04","objectID":"/posts/algs4/algs4_09/:2:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 优先队列","uri":"/posts/algs4/algs4_09/#索引优先队列-api"},{"categories":["数据结构与算法"],"content":" 2.2 索引优先队列的实现 Java public class IndexMinPQ\u003cKey extends Comparable\u003cKey\u003e\u003e { /** * keys: 所有元素存储在 keys 数组中，并与索引进行绑定 * pq : 索引二叉堆 * qp : 存储索引的索引，qp[i] 表示 keys[i] 元素对应的索引在 pq 的位置(索引) * 即对于索引为 i 的元素 pq[qp[i]] = i * * 为什么需要记录元素索引的索引？ * 在 deleteMin / changeKey 方法中变更任意元素 keys[i] * 可以直接通过 qp[i] 获取索引在二叉堆 pq 中的位置(索引的索引) */ private int maxN; // maximum number of elements on PQ private int n; // number of elements on PQ private int[] pq; // binary heap using 1-based indexing private int[] qp; // inverse of pq - qp[pq[i]] = pq[qp[i]] = i private Key[] keys; // keys[i] = priority of i public IndexMinPQ(int maxN) { if (maxN \u003c 0) throw new IllegalArgumentException(); this.maxN = maxN; n = 0; keys = (Key[]) new Comparable[maxN + 1]; pq = new int[maxN + 1]; qp = new int[maxN + 1]; for (int i = 0; i \u003c= maxN; i++) qp[i] = -1; } public void insert(int i, Key key) { validateIndex(i); if (contains(i)) throw new IllegalArgumentException(\"index is already in the priority queue\"); keys[i] = key; n++; pq[n] = i; // 将索引 i 加入到 pq[] 最后 qp[i] = n; swim(n); } public void changeKey(int i, Key key) { validateIndex(i); if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\"); keys[i] = key; swim(qp[i]); sink(qp[i]); } public boolean contains(int i) { validateIndex(i); return qp[i] != -1; } public void delete(int i) { validateIndex(i); if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\"); int index = qp[i]; exch(index, n--); swim(index); sink(index); keys[i] = null; qp[i] = -1; } public Key minKey() { if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\"); return keys[pq[1]]; } public int minIndex() { if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\"); return pq[1]; } public int delMin() { if (n == 0) throw new NoSuchElementException(\"Priority queue underflow\"); int min = pq[1]; exch(1, n--); sink(1); assert min == pq[n + 1]; qp[min] = -1; // delete keys[min] = null; // to help with garbage collection pq[n + 1] = -1; // not needed return min; } public Key keyOf(int i) { validateIndex(i); if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\"); return keys[i]; } public boolean isEmpty() { return n == 0; } public int size() { return n; } private void validateIndex(int i) { if (i \u003c 0) throw new IllegalArgumentException(\"index is negative: \" + i); if (i \u003e= maxN) throw new IllegalArgumentException(\"index \u003e= capacity: \" + i); } /*************************************************************************** * Heap helper functions. ***************************************************************************/ private void swim(int k) { while (k \u003e 1 \u0026\u0026 greater(k / 2, k)) { exch(k, k / 2); k = k / 2; } } private void sink(int k) { while (2 * k \u003c= n) { int j = 2 * k; if (j \u003c n \u0026\u0026 greater(j, j + 1)) j++; if (!greater(k, j)) break; exch(k, j); k = j; } } /*************************************************************************** * General helper functions. ***************************************************************************/ private boolean greater(int v, int w) { return keys[pq[v]].compareTo(keys[pq[w]]) \u003e 0; } private void exch(int v, int w) { int swap = pq[v]; pq[v] = pq[w]; pq[w] = swap; // 索引 pq[v] 与 pq[w] 交换，此时 pq[v] 指向 keys[w], pq[w] 指向 keys[v] qp[pq[v]] = v; qp[pq[w]] = w; } } ","date":"2023-08-04","objectID":"/posts/algs4/algs4_09/:2:2","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 优先队列","uri":"/posts/algs4/algs4_09/#索引优先队列的实现"},{"categories":["数据结构与算法"],"content":" 2.3 索引优先队列用例多向归并问题：将多个有序的输入流归并成一个有序的输出流。 使用优先队列解决多向归并问题，无论输入有多长都可以将其全部读入并排序。 Java public class Multiway { public static void merge(In[] streams) { // 每个输入流对应索引优先队列的一个索引 int N = streams.length; IndexMinPQ\u003cString\u003e pq = new IndexMinPQ\u003c\u003e(N); // 每个输入流的索引都关联一个元素（输入中的下一个字符串） for (int i = 0; i \u003c N; i++) if (!streams[i].isEmpty()) pq.insert(i, streams[i].readString()); // 删除并打印出队列中最小字符串 // 然后将该输入的下一个字符串添加到优先队列 while (!pq.isEmpty()) { StdOut.println(pq.min()); int i = pq.delMin(); if (!streams[i].isEmpty()) pq.insert(i, streams[i].readString()); } } public static void main(String[] args) { int N = args.length; In[] streams = new In[N]; for (int i = 0; i \u003c N; i++) streams[i] = new In(args[i]); merge(streams); } } ","date":"2023-08-04","objectID":"/posts/algs4/algs4_09/:2:3","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 优先队列","uri":"/posts/algs4/algs4_09/#索引优先队列用例"},{"categories":["数据结构与算法"],"content":" 3 堆排序堆排序算法：堆排序算法分为两个阶段，堆的构造阶段和下沉排序阶段。 在堆的构造阶段，我们将原始数组重新组织安排进一个堆中。 在下沉排序阶段，我们从堆中按递减顺序取出所有元素并得到排序结果。 ","date":"2023-08-04","objectID":"/posts/algs4/algs4_09/:3:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 优先队列","uri":"/posts/algs4/algs4_09/#堆排序"},{"categories":["数据结构与算法"],"content":" 3.1 堆的构造构造堆的一个高效方法是使用 sink 方法从右至左构造子堆。如果一个结点的两个子结点已经是堆了，那么在该结点上调用 sink 方法可以将它们变成一个堆。 开始时我们只需要扫描数组中的一半元素，因为我们可以提哦啊过大小为 1 的子堆。最后我们在位置 1 上调用 sink 方法，堆构造结束。 ","date":"2023-08-04","objectID":"/posts/algs4/algs4_09/:3:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 优先队列","uri":"/posts/algs4/algs4_09/#堆的构造"},{"categories":["数据结构与算法"],"content":" 3.2 下沉排序我们将堆中的最大元素删除，然后放入堆缩小后数组中空出的位置，直至销毁堆，下沉排序完成。 Java public class Heap { public static void sort(Comparable[] pq) { int n = pq.length; // heapify phase for (int k = n/2; k \u003e= 1; k--) sink(pq, k, n); // sortdown phase int k = n; while (k \u003e 1) { exch(pq, 1, k--); sink(pq, 1, k); } } } ","date":"2023-08-04","objectID":"/posts/algs4/algs4_09/:3:2","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 优先队列","uri":"/posts/algs4/algs4_09/#下沉排序"},{"categories":["数据结构与算法"],"content":" 3.3 先下沉后上浮（Floyd 优化）大多数在下沉排序期间重新插入堆的元素会下沉到堆底。 通过先下沉后上浮，我们正好可以通过免去检查元素是否到达正确的位置来节省时间。在下沉过程中总是直接提升较大的子结点直至到达堆底。然后再使元素上浮到正确的位置。 这种方法可以将比较次数减少一半，接近归并排序所需的比较次数。 Java public class FloydHeap { public static void sort(Comparable[] pq) { int n = pq.length; // heapify phase for (int k = n / 2; k \u003e= 1; k--) sink(pq, k, n); // sortdown phase int k = n; while (k \u003e 1) { exch(pq, 1, k--); sinkThenSwim(pq, 1, k); } } private static void sink(Comparable[] pq, int k, int n) { while (2 * k \u003c= n) { int j = 2 * k; if (j \u003c n \u0026\u0026 less(pq, j, j + 1)) j++; if (!less(pq, k, j)) break; exch(pq, k, j); k = j; } } private static void swim(Comparable[] pq, int k) { while (k \u003e 1 \u0026\u0026 less(pq, k / 2, k)) { exch(pq, k, k / 2); k /= 2; } } private static void sinkThenSwim(Comparable[] pq, int k, int n) { while (2 * k \u003c= n) { int j = 2 * k; if (j \u003c n \u0026\u0026 less(pq, j, j + 1)) j++; // 免去检查元素是否到达正确位置 // if (!less(pq, k, j)) break; exch(pq, k, j); k = j; } // swim 到正确位置 swim(pq, k); } } ","date":"2023-08-04","objectID":"/posts/algs4/algs4_09/:3:3","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 优先队列","uri":"/posts/algs4/algs4_09/#先下沉后上浮floyd-优化"},{"categories":["计算机体系结构"],"content":"汇编语言 —— 寄存器(内存访问)","date":"2023-08-03","objectID":"/posts/computer_architecture/assemply_language/assemply_language_03/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器(内存访问)","uri":"/posts/computer_architecture/assemply_language/assemply_language_03/"},{"categories":["计算机体系结构"],"content":" 1 内存中字的存储CPU 中，用 16 位寄存器来存储一个字。高 8 位存放高位字节，低 8 位存放低位字节。 字单元：即存放一个字型数据(16 位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。 ","date":"2023-08-03","objectID":"/posts/computer_architecture/assemply_language/assemply_language_03/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器(内存访问)","uri":"/posts/computer_architecture/assemply_language/assemply_language_03/#内存中字的存储"},{"categories":["计算机体系结构"],"content":" 2 DS 和 [address]8086CPU 中有一个 DS 寄存器，通常用来存放要访问数据的段地址。 比如我们需要读取 10000H 单元的内容，并将数据读到 al 中。代码如下： text ; 8086CPU 不支持将数据直接送入段寄存器的操作（硬件设计问题） ; 需要使用一个寄存器进行中转 mov bx,1000H mov ds,bx ; 完成数据从 1000:0 单元到 al 的传送 ; 指令执行时，8086CPU 自动取 ds 中的数据为内存单元的段地址 mov al,[0] ","date":"2023-08-03","objectID":"/posts/computer_architecture/assemply_language/assemply_language_03/:2:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器(内存访问)","uri":"/posts/computer_architecture/assemply_language/assemply_language_03/#ds-和-address"},{"categories":["计算机体系结构"],"content":" 3 字的传送只要在 mov 指令中给出 16 位的寄存器就可以进行 16 位数据的传送： text mov bx,1000H mov ds,bx mov ax,[0] ; 1000:0 处的字型数据送入 ax mov [0],cx ; cx 中的 16 位数据送到 1000:0 处 ","date":"2023-08-03","objectID":"/posts/computer_architecture/assemply_language/assemply_language_03/:3:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器(内存访问)","uri":"/posts/computer_architecture/assemply_language/assemply_language_03/#字的传送"},{"categories":["计算机体系结构"],"content":" 4 mov、add、sub 指令mov、add、sub 指令可以有以下几种形式（以 mov 指令举例）： 指令形式 指令案例 mov 寄存器，数据 mov ax,8 mov 寄存器，寄存器 mov ax,bx mov 寄存器，内存单元 mov ax,[0] mov 内存单元，寄存器 mov [0],ax mov 段寄存器，寄存器 mov ds,ax mov 寄存器，段寄存器 mov ax,ds mov 段寄存器，内存单元 mov cs,[0] mov 内存单元，段寄存器 mov [0],cs ","date":"2023-08-03","objectID":"/posts/computer_architecture/assemply_language/assemply_language_03/:4:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器(内存访问)","uri":"/posts/computer_architecture/assemply_language/assemply_language_03/#movaddsub-指令"},{"categories":["计算机体系结构"],"content":" 5 数据段我们可以将一组长度为 N( ≤ 64 KB )、地址连续、起始地址为 16 的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。 将一段内存当作数据段，也是我们在编程时的一种安排，与代码段类似。 ","date":"2023-08-03","objectID":"/posts/computer_architecture/assemply_language/assemply_language_03/:5:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器(内存访问)","uri":"/posts/computer_architecture/assemply_language/assemply_language_03/#数据段"},{"categories":["计算机体系结构"],"content":" 6 CPU 提供的栈机制栈是一种具有特殊的访问方式的存储空间。最后进入这个空间的数据，最先出去。 8086CPU 提供相关的指令来以栈的方式访问内存空间。在基于 8086CPU 编程的时候，可以将一段内存当作栈来使用。 8086CPU 提供入栈和出栈指令，最基本的两个是 PUSH(入栈) 和 POP(出栈)。8086CPU 的入栈和出栈操作以字为单位进行的。 8086CPU 中，有两个寄存器，段寄存器 SS 和寄存器 SP，栈顶的段地址存放 在 SS 中，偏移地址存放在 SP 中。任意时刻，SS:SP 指向栈顶元素。push 指令和 pop 指令执行时，CPU 从 SS 和 SP 中得到栈顶的地址。 ","date":"2023-08-03","objectID":"/posts/computer_architecture/assemply_language/assemply_language_03/:6:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器(内存访问)","uri":"/posts/computer_architecture/assemply_language/assemply_language_03/#cpu-提供的栈机制"},{"categories":["计算机体系结构"],"content":" 6.1 PUSH 操作push ax 的执行，由以下两步完成： SP = SP - 2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶； 将 ax 中的内容送入 SS:SP 指向的内存单元处，SS:SP 此时指向新栈顶。 PUSH 指令执行过程 ","date":"2023-08-03","objectID":"/posts/computer_architecture/assemply_language/assemply_language_03/:6:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器(内存访问)","uri":"/posts/computer_architecture/assemply_language/assemply_language_03/#push-操作"},{"categories":["计算机体系结构"],"content":" 6.2 POP 操作pop ax 的执行过程和 push ax 相反，由以下两步完成： 将 SS:SP 指向的内存单元处的数据送入 ax 中； SP = SP + 2，SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。 POP 指令执行过程 ","date":"2023-08-03","objectID":"/posts/computer_architecture/assemply_language/assemply_language_03/:6:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器(内存访问)","uri":"/posts/computer_architecture/assemply_language/assemply_language_03/#pop-操作"},{"categories":["计算机体系结构"],"content":" 6.3 栈空时 SS:SP 的指向任意时刻，SS:SP 指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以 SS:SP 只能指向栈的最底部单元下面的单元，该单元的偏移地为栈最底部的字单元的偏移地址 + 2。 栈空的状态 ","date":"2023-08-03","objectID":"/posts/computer_architecture/assemply_language/assemply_language_03/:6:3","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器(内存访问)","uri":"/posts/computer_architecture/assemply_language/assemply_language_03/#栈空时-sssp-的指向"},{"categories":["计算机体系结构"],"content":" 6.4 栈顶超界问题当栈满的时候 再使用 push 指令入栈，或栈空的时候再使用 pop 指令出栈，都将发生栈顶超界问题。 8086CPU 不保证我们对栈的操作不会超界，在编程的时候要自己操心栈顶超界的问题。 ","date":"2023-08-03","objectID":"/posts/computer_architecture/assemply_language/assemply_language_03/:6:4","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器(内存访问)","uri":"/posts/computer_architecture/assemply_language/assemply_language_03/#栈顶超界问题"},{"categories":["计算机体系结构"],"content":" 7 PUSH、POP 指令 指令形式 指令案例 指令说明 push 寄存器 push ax 将一个奇存器中的数据入栈 pop 寄存器 pop ax 出栈，用一个寄存器接收出栈的数据 push 段寄存器 push ds 将一个段寄存器中的数据入栈 pop 段寄存器 pop cs 出栈，用一个段寄存器接收出栈的数据 push 内存单元 push [0] 将一个内存字单元处的字入栈(注意:栈操作都是以字为单位) pop 内存单元 pop [0] 出栈，用 一个内存字单元按收出栈的数据 push、pop 实质上就是一种内存传送指令，可以在寄存器和内存之间或内存和内存之间传送数据，与 mov 指令不同的是，push 和 pop 指令访问的内存单元的地址不是在指令中给出的，而是由 SS:SP 指出的。 CPU 执行 mov 指令只需一步操作，就是传送；而执行 push、pop 指令需要两步操作： 执行push时，CPU 的两步操作是：先改变 SP，后向 SS:SP 处传送 执行 pop 时，CPU 的两步操作是：先读取 SS:SP 处的数据，后改变SP 提供：SS、SP 指示栈顶；改变 SP 后写内存的入栈指令；读内存后改变 SP 的出栈指令。这就是 8086CPU 提供的栈操作机制。 ","date":"2023-08-03","objectID":"/posts/computer_architecture/assemply_language/assemply_language_03/:7:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器(内存访问)","uri":"/posts/computer_architecture/assemply_language/assemply_language_03/#pushpop-指令"},{"categories":["计算机体系结构"],"content":" 8 段的综述我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排： 我们可以用一个段存放数据，将它定义为“数据段”； 我们可以用一个段存放代码，将它定义为“代码段”； 我们可以用一个段当作栈，将它定义为“栈段”。 对于数据段，将它的段地址放在 DS 中，用 mov、add、sub 等访问内存单元的指令时，CPU 就将我们定义的数据段中的内容当作数据来访问。 对于代码段，将它的段地址放在 CS 中，将段中第一条指令的偏移地址放在 IP 中，这样 CPU 就将执行我们定义的代码段中的指令。 对于栈段，将它的段地址放在 SS 中，将栈顶单元的偏移地址放在 SP 中，这样 CPU 在需要进行栈操作的时候，比如执行 push、pop 指令等，就将我们定义的栈段当作栈空间来用。 一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于CPU中寄存器的设置，即 CS、IP，SS、SP，DS 的指向。 ","date":"2023-08-03","objectID":"/posts/computer_architecture/assemply_language/assemply_language_03/:8:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器(内存访问)","uri":"/posts/computer_architecture/assemply_language/assemply_language_03/#段的综述"},{"categories":["中间件技术"],"content":"阅读 Redis SDS 相关代码，理解 Redis 中字符串是如何存储的。","date":"2023-07-27","objectID":"/posts/redis_source_code/redis_source_code_01/","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 简单动态字符串 SDS","uri":"/posts/redis_source_code/redis_source_code_01/"},{"categories":["中间件技术"],"content":" 1 SDS 定义sds 的定义以及 sdshdr 的定义代码如下： C typedef char *sds; /* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; sds 实际就是字符指针 char * 类型。 sds 通过五种类型的 Header 来满足不同长度字符串的使用需求。除了 sdshdr5 类型是为不可变的字符串准备的(比如一个存储 key 的字符串)，其余的 Header 都有 len、alloc 和 flags 元数据域和 buf 存储域。 len 保存字符串长度(不包括 C 字符串末尾的 ‘\\0’ )； alloc 保存 buf 数组的长度； flags 占一个字节，前 3 位保存 Header 类型，后三位未使用； buf 保存具体的字符串。实际长度为 alloc + 1 (最后一位的 ‘\\0’)。 C // flags 的定义 #define SDS_TYPE_5 0 // 0000 0000 #define SDS_TYPE_8 1 // 0000 0001 #define SDS_TYPE_16 2 // 0000 0010 #define SDS_TYPE_32 3 // 0000 0011 #define SDS_TYPE_64 4 // 0000 0100 ","date":"2023-07-27","objectID":"/posts/redis_source_code/redis_source_code_01/:1:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 简单动态字符串 SDS","uri":"/posts/redis_source_code/redis_source_code_01/#sds-定义"},{"categories":["中间件技术"],"content":" 1.1 SDS 的内存构造下图使用一个 sdshdr16 类型的 Header 演示 sds 的内存构造。 SDS 内存构造 ","date":"2023-07-27","objectID":"/posts/redis_source_code/redis_source_code_01/:1:1","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 简单动态字符串 SDS","uri":"/posts/redis_source_code/redis_source_code_01/#sds-的内存构造"},{"categories":["中间件技术"],"content":" 1.2 内存对齐__attribute__ ((__packed__)) 令编译器取消内存对齐，从而节省内存，并方便使用 buf[-1] 获取 flags 域的地址。 下图使用 sdshdr16 的 sds，内存对齐系数为 4，演示内存对齐与内存不对齐的区别。 内存对齐与内存不对齐的区别 ","date":"2023-07-27","objectID":"/posts/redis_source_code/redis_source_code_01/:1:2","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 简单动态字符串 SDS","uri":"/posts/redis_source_code/redis_source_code_01/#内存对齐"},{"categories":["中间件技术"],"content":" 2 SDS API","date":"2023-07-27","objectID":"/posts/redis_source_code/redis_source_code_01/:2:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 简单动态字符串 SDS","uri":"/posts/redis_source_code/redis_source_code_01/#sds-api"},{"categories":["中间件技术"],"content":" 2.1 创建字符串sdsnew 函数创建一个字符串，返回指向 sds 的指针。 C /* Create a new sds string with the content specified by the 'init' pointer * and 'initlen'. * If NULL is used for 'init' the string is initialized with zero bytes. * If SDS_NOINIT is used, the buffer is left uninitialized; * * The string is always null-terminated (all the sds strings are, always) so * even if you create an sds string with: * * mystring = sdsnewlen(\"abc\",3); * * You can print the string with printf() as there is an implicit \\0 at the * end of the string. However the string is binary safe and can contain * \\0 characters in the middle, as the length is stored in the sds header. */ sds _sdsnewlen(const void *init, size_t initlen, int trymalloc) { // sdshdr 指针 void *sh; sds s; // 通过字符串长度，决定使用哪种 sdshdr char type = sdsReqType(initlen); /* Empty strings are usually created in order to append. Use type 8 * since type 5 is not good at this. */ if (type == SDS_TYPE_5 \u0026\u0026 initlen == 0) type = SDS_TYPE_8; // 计算 sdshdr 的内存大小 int hdrlen = sdsHdrSize(type); unsigned char *fp; /* flags pointer. */ // malloc 分配的字节数 size_t usable; assert(initlen + hdrlen + 1 \u003e initlen); /* Catch size_t overflow */ // 分配内存，大小为 Header 长度、字符串长度、'\\0' 之和 sh = trymalloc? s_trymalloc_usable(hdrlen+initlen+1, \u0026usable) : s_malloc_usable(hdrlen+initlen+1, \u0026usable); if (sh == NULL) return NULL; if (init==SDS_NOINIT) init = NULL; else if (!init) // 将 sh 指针向后的内存区域初始化为 0 memset(sh, 0, hdrlen+initlen+1); // 指向 buf s = (char*)sh+hdrlen; // 指向 flags fp = ((unsigned char*)s)-1; // 计算字符数组实际可用长度，使其不会超过类型的上限。 usable = usable-hdrlen-1; if (usable \u003e sdsTypeMaxSize(type)) usable = sdsTypeMaxSize(type); switch(type) { case SDS_TYPE_5: { *fp = type | (initlen \u003c\u003c SDS_TYPE_BITS); break; } case SDS_TYPE_8: { SDS_HDR_VAR(8,s); sh-\u003elen = initlen; sh-\u003ealloc = usable; *fp = type; break; } // ... SDS_TYPE_16 SDS_TYPE_32 SDS_TYPE_64 } if (initlen \u0026\u0026 init) // 将 init 指向的字符串拷贝到指针 s 中 memcpy(s, init, initlen); // 末尾赋值 '\\0' s[initlen] = '\\0'; return s; } sds sdsnewlen(const void *init, size_t initlen) { return _sdsnewlen(init, initlen, 0); } sds sdstrynewlen(const void *init, size_t initlen) { return _sdsnewlen(init, initlen, 1); } /* Create an empty (zero length) sds string. Even in this case the string * always has an implicit null term. */ sds sdsempty(void) { return sdsnewlen(\"\",0); } /* Create a new sds string starting from a null terminated C string. */ sds sdsnew(const char *init) { size_t initlen = (init == NULL) ? 0 : strlen(init); return sdsnewlen(init, initlen); } ","date":"2023-07-27","objectID":"/posts/redis_source_code/redis_source_code_01/:2:1","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 简单动态字符串 SDS","uri":"/posts/redis_source_code/redis_source_code_01/#创建字符串"},{"categories":["中间件技术"],"content":" 2.2 字符串空间预分配在 sds 可能会有空间内存增长时，会调用 sdsMakeRoomFor 方法进行 sds 空间检查和扩容。 为了尽可能避免内存的重新申请/分配，redis 的 buf 数组如果有变动，通常会预分配额外的空间保证下次字符串变化时，如果空间足够，就不需要再次进行内存分配。 常量 SDS_MAX_PREALLOC 值为 1024 * 1024。当新申请的 sds 大小小于 1MB 时，会多分配一倍的内存；当新申请的 sds 大小大于等于 1MB 时，函数多分配 1MB 内存。 C /* Enlarge the free space at the end of the sds string so that the caller * is sure that after calling this function can overwrite up to addlen * bytes after the end of the string, plus one more byte for nul term. * If there's already sufficient free space, this function returns without any * action, if there isn't sufficient free space, it'll allocate what's missing, * and possibly more: * When greedy is 1, enlarge more than needed, to avoid need for future reallocs * on incremental growth. * When greedy is 0, enlarge just enough so that there's free space for 'addlen'. * * Note: this does not change the *length* of the sds string as returned * by sdslen(), but only the free buffer space we have. */ sds _sdsMakeRoomFor(sds s, size_t addlen, int greedy) { // 旧 sdshdr 和新 sdshdr 指针 void *sh, *newsh; // 旧 sds 可用内存 (sh-\u003ealloc - sh-\u003elen) size_t avail = sdsavail(s); // 旧 sds 长度，新 sds 长度，请求的长度 size_t len, newlen, reqlen; char type, oldtype = s[-1] \u0026 SDS_TYPE_MASK; int hdrlen; size_t usable; /* Return ASAP if there is enough space left. */ // 如果可用空间 avail 足够，直接返回 (避免内存的重新分配) if (avail \u003e= addlen) return s; len = sdslen(s); sh = (char*)s-sdsHdrSize(oldtype); reqlen = newlen = (len+addlen); assert(newlen \u003e len); /* Catch size_t overflow */ if (greedy == 1) { // 如果小于 1MB，就扩容两倍 newlen if (newlen \u003c SDS_MAX_PREALLOC) newlen *= 2; // 否则，只扩展 1MB else newlen += SDS_MAX_PREALLOC; } // 根据长度计算 sdshdr 类型 type = sdsReqType(newlen); /* Don't use type 5: the user is appending to the string and type 5 is * not able to remember empty space, so sdsMakeRoomFor() must be called * at every appending operation. */ if (type == SDS_TYPE_5) type = SDS_TYPE_8; // 新的 sdshdr 大小 hdrlen = sdsHdrSize(type); assert(hdrlen + newlen + 1 \u003e reqlen); /* Catch size_t overflow */ if (oldtype==type) { // 如果新旧 sdshdr 类型一致, 对 sh 的空间重新分配, 不会改变原来里面的数据 // https://man.cx/realloc newsh = s_realloc_usable(sh, hdrlen+newlen+1, \u0026usable); if (newsh == NULL) return NULL; s = (char*)newsh+hdrlen; } else { /* Since the header size changes, need to move the string forward, * and can't use realloc */ // sdshdr 类型改变，不能使用 realloc newsh = s_malloc_usable(hdrlen+newlen+1, \u0026usable); if (newsh == NULL) return NULL; // 将旧 sds 内容拷贝到新 sds 中 memcpy((char*)newsh+hdrlen, s, len+1); // 释放旧 sdshdr 空间 s_free(sh); // 旧 sds 指针指向新 sds s = (char*)newsh+hdrlen; // 赋值 flags s[-1] = type; // 设置 sh-\u003elen sdssetlen(s, len); } // 设置 sh-\u003ealloc usable = usable-hdrlen-1; if (usable \u003e sdsTypeMaxSize(type)) usable = sdsTypeMaxSize(type); sdssetalloc(s, usable); return s; } /* Enlarge the free space at the end of the sds string more than needed, * This is useful to avoid repeated re-allocations when repeatedly appending to the sds. */ sds sdsMakeRoomFor(sds s, size_t addlen) { return _sdsMakeRoomFor(s, addlen, 1); } /* Unlike sdsMakeRoomFor(), this one just grows to the necessary size. */ sds sdsMakeRoomForNonGreedy(sds s, size_t addlen) { return _sdsMakeRoomFor(s, addlen, 0); } ","date":"2023-07-27","objectID":"/posts/redis_source_code/redis_source_code_01/:2:2","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 简单动态字符串 SDS","uri":"/posts/redis_source_code/redis_source_code_01/#字符串空间预分配"},{"categories":["中间件技术"],"content":" 2.3 字符串空间惰性释放(重分配)在 sds 长度减少，Redis 不会立即回收减少部分的内存空间，在下次需要增加 sds 长度时，可以一定程度上避免内存的分配。 比如在 sdstrim 中，不会释放内存空间： C /* Remove the part of the string from left and from right composed just of * contiguous characters found in 'cset', that is a null terminated C string. * * After the call, the modified sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. * * Example: * * s = sdsnew(\"AA...AA.a.aa.aHelloWorld :::\"); * s = sdstrim(s,\"Aa. :\"); * printf(\"%s\\n\", s); * * Output will be just \"HelloWorld\". */ sds sdstrim(sds s, const char *cset) { char *end, *sp, *ep; size_t len; sp = s; ep = end = s+sdslen(s)-1; while(sp \u003c= end \u0026\u0026 strchr(cset, *sp)) sp++; while(ep \u003e sp \u0026\u0026 strchr(cset, *ep)) ep--; len = (ep-sp)+1; // sp 长度为 len 的内存拷贝到 s if (s != sp) memmove(s, sp, len); // 维护末尾的 '\\0' s[len] = '\\0'; // 维护 sh-\u003elen， sh-\u003ealloc 没有更改 sdssetlen(s,len); return s; } 调用 sdsRemoveFreeSpace 可以主动回收空间。例如客户端输入缓冲区大于 4KB 并且客户端空闲时间超过 2s，会调用 sdsRemoveFreeSpace 对 c-\u003equerybuf 进行进行多余空间的释放。 C /* The client query buffer is an sds.c string that can end with a lot of * free space not used, this function reclaims space if needed. * * The function always returns 0 as it never terminates the client. */ int clientsCronResizeQueryBuffer(client *c) { // ... /* Only resize the query buffer if the buffer is actually wasting at least a * few kbytes */ if (sdsavail(c-\u003equerybuf) \u003e 1024*4) { /* There are two conditions to resize the query buffer: */ if (idletime \u003e 2) { /* 1) Query is idle for a long time. */ c-\u003equerybuf = sdsRemoveFreeSpace(c-\u003equerybuf, 1); } // ... } // ... return 0; } sdsRemoveFreeSpace 实际上是调用的 sdsResize 方法。 C /* Reallocate the sds string so that it has no free space at the end. The * contained string remains not altered, but next concatenation operations * will require a reallocation. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdsRemoveFreeSpace(sds s, int would_regrow) { return sdsResize(s, sdslen(s), would_regrow); } /* Resize the allocation, this can make the allocation bigger or smaller, * if the size is smaller than currently used len, the data will be truncated. * * The when the would_regrow argument is set to 1, it prevents the use of * SDS_TYPE_5, which is desired when the sds is likely to be changed again. * * The sdsAlloc size will be set to the requested size regardless of the actual * allocation size, this is done in order to avoid repeated calls to this * function when the caller detects that it has excess space. */ sds sdsResize(sds s, size_t size, int would_regrow) { // 旧 sdshdr 和 新 sdshdr 指针 void *sh, *newsh; // 新 sdshdr 类型 和 旧 sdshdr 类型 char type, oldtype = s[-1] \u0026 SDS_TYPE_MASK; // 新 sdshdr 长度 和 新 sdshdr 长度 int hdrlen, oldhdrlen = sdsHdrSize(oldtype); size_t len = sdslen(s); sh = (char*)s-oldhdrlen; /* Return ASAP if the size is already good. */ // 大小无变化，不需要 resize if (sdsalloc(s) == size) return s; /* Truncate len if needed. */ if (size \u003c len) len = size; /* Check what would be the minimum SDS header that is just good enough to * fit this string. */ type = sdsReqType(size); if (would_regrow) { /* Don't use type 5, it is not good for strings that are expected to grow back. */ if (type == SDS_TYPE_5) type = SDS_TYPE_8; } hdrlen = sdsHdrSize(type); /* If the type is the same, or can hold the size in it with low overhead * (larger than SDS_TYPE_8), we just realloc(), letting the allocator * to do the copy only if really needed. Otherwise if the change is * huge, we manually reallocate the string to use the different header * type. */ // 如果 新旧 sdshdr 类型一样，或者旧类型能够容纳新类型，使用 realloc int use_realloc = (oldtype==type || (type \u003c oldtype \u0026\u0026 type \u003e SDS_TYPE_8)); size_t newlen = use_realloc ? oldhdrlen+size+1 : hdrlen+size+1; // jemalloc 优化 int alloc_already_optimal = 0; #if defined(USE_JEMALLOC) /* je_nallocx returns the expected allocation size for the newlen. * We aim to avoid cal","date":"2023-07-27","objectID":"/posts/redis_source_code/redis_source_code_01/:2:3","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 简单动态字符串 SDS","uri":"/posts/redis_source_code/redis_source_code_01/#字符串空间惰性释放重分配"},{"categories":["中间件技术"],"content":" 3 字符串编码Redis 字符串会使用不同的编码格式存储不同类型的数据。若字符串是数字，则使用 int 编码；若设置的字符串大小小于等于 44 个字节，则使用紧凑的编码类型 embstr；若设置的字符串大小大于 44 个字节，则使用 raw 类型进行编码。 ","date":"2023-07-27","objectID":"/posts/redis_source_code/redis_source_code_01/:3:0","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 简单动态字符串 SDS","uri":"/posts/redis_source_code/redis_source_code_01/#字符串编码"},{"categories":["中间件技术"],"content":" 3.1 redisObject在学习 Redis 编码之前，需要先了解 redisObject 结构体。在 Redis 中，所有的 key/value 都是一个 redisObject 结构体。该结构体的定义如下。 C #define LRU_BITS 24 struct redisObject { // 4 bits 表示类型， string / list / set / zset / hash / module / stream unsigned type:4; // 4 bits 表示编码，如 string 可以有 raw / embstr / int 等编码方式 unsigned encoding:4; // 24 bits unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or * LFU data (least significant 8 bits frequency * and most significant 16 bits access time). */ // 4 * 8 = 32 bits 对象的引用计数 int refcount; // 8 bytes (64-bit system)，指向实际对象地址指针 void *ptr; }; 可以算出 redisObject 的大小为 16 字节。4 bits 的 encoding 域保存对象编码类型。 ","date":"2023-07-27","objectID":"/posts/redis_source_code/redis_source_code_01/:3:1","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 简单动态字符串 SDS","uri":"/posts/redis_source_code/redis_source_code_01/#redisobject"},{"categories":["中间件技术"],"content":" 3.2 字符串紧凑编码 embstrembstr 类型的介绍：Introduction of a new string encoding: EMBSTR 在字符串大小小于等于 44 字节时，使用 embstr 对字符串进行编码。以 44 字节作为分界的原因需要对比一下 embstr 和 raw 在内存上的存储方式。 embstr 和 raw 在内存上的存储方式 在 embstr 编码中， robj 和 sds 在内存中是连续的，申请内存时只需要调用一次 malloc 方法，释放内存也只需调用一次 free 方法；raw 格式编码在内存地址中不连续，申请/释放内存时会进行两次 malloc/free 调用。 ","date":"2023-07-27","objectID":"/posts/redis_source_code/redis_source_code_01/:3:2","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 简单动态字符串 SDS","uri":"/posts/redis_source_code/redis_source_code_01/#字符串紧凑编码-embstr"},{"categories":["中间件技术"],"content":" 3.3 字符串对象的创建创建字符串对象的代码如下所示： C /* Create a string object with EMBSTR encoding if it is smaller than * OBJ_ENCODING_EMBSTR_SIZE_LIMIT, otherwise the RAW encoding is * used. * * The current limit of 44 is chosen so that the biggest string object * we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc. */ #define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44 robj *createStringObject(const char *ptr, size_t len) { // 长度小于等于 44 字节，使用 embstr 编码，否则使用 raw 编码 if (len \u003c= OBJ_ENCODING_EMBSTR_SIZE_LIMIT) return createEmbeddedStringObject(ptr,len); else return createRawStringObject(ptr,len); } /* Create a string object with encoding OBJ_ENCODING_EMBSTR, that is * an object where the sds string is actually an unmodifiable string * allocated in the same chunk as the object itself. */ robj *createEmbeddedStringObject(const char *ptr, size_t len) { // malloc 一次性申请 robj + sdshdr8 + len + 1 字节的内存 robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1); struct sdshdr8 *sh = (void*)(o+1); // 设置 robj o-\u003etype = OBJ_STRING; o-\u003eencoding = OBJ_ENCODING_EMBSTR; o-\u003eptr = sh+1; o-\u003erefcount = 1; o-\u003elru = 0; sh-\u003elen = len; // alloc 设置为 len sh-\u003ealloc = len; sh-\u003eflags = SDS_TYPE_8; if (ptr == SDS_NOINIT) sh-\u003ebuf[len] = '\\0'; else if (ptr) { memcpy(sh-\u003ebuf,ptr,len); sh-\u003ebuf[len] = '\\0'; } else { memset(sh-\u003ebuf,0,len+1); } return o; } /* Create a string object with encoding OBJ_ENCODING_RAW, that is a plain * string object where o-\u003eptr points to a proper sds string. */ robj *createRawStringObject(const char *ptr, size_t len) { // sdsnewlen 中会调用一次 malloc return createObject(OBJ_STRING, sdsnewlen(ptr,len)); } robj *createObject(int type, void *ptr) { // 第二次调用 malloc robj *o = zmalloc(sizeof(*o)); o-\u003etype = type; o-\u003eencoding = OBJ_ENCODING_RAW; o-\u003eptr = ptr; o-\u003erefcount = 1; o-\u003elru = 0; return o; } ","date":"2023-07-27","objectID":"/posts/redis_source_code/redis_source_code_01/:3:3","series":["Redis源码 阅读笔记"],"tags":["Redis","Redis数据结构"],"title":"Redis 简单动态字符串 SDS","uri":"/posts/redis_source_code/redis_source_code_01/#字符串对象的创建"},{"categories":["中间件技术"],"content":"阅读 Redis 代码，学习代码设计。","date":"2023-07-26","objectID":"/posts/redis_source_code/redis_source_code_00/","series":["Redis源码 阅读笔记"],"tags":["Redis"],"title":"Redis 代码阅读开篇","uri":"/posts/redis_source_code/redis_source_code_00/"},{"categories":["中间件技术"],"content":" 1 为什么要阅读 Redis 源码 更加深刻地理解 Redis 以及在使用 Redis 出现故障时能够更好地定位问题； 提升系统设计能力与编程水平。 ","date":"2023-07-26","objectID":"/posts/redis_source_code/redis_source_code_00/:1:0","series":["Redis源码 阅读笔记"],"tags":["Redis"],"title":"Redis 代码阅读开篇","uri":"/posts/redis_source_code/redis_source_code_00/#为什么要阅读-redis-源码"},{"categories":["计算机体系结构"],"content":"汇编语言 —— 寄存器","date":"2023-07-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_02/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_02/"},{"categories":["计算机体系结构"],"content":"CPU 由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。内部总线实现 CPU 内部各个器件之间的联系，外部总线实现 CPU 和主板上其他器件的联系。 在 CPU 中： 运算器进行信息处理； 寄存器进行信息存储； 控制器控制各种器件进行工作； 内部总线连接各种器件，在它们之间进行数据的传送。 ","date":"2023-07-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_02/:0:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_02/#"},{"categories":["计算机体系结构"],"content":" 1 通用寄存器8086CPU 的所有寄存器都是 16 位的，可以存放两个字节。AX、BX、CX、DX 这 4 个寄存器通常用来存放一般性的数据，被称为通用寄存器。 8086CPU 的 AX、BX、CX 、DX 这 4 个寄存器都可分为两个可独立使用的 8 位寄存器来使用。 ","date":"2023-07-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_02/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_02/#通用寄存器"},{"categories":["计算机体系结构"],"content":" 2 字在寄存器中的存储字节：记为 byte，一个字节由 8 个 bit 组成，可以存在 8 位寄存器中。 字：记为 word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节。 text AX 寄存器： 高位字节 AH 低位字节 AL 0 1 0 0 1 1 1 0 | 0 0 1 0 0 0 0 0 ","date":"2023-07-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_02/:2:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_02/#字在寄存器中的存储"},{"categories":["计算机体系结构"],"content":" 3 几条汇编指令 汇编指令 控制 CP U 完成的操作 用高级语言的语法描述 mov ax,18 将 18 送入寄存器 AX AX = 18 mov ah,78 将 78 送入寄存器 AH AH = 78 add ax,8 将寄存器 AX 中的数值加上 8 AX = AX + 8 mov ax,bx 将寄存器 BX 中的数据送入寄存器 AX AX = BX add ax,bx 将 AX 和 BX 中的数值相加，结果存在 AX 中 AX = AX + BX ","date":"2023-07-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_02/:3:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_02/#几条汇编指令"},{"categories":["计算机体系结构"],"content":" 4 8086CPU 给出物理地址的方法","date":"2023-07-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_02/:4:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_02/#8086cpu-给出物理地址的方法"},{"categories":["计算机体系结构"],"content":" 4.1 物理地址的概念CPU 访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。 CPU 通过地址总线送入存储器的，必须是一个内存单元的物理地址。在 CPU 向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的 CPU 可以有不同的形成物理地址的方式。 ","date":"2023-07-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_02/:4:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_02/#物理地址的概念"},{"categories":["计算机体系结构"],"content":" 4.2 8086CPU 的结构8086CPU 是 16 位结构的 CPU： 运算器一次最多可以处理 16 位的数据； 寄存器的最大宽度为 16 位； 寄存器和运算器之间的通路为 16 位。 内存单元的地址在送上地址总线之前，必须在 CPU 中处理、传输、暂时存放，对于 16 位 CPU，能一次性处理、传输、暂时存储 16 位的地址。 8086CPU 有 20 位地址总线，可以传送 20 位地址，达到 1MB 寻址能力。 ","date":"2023-07-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_02/:4:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_02/#8086cpu-的结构"},{"categories":["计算机体系结构"],"content":" 4.3 8086CPU 生成物理地址的过程8086CPU 采用一种在内部用两个 16 位地址合成的方法来形成一个 20 位的物理地址: CPU 中的相关部件提供两个 16 位的地址，一个称为段地址，另一个称为偏移地址； 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件； 地址加法器将两个 16 位地址合成为一个 20 位的物理地址； 地址加法器通过内部总线将 20 位物理地址送入输入输出控制电路； 输入输出控制电路将 20 位物理地址送上地址总线； 20 位物理地址被地址总线传送到存储器。 8086CPU 相关部件的逻辑结构 地址加法器采用 物理地址 = 段地址 × 16 + 偏移地址 的方法用段地址和偏移地址合成物理地址。 “段地址 × 16 + 偏移地址 = 物理地址” 的本质含义是：CPU 在访问内存时，用一个基础地址(段地址 × 16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。 内存并没有分段，段的划分来自于 CPU，由于 8086CPU 用 “基础地址(段地址 x 16) + 偏移地址 = 物理地址” 的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。 “基础地址 = 段地址 x 16”，因此段的起始地址也一定 16 的倍数；偏移地址为 16 位 ，16 位地址的寻址能力为 64KB ，所以一个段的长度最大为 64KB。 ","date":"2023-07-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_02/:4:3","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_02/#8086cpu-生成物理地址的过程"},{"categories":["计算机体系结构"],"content":" 5 CS 和 IP段地址在 8086CPU 的段寄存器中存放。8086CPU 有 4 个段寄存器：CS、DS、SS、ES。 CS 和 IP 是8086CPU 中两个最关键的寄存器，它们指示了 CPU 当前要读取指令的地址。CS 为代码段寄存器，IP 为指令指针寄存器。 8086 机中，任意时刻，CPU 将 CS:IP 指向的内容当作指令执行。 8086PC 读取和执行指令的相关部件 8086CPU 读取、执行一条指令的详细过程： CS、IP 中的内容送入地址加法器，地址加法器计算物理地址； 地址加法器将物理地址送入输入输出控制电路； 输入输出控制电路将物理地址送上地址总线； 从物理地址对应的内存单元中获取机器指令，将机器指令通过数据总线被送入 CPU； 输入输出控制电路将机器指令送入指令缓冲器； 读取一条指令后，IP 中的值自动増加，值为所读取指令的长度，以使 CPU 可以读取下一条指令； 执行控制器执行指令。转到步骤 1，重复这个过程。 8086CPU 读取、执行一条指令的简要过程描述： 从 CS:IP 指向的内存单元读取指令，读取的指令进入指令缓冲器； IP = IP + 所读取指令的长度，从而指向下一条指令； 操作执行器执行指令。转到步骤 1，重复这个过程。 在 8086CPU 加电启动或复位后(即 CPU 刚开始工作时) CS 和 IP 被设置为 CS=FFFFH，IP=0000H，即在 8086PC 机刚启动时，CPU 从内存 FFFFOH 单元中读取指令执行，FFFFOH 单元中的指令是 8086PC 机开机后执行的第一条指令。 在内存中，指令和数据没有任何区别，都是二进制信息，CPU 在工作的时候把有的信息看作指令，有的信息看作数据。CPU 将 CS、IP 中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。 ","date":"2023-07-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_02/:5:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_02/#cs-和-ip"},{"categories":["计算机体系结构"],"content":" 6 修改 CS、IP 的指令程序员可以通过改变 CS、IP 中的内容来控制 CPU 执行目标指令。 mov 指令不能用于设置 CS、IP 的值，mov 指令被称为传送指令。 jmp 指令可以用于设置 CS、IP 的值。能够改变 CS、IP 的 内容的指令被统称为转移指令。 jmp 指令用法 jmp 指令案例 jmp 指令功能 jmp 段地址:偏移地址 jmp 2AE3:3 执行后：CS=2AE3H，IP=0003H 同时修改 CS、IP 的内容 jmp 某一合法奇存器 jmp ax 执行后：IP = AX 用寄存器中的值修改 IP ","date":"2023-07-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_02/:6:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_02/#修改-csip-的指令"},{"categories":["计算机体系结构"],"content":" 7 代码段对于 8086PC 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N（N ≤ 64KB）的一组代码，存在一组地址连续、起始地址为 16 的 倍数的内存单元中。我们可以认为，这段内存是用来存放代码的，从而定义了一个代码段。 将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。 ","date":"2023-07-16","objectID":"/posts/computer_architecture/assemply_language/assemply_language_02/:7:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 寄存器","uri":"/posts/computer_architecture/assemply_language/assemply_language_02/#代码段"},{"categories":["计算机体系结构"],"content":"汇编语言 —— 基础知识","date":"2023-07-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_01/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 基础知识","uri":"/posts/computer_architecture/assemply_language/assemply_language_01/"},{"categories":["计算机体系结构"],"content":"汇编语言是直接在硬件之上工作的编程语言，需要了解硬件系统的结构，才能有效地应用汇编语言对其编程。 ","date":"2023-07-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_01/:0:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 基础知识","uri":"/posts/computer_architecture/assemply_language/assemply_language_01/#"},{"categories":["计算机体系结构"],"content":" 1 机器语言机器语言是机器指令的集合，每一种微处理器由于硬件设计和内部结构的不同，都有自己的机器指令集。 机器语言由 0、1 表示高低电平，有不易阅读、不易查错、难于辨别和查错等缺点。 ","date":"2023-07-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_01/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 基础知识","uri":"/posts/computer_architecture/assemply_language/assemply_language_01/#机器语言"},{"categories":["计算机体系结构"],"content":" 2 汇编语言汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。 将汇编指令转换为机器指令的翻译程序，称为编译器。 flowchart LR AI(Assembly Instructions) MC(Machine Code) Programer --\u003e|write| AI --\u003e Compiler --\u003e MC --\u003e|run| Computer 汇编语言由以下三类指令组成： 汇编指令：机器码的助记符，有对应机器码。 伪指令：没有对应机器码，由编译器执行，计算机不执行。 其他符号：如 +、-、*、/ 等，由编译器识别，没有对应机器码。 ","date":"2023-07-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_01/:2:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 基础知识","uri":"/posts/computer_architecture/assemply_language/assemply_language_01/#汇编语言"},{"categories":["计算机体系结构"],"content":" 3 CPU 对存储器的读写","date":"2023-07-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_01/:3:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 基础知识","uri":"/posts/computer_architecture/assemply_language/assemply_language_01/#cpu-对存储器的读写"},{"categories":["计算机体系结构"],"content":" 3.1 存储器、指令、数据和存储单元存储器，即内存，存放指令和数据。 指令和数据在内存或磁盘上没有任何区别，都是二进制信息。指令和数据是应用上的概念。对于同一个二进制信息，CPU 在工作时既可以将其看作指令，也可以将其看作信息。 存储单元，存储器被划分为若干个存储单元，从 0 开始顺序编号。一个存储单元可以存储一个 Byte (8 bit) 。 微机存储器的容量以字节为最小单元来计算。 1KB = 1024B ； 1MB = 1024KB ； 1GB = 1024MB ； 1TB = 1024GB 。 磁盘的容量单位同内存一样。 ","date":"2023-07-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_01/:3:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 基础知识","uri":"/posts/computer_architecture/assemply_language/assemply_language_01/#存储器指令数据和存储单元"},{"categories":["计算机体系结构"],"content":" 3.2 CPU 对存储器读写的流程CPU 想要进行数据的读写，必须和外部器件（芯片）进行以下三类信息交互： 地址信息：存储单元的地址； 控制信息：器件的选择，读或写的命令； 数据信息：读或写的数据。 电子计算机处理、传输的信息都是电信号，通过导线传送。连接 CPU 和其他芯片的导线称为总线，CPU 通过总线传送信息。 总线从逻辑上分为三类：地址总线、控制总线和数据总线。 CPU 从内存中读取数据的过程 CPU 从 3 号存储单元读取数据的过程： CPU 通过地址总线将地址信息 3 发出。 CPU 通过控制总线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。 存储器将 3 号单元中的数据 8 通过数据总线送入 CPU。 CPU 向 3 号单元写入数据 26 的过程： CPU 通过地址线将地址信息 3 发出。 CPU 通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入数据。 CPU 通过数据线将数据 26 送入内存的 3 号单元中。 用汇编指令表示 CPU 从 3 号存储单元读取数据：MOV AX,[3]。含义为传送 3 号单元的内容入 AX 寄存器。 寄存器是 CPU 中可以存储数据的器件，一个 CPU 中有多个寄存器。 AX 是其中一个寄存器的代号。 ","date":"2023-07-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_01/:3:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 基础知识","uri":"/posts/computer_architecture/assemply_language/assemply_language_01/#cpu-对存储器读写的流程"},{"categories":["计算机体系结构"],"content":" 3.3 地址总线、数据总线和控制总线CPU 通过地址总线来指定存储器单元。一个 CPU 有 N 根地址线，则可以说这个 CPU 的地址总线宽度为 N，这样的 CPU 最多可以寻找 2^N 个内存单元。 CPU 与内存或其他器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了 CPU 与其他器件进行数据传送时的一次数据传送量。8 根数据总线一次可传送一个 8 位二进制数据 (即一个字节)。 CPU 对外部器件的控制是通过控制总线来进行的。控制总线是一些不同控制线的集合。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。 ","date":"2023-07-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_01/:3:3","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 基础知识","uri":"/posts/computer_architecture/assemply_language/assemply_language_01/#地址总线数据总线和控制总线"},{"categories":["计算机体系结构"],"content":" 4 主板、接口卡和存储器芯片","date":"2023-07-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_01/:4:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 基础知识","uri":"/posts/computer_architecture/assemply_language/assemply_language_01/#主板接口卡和存储器芯片"},{"categories":["计算机体系结构"],"content":" 4.1 主板和接口卡主板上有核心器件和一些主要器件，这些器件通过总线(地址总线、数据总线、控制总线)相连。这些器件有 CPU、存储器、外围芯片组、扩展插槽等。扩展插槽上一般插有 RAM 内存条和各类接口卡。 CPU 对外部设备都不能直接控制，如显示器、音箱、打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡。扩展插槽通过总线和 CPU 相连，所以接口卡也通过总线同 CPU 相连。CPU 可以直接控制这些接口卡，从而实现 CPU 对外设的间接控制。 CPU 通过总线向接口卡发送命令，接口卡根据 CPU 的命令控制外设进行工作。 ","date":"2023-07-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_01/:4:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 基础知识","uri":"/posts/computer_architecture/assemply_language/assemply_language_01/#主板和接口卡"},{"categories":["计算机体系结构"],"content":" 4.2 存储器芯片存储器从读写属性上看分为两类：随机存储器(RAM)和只读存储器(ROM)。随机存储器可读可写，但必须带电存储，关机后存储的内容丢失：只读存储器只能读取不能写入，关机后其中的内容不丢失。 存储器从功能上分为以下 3 类： 随机存储器：用于存放供 CPU 使用的绝大部分程序和数据，一般由两个位置上的 RAM 组成，装在主板上的 RAM 和插在扩展插槽上的 RAM。 装有 BIOS 的 ROM：在主板和某些接口卡上插有存储相应 BIOS 的 ROM。例如，主板上的 ROM 中存储着主板的 BIOS(通常称为系统 BIOS)。显卡上的 ROM 中存储着显卡的 BIOS。 接口卡上的 RAM：某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有 RAM。显示卡上的 RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。 PC 机中各类存储器的逻辑连接 ","date":"2023-07-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_01/:4:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 基础知识","uri":"/posts/computer_architecture/assemply_language/assemply_language_01/#存储器芯片"},{"categories":["计算机体系结构"],"content":" 5 内存地址空间一个 CPU 的地址总线宽度为10，那么可以寻址 1024 个内存单元，这 1024 个可寻到的内存单元就构成这个 CPU 的内存地址空间。内存地址空间的大小受 CPU 地址总线宽度的限制。 所有的存储器（包括主存储器、各类接口卡的存储器等）都和 CPU 的总线相连，CPU 对它们进行读或写的时候都通过控制线发出内存读写命令。CPU 在操控它们的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。 所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU 在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。 将各类存储器看作一个逻辑存储器 ","date":"2023-07-10","objectID":"/posts/computer_architecture/assemply_language/assemply_language_01/:5:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 基础知识","uri":"/posts/computer_architecture/assemply_language/assemply_language_01/#内存地址空间"},{"categories":["计算机体系结构"],"content":"汇编语言 —— 前言","date":"2023-07-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_00/","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 前言","uri":"/posts/computer_architecture/assemply_language/assemply_language_00/"},{"categories":["计算机体系结构"],"content":" 1 前言本系列文章记录学习《汇编语言》——王爽 的知识点，为接下来系统学习操作系统打下基础。 ","date":"2023-07-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_00/:1:0","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 前言","uri":"/posts/computer_architecture/assemply_language/assemply_language_00/#前言"},{"categories":["计算机体系结构"],"content":" 1.1 学习汇编的目的 充分获得底层编程的体验； 深刻理解机器运行程序的机理。 ","date":"2023-07-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_00/:1:1","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 前言","uri":"/posts/computer_architecture/assemply_language/assemply_language_00/#学习汇编的目的"},{"categories":["计算机体系结构"],"content":" 1.2 学习汇编语言的重心通过学习关键指令来深入理解机器工作的基本原理，培养底层编程意识和思想。 ","date":"2023-07-09","objectID":"/posts/computer_architecture/assemply_language/assemply_language_00/:1:2","series":["汇编语言 阅读笔记"],"tags":["汇编语言"],"title":"汇编语言 —— 前言","uri":"/posts/computer_architecture/assemply_language/assemply_language_00/#学习汇编语言的重心"},{"categories":["数据结构与算法"],"content":"快速排序","date":"2023-07-08","objectID":"/posts/algs4/algs4_08/","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 快速排序","uri":"/posts/algs4/algs4_08/"},{"categories":["数据结构与算法"],"content":" 1 快速排序的优点 实现简单，适用于各种不同的输入数据，且在一般应用中比其他排序算法都要快的多； 原地排序，只需要很小的辅助栈的额外空间； 将长度为 N 的数组排序所需的时间和 N * lgN 成正比。 快速排序的缺点是非常脆弱，在实现时要非常小心才能避免低劣的性能。 ","date":"2023-07-08","objectID":"/posts/algs4/algs4_08/:1:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 快速排序","uri":"/posts/algs4/algs4_08/#快速排序的优点"},{"categories":["数据结构与算法"],"content":" 2 快速排序基本算法 Java public class Quick { /** * Rearranges the array in ascending order, using the natural order. * * @param a the array to be sorted */ public static void sort(Comparable[] a) { StdRandom.shuffle(a); sort(a, 0, a.length - 1); } // quicksort the subarray from a[lo] to a[hi] private static void sort(Comparable[] a, int lo, int hi) { if (hi \u003c= lo) return; int j = partition(a, lo, hi); sort(a, lo, j - 1); sort(a, j + 1, hi); } // partition the subarray a[lo..hi] so that a[lo..j-1] \u003c= a[j] \u003c= a[j+1..hi] // and return the index j. private static int partition(Comparable[] a, int lo, int hi) { int i = lo; int j = hi + 1; Comparable v = a[lo]; while (true) { // find item on lo to swap while (less(a[++i], v)) { if (i == hi) break; } // find item on hi to swap while (less(v, a[--j])) { if (j == lo) break; // redundant since a[lo] acts as sentinel } // check if pointers cross if (i \u003e= j) break; exch(a, i, j); } // put partitioning item v at a[j] exch(a, lo, j); // now, a[lo .. j-1] \u003c= a[j] \u003c= a[j+1 .. hi] return j; } // is v \u003c w ? private static boolean less(Comparable v, Comparable w) { if (v == w) return false; // optimization when reference equals return v.compareTo(w) \u003c 0; } // exchange a[i] and a[j] private static void exch(Object[] a, int i, int j) { Object swap = a[i]; a[i] = a[j]; a[j] = swap; } } 快速排序是一种分治的排序算法。它将一个数组切分成两个子数组，将两部分独立地排序。其与归并排序是互补的。 由于切分过程总是能排定一个元素，用归纳法可以证明递归能够正确地将数组排序：如果左子数组和右子数组都是有序的，那么由左子数组、切分元素和右子数组组成的结果数组也一定是有序的。 ","date":"2023-07-08","objectID":"/posts/algs4/algs4_08/:2:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 快速排序","uri":"/posts/algs4/algs4_08/#快速排序基本算法"},{"categories":["数据结构与算法"],"content":" 3 快速排序的性能特点由于快速排序切分方法的内循环简洁短小，相比归并排序与希尔排序，其内循环中很少移动数据，因此快速排序性能一般比其他的排序算法性能高。 快速排序的另一个特点是比较次数很少，快速排序的最好情况是每次都正好能将数组对半分。 ","date":"2023-07-08","objectID":"/posts/algs4/algs4_08/:3:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 快速排序","uri":"/posts/algs4/algs4_08/#快速排序的性能特点"},{"categories":["数据结构与算法"],"content":" 4 快速排序的算法改进 切换到插入排序。对于小数组，快速排序比插入排序慢。因为快速排序的 sort 递归方法在小数组中也会调用自己。 三取样切分。能够使得快速排序的切分效果更好，但代价是需要计算中位数。同时可以将取样元素放在数组末尾作为“哨兵”来去掉切分方法的边界测试。 熵最优排序。一个元素全部重复的子数组不需要继续排序，但是快速排序的基础算法还会继续将它切分为更小的数组。在含有大量重复元素的数组的情况下，快速排序会使元素全部重复的子数组经常出现，这部分的优化能够将当前线性对数级的性能提高到线性级别。 ","date":"2023-07-08","objectID":"/posts/algs4/algs4_08/:4:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 快速排序","uri":"/posts/algs4/algs4_08/#快速排序的算法改进"},{"categories":["数据结构与算法"],"content":" 4.1 快速排序的哨兵 Java public class QuickSentinel { public static void sort(Comparable[] a) { if (a == null || a.length \u003c 2) return; // 将数组的最大元素放在最右边作为哨兵，除非和相等的元素交换，否则该元素永远不会移动 int maxIndex = 0; for (int i = 1; i \u003c a.length; i++) { if (less(a[maxIndex], a[i])) { maxIndex = i; } } exch(a, maxIndex, a.length - 1); sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { if (lo \u003e= hi) return; int mid = partition(a, lo, hi); sort(a, lo, mid - 1); sort(a, mid + 1, hi); } private static int partition(Comparable[] a, int lo, int hi) { int i = lo, j = hi + 1; Comparable pivot = a[lo]; while (true) { while (less(a[++i], pivot)) { // 切分元素本身就是哨兵 } while (less(pivot, a[--j])) { // 右侧哨兵取消边界检查 } if (i \u003e= j) break; exch(a, i, j); } exch(a, lo, j); return j; } } ","date":"2023-07-08","objectID":"/posts/algs4/algs4_08/:4:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 快速排序","uri":"/posts/algs4/algs4_08/#快速排序的哨兵"},{"categories":["数据结构与算法"],"content":" 4.2 快速排序的非递归实现 Java class QuickNoRecursive { public static void sort(Comparable[] a) { if (a == null || a.length \u003c 2) return; Stack\u003cInteger\u003e stack = new Stack\u003c\u003e(); stack.push(0); stack.push(a.length - 1); sort(a, stack); } // 使用栈来模拟递归栈 private static void sort(Comparable[] a, Stack\u003cInteger\u003e stack) { while (!stack.isEmpty()) { int hi = stack.pop(); int lo = stack.pop(); if (lo \u003e= hi) continue; int mid = partition(a, lo, hi); // 先将较小的子数组压入栈，可以保证栈最多只会有 lgN 个元素 if (hi - mid \u003e mid - lo) { stack.push(mid + 1); stack.push(hi); stack.push(lo); stack.push(mid - 1); } else { stack.push(lo); stack.push(mid - 1); stack.push(mid + 1); stack.push(hi); } } } private static int partition(Comparable[] a, int lo, int hi) { int i = lo; int j = hi + 1; Comparable v = a[lo]; while (true) { while (less(a[++i], v)) { if (i == hi) break; } while (less(v, a[--j])) { if (j == lo) break; } if (i \u003e= j) break; exch(a, i, j); } exch(a, lo, j); return j; } } ","date":"2023-07-08","objectID":"/posts/algs4/algs4_08/:4:2","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 快速排序","uri":"/posts/algs4/algs4_08/#快速排序的非递归实现"},{"categories":["数据结构与算法"],"content":" 4.3 快速排序优化代码的实现 Java public class Quick { // cutoff to insertion sort, must be \u003e= 1 private static final int INSERTION_SORT_CUTOFF = 8; /** * Rearranges the array in ascending order, using the natural order. * @param a the array to be sorted */ public static void sort(Comparable[] a) { // StdRandom.shuffle(a); sort(a, 0, a.length - 1); } // quicksort the subarray from a[lo] to a[hi] private static void sort(Comparable[] a, int lo, int hi) { if (hi \u003c= lo) return; // cutoff to insertion sort (Insertion.sort() uses half-open intervals) int n = hi - lo + 1; if (n \u003c= INSERTION_SORT_CUTOFF) { Insertion.sort(a, lo, hi + 1); return; } int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); } // partition the subarray a[lo..hi] so that a[lo..j-1] \u003c= a[j] \u003c= a[j+1..hi] // and return the index j. private static int partition(Comparable[] a, int lo, int hi) { int n = hi - lo + 1; int m = median3(a, lo, lo + n/2, hi); // 取样确定切分元素 exch(a, m, lo); int i = lo; int j = hi + 1; Comparable v = a[lo]; // 切分元素为最大、最小的情况，直接返回 // a[lo] is unique largest element while (less(a[++i], v)) { if (i == hi) { exch(a, lo, hi); return hi; } } // a[lo] is unique smallest element while (less(v, a[--j])) { if (j == lo + 1) return lo; } // the main loop while (i \u003c j) { exch(a, i, j); while (less(a[++i], v)) ; while (less(v, a[--j])) ; } // put partitioning item v at a[j] exch(a, lo, j); // now, a[lo .. j-1] \u003c= a[j] \u003c= a[j+1 .. hi] return j; } // return the index of the median element among a[i], a[j], and a[k] private static int median3(Comparable[] a, int i, int j, int k) { return (less(a[i], a[j]) ? (less(a[j], a[k]) ? j : less(a[i], a[k]) ? k : i) : (less(a[k], a[j]) ? j : less(a[k], a[i]) ? k : i)); } // is v \u003c w ? private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u003c 0; } // exchange a[i] and a[j] private static void exch(Object[] a, int i, int j) { Object swap = a[i]; a[i] = a[j]; a[j] = swap; } } 上述代码是对二向切分的快速排序的优化版本： 每次排序抽样三个元素，并以三个元素的中位数作为切分元素，优化切分效果； 使用插入排序提升小数组的排序速度； 对于切分元素 lo 是最大（最小）情况进行优化。 ","date":"2023-07-08","objectID":"/posts/algs4/algs4_08/:4:3","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 快速排序","uri":"/posts/algs4/algs4_08/#快速排序优化代码的实现"},{"categories":["数据结构与算法"],"content":" 5 三向切分的快速排序三向切分的快速排序适用于大量重复主键的随机数组。通过统计待排序数组的香农信息量，可以得出三向切分的快速排序所需要的比较次数的上下界。 三向切分的快速排序是信息量最优的。因为对于包含大量重复元素的数组，它将排序时间从线性对数级降低到了线性级别。三向切分的最坏情况正是所有主键均不相同。 ","date":"2023-07-08","objectID":"/posts/algs4/algs4_08/:5:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 快速排序","uri":"/posts/algs4/algs4_08/#三向切分的快速排序"},{"categories":["数据结构与算法"],"content":" 5.1 Dijkstra 三向切分的快速排序 Java public class Quick3way { /** * Rearranges the array in ascending order, using the natural order. * * @param a the array to be sorted */ public static void sort(Comparable[] a) { StdRandom.shuffle(a); sort(a, 0, a.length - 1); } // quicksort the subarray a[lo .. hi] using 3-way partitioning private static void sort(Comparable[] a, int lo, int hi) { if (hi \u003c= lo) return; int lt = lo, gt = hi; Comparable v = a[lo]; int i = lo + 1; while (i \u003c= gt) { // 从左到右遍历数组一次 int cmp = a[i].compareTo(v); // 使用 compareTo 比较元素，而非 less 方法 if (cmp \u003c 0) exch(a, lt++, i++); else if (cmp \u003e 0) exch(a, i, gt--); else i++; } // a[lo..lt-1] \u003c v = a[lt..gt] \u003c a[gt+1..hi]. sort(a, lo, lt - 1); sort(a, gt + 1, hi); } } 三向切分示意图 从左到右遍历数组一次，维护一个指针 lt 使得 a[lo..lt-1] 中的元素都小于 v，一个指针 gt 使得 a[gt+1..hi] 中的元素都大于 v，，一个指针 i 使得 a[lt..i-1] 中的元素都等于 v,a[i..gt] 中的元素都还未确定。 a[i] 小于 v，将 a[lt] 和 a[i] 交换，将 lt 和 i 加一; a[i] 大于 v，将 a[gt] 和 a[i] 交换，将 gt 减一; a[j] 等于 v，将 i 加一。 在数组中重复元素不多的普通情况下它比标准的二分法多使用了很多次交换。J.Bently 和 D.Mcllrov 的快速排序方法，使得三向切分的快速排序比归并排序和其他排序方法在包括重复元素很多的实际应用中更快。 ","date":"2023-07-08","objectID":"/posts/algs4/algs4_08/:5:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 快速排序","uri":"/posts/algs4/algs4_08/#dijkstra-三向切分的快速排序"},{"categories":["数据结构与算法"],"content":" 5.2 快速三向切分（J.Bently, D.Mcllrov） Java public class QuickBentleyMcIlroy { // cutoff to insertion sort, must be \u003e= 1 private static final int INSERTION_SORT_CUTOFF = 8; // cutoff to median-of-3 partitioning private static final int MEDIAN_OF_3_CUTOFF = 40; /** * Rearranges the array in ascending order, using the natural order. * @param a the array to be sorted */ public static void sort(Comparable[] a) { sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { int n = hi - lo + 1; // cutoff to insertion sort if (n \u003c= INSERTION_SORT_CUTOFF) { insertionSort(a, lo, hi); return; } // use median-of-3 as partitioning element else if (n \u003c= MEDIAN_OF_3_CUTOFF) { int m = median3(a, lo, lo + n/2, hi); exch(a, m, lo); } // use Tukey ninther as partitioning element else { int eps = n/8; int mid = lo + n/2; int m1 = median3(a, lo, lo + eps, lo + eps + eps); int m2 = median3(a, mid - eps, mid, mid + eps); int m3 = median3(a, hi - eps - eps, hi - eps, hi); int ninther = median3(a, m1, m2, m3); exch(a, ninther, lo); } // Bentley-McIlroy 3-way partitioning int i = lo, j = hi+1; int p = lo, q = hi+1; Comparable v = a[lo]; while (true) { while (less(a[++i], v)) if (i == hi) break; while (less(v, a[--j])) if (j == lo) break; // pointers cross if (i == j \u0026\u0026 eq(a[i], v)) exch(a, ++p, i); if (i \u003e= j) break; exch(a, i, j); if (eq(a[i], v)) exch(a, ++p, i); if (eq(a[j], v)) exch(a, --q, j); } i = j + 1; for (int k = lo; k \u003c= p; k++) exch(a, k, j--); for (int k = hi; k \u003e= q; k--) exch(a, k, i++); sort(a, lo, j); sort(a, i, hi); } // sort from a[lo] to a[hi] using insertion sort private static void insertionSort(Comparable[] a, int lo, int hi) { for (int i = lo; i \u003c= hi; i++) for (int j = i; j \u003e lo \u0026\u0026 less(a[j], a[j-1]); j--) exch(a, j, j-1); } // return the index of the median element among a[i], a[j], and a[k] private static int median3(Comparable[] a, int i, int j, int k) { return (less(a[i], a[j]) ? (less(a[j], a[k]) ? j : less(a[i], a[k]) ? k : i) : (less(a[k], a[j]) ? j : less(a[k], a[i]) ? k : i)); } // is v \u003c w ? private static boolean less(Comparable v, Comparable w) { if (v == w) return false; // optimization when reference equal return v.compareTo(w) \u003c 0; } // does v == w ? private static boolean eq(Comparable v, Comparable w) { if (v == w) return true; // optimization when reference equal return v.compareTo(w) == 0; } // exchange a[i] and a[j] private static void exch(Object[] a, int i, int j) { Object swap = a[i]; a[i] = a[j]; a[j] = swap; } } Bently McIlroy 三向切分 上述代码的基本思想是：将重复元素放置于子数组两端的方式实现的信息量最优的排序算法。 使用两个索引 p 和 q，使得 a[lo..p-1] 和 a[q+1..hi] 的元素都和 a[lo] 相等。 使用另外两个索引 i 和 j，使得 a[p..i-1] 小于 a[lo]，a[j+i..q]大于 a[lo]。 在内循环中加入代码，在 a[i] 和 v 相当时将其与 a[p] 交换(并将 p 加 1 )，在 a[j] 和 v 相等且 a[i] 和 a[j] 尚未和 v 进行比较之前将其与 a[q] 交换。 使用 Tukey’s ninther 方法来找出切分元素，选择三组，每组三个元素，分别取三组元素的中位数，然后取三个中位数的中位数作为切分元素，且在排序小数组时切换到插入排序。 ","date":"2023-07-08","objectID":"/posts/algs4/algs4_08/:5:2","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 快速排序","uri":"/posts/algs4/algs4_08/#快速三向切分jbently-dmcllrov"},{"categories":["系统设计"],"content":"记录在分布式锁开发中的两个编码规范。","date":"2023-06-26","objectID":"/posts/distributed_lock/distributed_lock_04/","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 两个编码规范","uri":"/posts/distributed_lock/distributed_lock_04/"},{"categories":["系统设计"],"content":"记录两个在编码过程中应该注意的编码规范，作为今后的编码原则。 ","date":"2023-06-26","objectID":"/posts/distributed_lock/distributed_lock_04/:0:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 两个编码规范","uri":"/posts/distributed_lock/distributed_lock_04/#"},{"categories":["系统设计"],"content":" 1 不要生吞异常Unlock 发送请求，如果发生 Socket 异常导致逻辑上解锁但实际上未解锁，是否需要将异常抛出？ 若不处理异常，Redis 中的 Key 会在设定的 30s 后过期，过期后可以将其与解锁看做等效，因此可以不处理异常； 若需要处理异常，则将该异常抛出，用户在使用 Unlock 时需要处理该异常。 原则：不要在代码中假设某种异常不会发生，或者忽略某中异常是无所谓的。 如果不将异常抛出或没有输出到日志，程序在出现莫名其妙的异常后会难以定位问题。因此不要忽略异常。 ","date":"2023-06-26","objectID":"/posts/distributed_lock/distributed_lock_04/:1:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 两个编码规范","uri":"/posts/distributed_lock/distributed_lock_04/#不要生吞异常"},{"categories":["系统设计"],"content":" 2 区分“判断”与“校验”在代码中，如果只有满足某种条件才能继续向后执行，应该使用校验。如果对于某个条件需要执行不同的分支，应该使用判断。 不要用判断取代校验，这会导致忽略某些异常。 C# // 校验，将异常抛出 internal void Unlock(string name) { if (! (_lockEntries.TryGetValue(name, out var entry) \u0026\u0026 entry.IsEntered())) { throw new InvalidStateException(\"The local lock is missing or the local lock is not held by the current thread. \" + $\"LockName: [{name}]\"); } entry.Exit(); entry.DecRef(); } csharp // 判断，会忽略异常，不便于今后的问题排查 internal void Unlock(string name) { if (_lockEntries.TryGetValue(name, out var entry) \u0026\u0026 entry.IsEntered()) { entry.Exit(); entry.DecRef(); } } ","date":"2023-06-26","objectID":"/posts/distributed_lock/distributed_lock_04/:2:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 两个编码规范","uri":"/posts/distributed_lock/distributed_lock_04/#区分判断与校验"},{"categories":["系统设计"],"content":"记录基于 Redis 的分布式锁异步续约机制设计。","date":"2023-06-25","objectID":"/posts/distributed_lock/distributed_lock_03/","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 异步续约机制","uri":"/posts/distributed_lock/distributed_lock_03/"},{"categories":["系统设计"],"content":"为了防止出现业务不能在锁过期时间内结束的问题，分布式锁的设计中引入了续约机制。 本章介绍分布式锁异步续约机制的设计。 ","date":"2023-06-25","objectID":"/posts/distributed_lock/distributed_lock_03/:0:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 异步续约机制","uri":"/posts/distributed_lock/distributed_lock_03/#"},{"categories":["系统设计"],"content":" 1 分布式锁续约调研一个续约的思路是，当线程成功获取分布式锁后，启动一个守护线程，每间隔一定的时间对分布式锁进行续约。当释放分布式锁后，关闭续约线程。如果每个成功获取分布式锁的线程都新开一个守护线程进行锁续约，则会导致应用新开大量的线程造成资源浪费。 开源项目 Redission 中分布式锁续约基于定时任务实现的（Netty 中的 HashedWheelTimer 工具类）。成功获取分布式锁后注册一个续约定时任务，由线程池中的线程调度执行定时任务，释放分布式锁时将定时任务取消。 ","date":"2023-06-25","objectID":"/posts/distributed_lock/distributed_lock_03/:1:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 异步续约机制","uri":"/posts/distributed_lock/distributed_lock_03/#分布式锁续约调研"},{"categories":["系统设计"],"content":" 2 分布式锁续约设计首先是分布式锁续约间隔问题：分布式锁默认 30s 过期，每 10s 续约一次（过期时间的 1/3，这样每个分布式锁能够容忍续约失败一次）。 分布式锁续约流程如下： 当线程第一次（重入次数为 1）成功获取分布式锁，生成一个 RenewEntry 的续约信息对象，对象以续约时间戳由小到大排序添加到一个阻塞优先队列中； 启动一个固定线程的线程池，续约线程从阻塞优先队列中获取续约对象进行续约操作： 如果续约对象对应的分布式锁已经释放，续约线程不做任何操作； 如果续约成功，则更新下次的续约时间戳，重新将续约对象放入阻塞优先队列中（因为分布式锁未释放）； 如果续约失败（非异常原因导致失败，比如 Key 过期或被删除等），则向客户端通知续约失败； 如果续约异常（Socket、IO 等异常），连续两次续约异常需要向客户端通知续约失败，仅一次续约异常则更新下次的续约时间戳，重新将续约对象放入阻塞优先队列中。 分布式锁续约设计 ","date":"2023-06-25","objectID":"/posts/distributed_lock/distributed_lock_03/:2:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 异步续约机制","uri":"/posts/distributed_lock/distributed_lock_03/#分布式锁续约设计"},{"categories":["系统设计"],"content":" 3 阻塞优先队列的实现阻塞优先队列的实现的思路：在非阻塞优先队列的基础上，通过锁的通知和等待机制来实现阻塞优先队列。这里涉及到一些线程同步的知识。 Monitor.Pulse：通知在锁对象就绪队列中的一个线程，通知锁对象的状态已改变。只有持有锁对象的线程才能调用 Pulse 方法。 Monitor.Wait ：释放当前占有的锁对象并阻塞当前线程，直到当前线程重新获取锁；如果指定了超时时间，则会在超时时间过去后，将当前线程放入锁对象就绪队列中。 C# internal class RenewEntryPriorityBlockingQueue\u003cT\u003e where T : RenewEntry { private readonly object _locker = new object(); internal void Offer(T item) { Monitor.Enter(_locker); GrowIfNecessary(); try { Insert(item); // Offer 线程在插入数据后 // 通知等待的续约线程，已经有新数据加入到优先队列中 Monitor.Pulse(_locker); } finally { Monitor.Exit(_locker); } } internal T Poll() { Monitor.Enter(_locker); T item; try { var waitTime = DistributedLockConfig.Instance.RenewThreadPollIntervalMilliseconds; while ((item = Peek()) == null || (waitTime = item.TimeToRenew()) \u003e 0) { // 续约线程在优先队列无数据，或队列中第一个元素未到续约时间时 // 需要进行阻塞等待 Monitor.Wait(_locker, waitTime); waitTime = DistributedLockConfig.Instance.RenewThreadPollIntervalMilliseconds; } item = Delete(); } finally { Monitor.Exit(_locker); } return item; } } 上述代码中 Insert、Delete、Peek 等方法为优先队列的基本 API 操作。 ","date":"2023-06-25","objectID":"/posts/distributed_lock/distributed_lock_03/:3:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 异步续约机制","uri":"/posts/distributed_lock/distributed_lock_03/#阻塞优先队列的实现"},{"categories":["系统设计"],"content":" 4 续约失败通知的实现续约失败通知的实现使用的 C# 提供的 Cancellation 机制。 ","date":"2023-06-25","objectID":"/posts/distributed_lock/distributed_lock_03/:4:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 异步续约机制","uri":"/posts/distributed_lock/distributed_lock_03/#续约失败通知的实现"},{"categories":["系统设计"],"content":" 5 分布式锁失效场景由于分布式锁使用单点锁实现，并且由于 Redis 本身的局限性，导致有如下锁失效场景： 异步复制：在锁未同步到从节点时主节点宕机，此时客户端认为拿到锁，但主从切换后锁已丢失； 缓存淘汰LRU/LFU有淘汰锁的可能性； 同一把锁连续两次续约失败且期间并未解锁，锁会因过期而导致失效。 其中，异步复制导致的锁失效问题，可以使用 WAIT 命令解决（Redission 中有实现），但本设计不实现。 ","date":"2023-06-25","objectID":"/posts/distributed_lock/distributed_lock_03/:5:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 异步续约机制","uri":"/posts/distributed_lock/distributed_lock_03/#分布式锁失效场景"},{"categories":["系统设计"],"content":"记录基于 Redis 的分布式锁加锁住流程设计。","date":"2023-06-24","objectID":"/posts/distributed_lock/distributed_lock_02/","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 加锁主流程","uri":"/posts/distributed_lock/distributed_lock_02/"},{"categories":["系统设计"],"content":"本章介绍分布式锁 Lock、TryLock 接口的加锁主流程。 ","date":"2023-06-24","objectID":"/posts/distributed_lock/distributed_lock_02/:0:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 加锁主流程","uri":"/posts/distributed_lock/distributed_lock_02/#"},{"categories":["系统设计"],"content":" 1 Lock 接口的加锁主流程对于 Lock 接口，应该轮询尝试加锁，直到加锁成功，否则 Sleep 一段时间，以降低 Redis 请求量。由此我们可以得到初步的加锁代码如下： C# public override void Lock(long leaseTime) { Checker.CheckLeaseTime(leaseTime); while (true) { // 尝试向 Redis 发送请求加锁，返回加锁是否成功 if (TryLockInternal(leaseTime)) { return; } Thread.Sleep(DistributedLockConfig.Instance.RetryIntervalMilliseconds); } } 但在多线程争抢同一分布式锁的场景下，上述加锁流程会向 Redis 发出不必要的请求： 不必要的请求 如上图，该场景下有 3 进程，每个进程包含 5 个线程，这些线程都去争抢同一把分布式锁，那么所有线程都会向 Redis 轮询请求分布式锁。然而经过分析，如果在一个进程内，有一个线程正在争抢分布式锁，其他线程并不需要去争抢，因此这些线程的轮询请求可以被优化掉。 这里使用一个内部锁去控制在一个进程内只有一个线程去轮询争抢分布式锁，优化后的效果如下图所示： 使用内部锁优化请求量 如上图，红色实线表示该线程正持有分布式锁；虚线表示线程正轮询请求分布式锁。线程必须先持有内部锁后，才能轮询请求锁，请求锁成功后，需要释放内部锁。优化后的代码如下： C# public override void Lock(long leaseTime) { Checker.CheckLeaseTime(leaseTime); // 尝试获取一次分布式锁 if (TryLockInternal(leaseTime)) { return; } // 获取分布式锁失败，需要获取内部锁后，轮询请求分布式锁 // 只有一个线程会持有内部锁，保证只有一个线程进入轮询代码块 LocalLockManager.Instance.Lock(_entryName); try { while (true) { if (TryLockInternal(leaseTime)) { return; } Thread.Sleep(DistributedLockConfig.Instance.RetryIntervalMilliseconds); } } finally { // 释放内部锁 LocalLockManager.Instance.Unlock(_entryName); } } ","date":"2023-06-24","objectID":"/posts/distributed_lock/distributed_lock_02/:1:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 加锁主流程","uri":"/posts/distributed_lock/distributed_lock_02/#lock-接口的加锁主流程"},{"categories":["系统设计"],"content":" 2 LocalLockManager我们可以注意到优化后的加锁流程中，引入了一个单例的 LocalLockManager，其实际上是一个并发字典。引入这个类是因为，不同的分布式锁对应不同的内部锁，我们需要将这些内部锁对象统一管理，即通过 LocalLockManager 来创建或释放内部锁对象。 ","date":"2023-06-24","objectID":"/posts/distributed_lock/distributed_lock_02/:2:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 加锁主流程","uri":"/posts/distributed_lock/distributed_lock_02/#locallockmanager"},{"categories":["系统设计"],"content":" 2.1 LockEntry 生命周期管理LockEntry 是通过引用计数算法管理的内部锁的封装。 当一个线程需要轮询重试时，需要先从 LocalLockManager 中获取对应的 LockEntry，再去尝试持有内部锁；如果 LockEntry 不存在，则会创建一个 LockEntry，并将其添加到 LocalLockManager 中，再尝试持有内部锁。 当一个线程轮询重试结束时，线程需要释放内部锁，这时线程还需要判断是否有其他线程正在等待内部锁。如果没有其他线程等待内部锁，则需要将这个内部锁从 LocalLockManager 中移除。这也是为何需要引用计数算法的原因，因为需要判断是否有其他线程等待，且需要保证移除操作的线程安全。 此处存在两个线程安全问题： 从 LocalLockManager 中获取 LockEntry 时，可能出现多个线程均判断 LockEntry 不存在，从而导致之后的 LocalLockManager 添加操作线程不安全； 线程成功获取 LockEntry，尝试增加 LockEntry 的引用计数时，另一个线程将该 LockEntry 从 LocalLockManager 中移除。 这里通过一个循环操作，和引用计数的 TryIncRef 操作，解决上述两个线程安全问题： csharp private LockEntry GetLockEntry(string name) { while (true) { if (_lockEntries.TryGetValue(name, out var entry)) { if (entry.TryIncRef()) { return entry; } } var newEntry = new LockEntry(name); if (_lockEntries.TryAdd(name, newEntry)) { return newEntry; } } } 对于第一个线程安全问题，线程 A 与线程 B 同时执行 TryAdd 方法，仅会有一个线程添加成功，比如线程 A 添加成功，线程 B 则会进入下一个循环，这样就保证了 LocalLockManager 添加操作的线程安全。 对于第二个线程安全问题，线程 A 执行 TryGetValue 成功获取了 LockEntry，线程 B 将引用计数减至 0 后，将 LockEntry 从 LocalLockManager 中移除，此时线程 A 执行 TryIncRef 将失败，并进入下一个循环，重新尝试获取 LockEntry。 ","date":"2023-06-24","objectID":"/posts/distributed_lock/distributed_lock_02/:2:1","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 加锁主流程","uri":"/posts/distributed_lock/distributed_lock_02/#lockentry-生命周期管理"},{"categories":["系统设计"],"content":" 3 引用计数算法 In computer science, reference counting is a programming technique of storing the number of references, pointers, or handles to a resource, such as an object, a block of memory, disk space, and others. In garbage collection algorithms, reference counts may be used to deallocate objects that are no longer needed. 对于一个实现了引用计数的对象，引用计数算法能够跟踪有多少引用处于活动状态。当引用的数量降至 0，我们可以安全的释放该对象的内存。 引用计数也是实现基本的垃圾回收算法的方式。 如果一个对象在多线程环境中需要安全关闭，可以考虑使用引用计数算法。 本实现借鉴了 ElasticSearch 中的实现：ElasticSearch 引用计数算法。 引用计数算法有两个核心操作：TryIncRef 和 DecRef。 csharp internal abstract class AbstractRefCounted : IRefCounted { private long _refCount = 1; public bool TryIncRef() { do { long i = Interlocked.Read(ref _refCount); if (i \u003e 0) { if (Interlocked.CompareExchange(ref _refCount, i + 1, i) == i) { return true; } } else { return false; } } while (true); } public bool DecRef() { long i = Interlocked.Decrement(ref _refCount); if (i == 0) { CloseInternal(); return true; } return false; } } DecRef 方法能够保证在引用计数降至 0 时执行一次 CloseInternal 方法，由于 Interlocked.Decrement() 是原子操作，因此在多线程环境下能够保证只有一个线程执行 CloseInternal 方法，即保证引用计数对象的安全关闭。 ","date":"2023-06-24","objectID":"/posts/distributed_lock/distributed_lock_02/:3:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 加锁主流程","uri":"/posts/distributed_lock/distributed_lock_02/#引用计数算法"},{"categories":["系统设计"],"content":" 4 TryLockInternal 方法简单介绍一下 TryLockInternal 方法。 TryLockInternal 方法向 Redis 服务端发送一次加锁请求，如果加锁成功，执行续约与重入相关代码，返回 true，否则返回 false。 csharp protected bool TryLockInternal(long leaseTime) { // 向 Redis 发送加锁请求 var pttl = LuaHelper.TryLock(_keyspace, _tenantId, _lockName, GetClientId(), leaseTime); // 加锁成功 // 在正常情况下，只有一个线程能够加锁成功，即只有一个线程能进入该代码块 if (pttl \u003e 0) { if (TryGetRenewEntry(out var oldEntry)) { // 已注册续约队列，则仅增加重入次数 oldEntry.IncreaseReentrantCount(); } else { var renewEntry = new RenewEntry(this, GetClientId(), leaseTime, pttl); _threadIds.TryAdd(Thread.CurrentThread.ManagedThreadId, renewEntry); // 未注册续约队列，则加入到续约队列 RenewManager.Instance.AddEntry(renewEntry); } return true; } return false; } ","date":"2023-06-24","objectID":"/posts/distributed_lock/distributed_lock_02/:4:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 加锁主流程","uri":"/posts/distributed_lock/distributed_lock_02/#trylockinternal-方法"},{"categories":["系统设计"],"content":"记录基于 Redis 的分布式锁的基本特性。","date":"2023-06-23","objectID":"/posts/distributed_lock/distributed_lock_01/","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 基本特性的设计与实现","uri":"/posts/distributed_lock/distributed_lock_01/"},{"categories":["系统设计"],"content":"上一章节，我们简要介绍了分布式锁的特性。这一章，我们介绍分布式锁基本特性的设计与实现，包括：互斥性、避免死锁、高可用性和可重入性。 分布式锁使用 Redis 中的 Hash 数据结构实现。Hash 的 Key 保存分布式锁的名字，相同的 Key 代表同一把分布式锁。 ","date":"2023-06-23","objectID":"/posts/distributed_lock/distributed_lock_01/:0:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 基本特性的设计与实现","uri":"/posts/distributed_lock/distributed_lock_01/#"},{"categories":["系统设计"],"content":" 1 互斥性与可重入性分布式锁的互斥性，即在任何场景下，只能有一个客户端能够持有分布式锁。那么 Redis 服务端需要记录下是哪一个进程的哪一个线程持有分布式锁。 分布式锁的可重入性，即一个线程获取分布式锁后，还可以再次获取锁。那么 Redis 服务端需要记录下哪一个线程重入哪一把分布式锁多少次。 为满足这两个特性，我们做如下的设计： Key 保存分布式锁的名字，相同的 Key 代表同一把分布式锁； Field 保存分布式锁对象的GUID和持有锁的线程ID，每个分布式锁对象会生成一个GUID，这个GUID同时也记录了进程信息； Value 保存重入次数。 这样便保证了分布式锁的互斥性，并实现了可重入性。 ","date":"2023-06-23","objectID":"/posts/distributed_lock/distributed_lock_01/:1:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 基本特性的设计与实现","uri":"/posts/distributed_lock/distributed_lock_01/#互斥性与可重入性"},{"categories":["系统设计"],"content":" 2 避免死锁避免死锁，已经获取分布式锁的客户端崩溃，其他的客户端也应该能够获取分布式锁。如果分布式锁得不到释放，其他线程将会一直阻塞。 避免死锁的常用方法，便是给分布式锁一个过期时间，这样即使客户端崩溃，分布式锁过期后会得到释放，其他线程便能够得到执行。 我们的设计中，默认的过期时间为 30s。 ","date":"2023-06-23","objectID":"/posts/distributed_lock/distributed_lock_01/:2:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 基本特性的设计与实现","uri":"/posts/distributed_lock/distributed_lock_01/#避免死锁"},{"categories":["系统设计"],"content":" 3 加锁解锁操作的实现通过互斥性、可重入性和避免死锁这 3 个特性，我们可以实现分布式锁的加锁与解锁操作。 分布式锁的加锁和解锁操作通过 Lua 实现，这是因为我们需要保证分布式锁的加锁与解锁操作是原子操作。 加锁操作脚本如下所示： Lua local function TryLock(key, field, leaseTime) if ((redis.call('EXISTS', key) == 0) or (redis.call('HEXISTS', key, field) == 1)) then redis.call('HINCRBY', key, field, 1) redis.call('PEXPIRE', key, leaseTime) return redis.call('PTTL', key) end return -2 end return TryLock(KEYS[1], ARGV[1], ARGV[2]) 解锁操作脚本如下所示： Lua local function Unlock(key, field) if (redis.call('HEXISTS', key, field) == 0) then return 0 end local counter = redis.call('HINCRBY', key, field, -1) if (counter \u003c 1) then redis.call('DEL', key) end return 1 end return Unlock(KEYS[1], ARGV[1], ARGV[2]) ","date":"2023-06-23","objectID":"/posts/distributed_lock/distributed_lock_01/:3:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 基本特性的设计与实现","uri":"/posts/distributed_lock/distributed_lock_01/#加锁解锁操作的实现"},{"categories":["系统设计"],"content":" 4 高可用性分布式锁的高可用性通过 Redis 服务的高可用性来保障。Redis 服务采用集群模式保障 Redis 服务的高可用。 ","date":"2023-06-23","objectID":"/posts/distributed_lock/distributed_lock_01/:4:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 基本特性的设计与实现","uri":"/posts/distributed_lock/distributed_lock_01/#高可用性"},{"categories":["系统设计"],"content":"记录基于Redis的分布式锁设计流程。","date":"2023-06-22","objectID":"/posts/distributed_lock/distributed_lock_00/","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 分布式锁介绍","uri":"/posts/distributed_lock/distributed_lock_00/"},{"categories":["系统设计"],"content":" 1 分布式锁的使用场景分布式系统要访问共享资源，为了避免并发访问资源带来错误，我们为共享资源添加一把锁，让各个访问互斥，保证并发访问的安全性，这就是使用分布式锁的原因。 ","date":"2023-06-22","objectID":"/posts/distributed_lock/distributed_lock_00/:1:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 分布式锁介绍","uri":"/posts/distributed_lock/distributed_lock_00/#分布式锁的使用场景"},{"categories":["系统设计"],"content":" 2 分布式锁的特性一个可靠的分布式锁系统，应该满足以下三个最低保障： 相互排斥。在任何场景下，只能有一个客户端能够持有分布式锁； 避免死锁。即使已经获取分布式锁的客户端崩溃，其他的客户端也应该能够获取分布式锁； 高可用性。锁服务（Redis 集群）是高可用的，当一个 Redis 结点出现问题，能够自动切换到另一个 Redis 结点。并且，即使客户端释放锁的代码逻辑出现问题，锁最终会被释放，不会影响其他线程对共享资源的访问。 在满足以上条件下，我们设计的分布式锁还满足以下特性： 可重入性。一个线程获取分布式锁后，还可以再次获取锁； 非阻塞。提供非阻塞接口（TryLock），如果获取不到锁，不会无限期等待； 异步续约，Watch Dog 机制。如果操作共享资源的线程未执行完毕，Watch Dog 会不断地延长锁的过期时间，保证锁不会因为超时而被释放； 锁失效通知。如果探测到分布式锁失效，能够通知到客户端； 与本地锁相同的使用机制。分布式锁的使用方法与本地锁相同，提供与本地锁相同的抽象，即多线程争抢同一分布式锁对象的机制； 对 Redis 服务的低请求量。分布式锁的实现优化了不必要的锁争抢，从而降低 Redis 服务端的压力。 接下来的章节，会根据以上介绍的分布式锁的基本特性，逐步介绍本分布式锁的设计与实现。 ","date":"2023-06-22","objectID":"/posts/distributed_lock/distributed_lock_00/:2:0","series":["分布式锁设计与实现"],"tags":["Redis","分布式锁"],"title":"Redis 分布式锁设计 —— 分布式锁介绍","uri":"/posts/distributed_lock/distributed_lock_00/#分布式锁的特性"},{"categories":["数据结构与算法"],"content":"归并排序","date":"2023-05-21","objectID":"/posts/algs4/algs4_07/","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 归并排序","uri":"/posts/algs4/algs4_07/"},{"categories":["数据结构与算法"],"content":" 1 自顶向下的归并排序 Java public class Merge { public static void sort(Comparable[] a) { Comparable[] aux = new Comparable[a.length]; sort(a, aux, 0, a.length - 1); } // mergesort a[lo..hi] using auxiliary array aux[lo..hi] private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) { if (hi \u003c= lo) return; int mid = lo + (hi - lo) / 2; sort(a, aux, lo, mid); sort(a, aux, mid + 1, hi); merge(a, aux, lo, mid, hi); } // stably merge a[lo .. mid] with a[mid+1 ..hi] using aux[lo .. hi] private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) { // copy to aux[] for (int k = lo; k \u003c= hi; k++) { aux[k] = a[k]; } // merge back to a[] int i = lo, j = mid + 1; for (int k = lo; k \u003c= hi; k++) { if (i \u003e mid) a[k] = aux[j++]; else if (j \u003e hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; // to ensure stability else a[k] = aux[i++]; } } } ","date":"2023-05-21","objectID":"/posts/algs4/algs4_07/:1:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 归并排序","uri":"/posts/algs4/algs4_07/#自顶向下的归并排序"},{"categories":["数据结构与算法"],"content":" 1.1 自顶向下归并排序索引 Java public class Merge { // Returns a permutation that gives the elements in the array in ascending order. public static int[] indexSort(Comparable[] a) { int n = a.length; int[] index = new int[n]; for (int i = 0; i \u003c n; i++) index[i] = i; int[] aux = new int[n]; sort(a, index, aux, 0, n - 1); return index; } // mergesort a[lo..hi] using auxiliary array aux[lo..hi] private static void sort(Comparable[] a, int[] index, int[] aux, int lo, int hi) { if (hi \u003c= lo) return; int mid = lo + (hi - lo) / 2; sort(a, index, aux, lo, mid); sort(a, index, aux, mid + 1, hi); merge(a, index, aux, lo, mid, hi); } // stably merge a[lo .. mid] with a[mid+1 .. hi] using aux[lo .. hi] private static void merge(Comparable[] a, int[] index, int[] aux, int lo, int mid, int hi) { // copy to aux[] for (int k = lo; k \u003c= hi; k++) { aux[k] = index[k]; } // merge back to a[] int i = lo, j = mid + 1; for (int k = lo; k \u003c= hi; k++) { if (i \u003e mid) index[k] = aux[j++]; else if (j \u003e hi) index[k] = aux[i++]; else if (less(a[aux[j]], a[aux[i]])) index[k] = aux[j++]; else index[k] = aux[i++]; } } } ","date":"2023-05-21","objectID":"/posts/algs4/algs4_07/:1:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 归并排序","uri":"/posts/algs4/algs4_07/#自顶向下归并排序索引"},{"categories":["数据结构与算法"],"content":" 1.2 自顶向下归并排序的优化 对小规模子数组使用插入排序。使用插入排序处理小规模的子数组（比如长度小于 15），一般可以将归并排序的运行时间缩短 10% ~ 15%； 测试数组是否已经有序。添加判断条件若 a[mid] \u003c= a[mid + 1]，则此时数组已经是有序的，可以跳过 merge 方法； 不将元素复制到辅助数组。节省将数组复制到用于归并的辅助数组所用的时间。需要调用两种排序方法，一种将数据从输入数组排序到辅助数组，一种将数组从辅助数组排序到输入数组。在递归调用的每个层次交换输入数组和辅助数组的角色。 Java public class Merge { private static final int CUTOFF = 7; // cutoff to insertion sort public static void sort(Comparable[] a) { Comparable[] aux = a.clone(); sort(aux, a, 0, a.length - 1); } private static void sort(Comparable[] src, Comparable[] dst, int lo, int hi) { // 1. 对小规模子数组使用插入排序 if (hi \u003c= lo + CUTOFF) { insertionSort(dst, lo, hi); return; } int mid = lo + (hi - lo) / 2; sort(dst, src, lo, mid); // 递归调用的每个层次交换输入数组和辅助数组的角色 sort(dst, src, mid + 1, hi); // sort 方法每次递归的结果为：传入的参数 dst 有序 // 2. 测试数组是否有序以跳过 merge 方法 // using System.arraycopy() is a bit faster than loop if (!less(src[mid + 1], src[mid])) { System.arraycopy(src, lo, dst, lo, hi - lo + 1); return; } merge(src, dst, lo, mid, hi); } private static void merge(Comparable[] src, Comparable[] dst, int lo, int mid, int hi) { // 3. 不将元素复制到辅助数组 int i = lo, j = mid + 1; for (int k = lo; k \u003c= hi; k++) { if (i \u003e mid) dst[k] = src[j++]; else if (j \u003e hi) dst[k] = src[i++]; else if (less(src[j], src[i])) dst[k] = src[j++]; // to ensure stability else dst[k] = src[i++]; } } // sort from a[lo] to a[hi] using insertion sort private static void insertionSort(Comparable[] a, int lo, int hi) { for (int i = lo; i \u003c= hi; i++) for (int j = i; j \u003e lo \u0026\u0026 less(a[j], a[j - 1]); j--) exch(a, j, j - 1); } } ","date":"2023-05-21","objectID":"/posts/algs4/algs4_07/:1:2","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 归并排序","uri":"/posts/algs4/algs4_07/#自顶向下归并排序的优化"},{"categories":["数据结构与算法"],"content":" 2 自底向上的归并排序","date":"2023-05-21","objectID":"/posts/algs4/algs4_07/:2:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 归并排序","uri":"/posts/algs4/algs4_07/#自底向上的归并排序"},{"categories":["数据结构与算法"],"content":" 2.1 自底向上归并排序数组 Java public class Merge { public static void sort(Comparable[] a) { int n = a.length; Comparable[] aux = new Comparable[n]; for (int len = 1; len \u003c n; len *= 2) { for (int lo = 0; lo \u003c n - len; lo += len + len) { int mid = lo + len - 1; int hi = Math.min(lo + len + len - 1, n - 1); merge(a, aux, lo, mid, hi); } } } private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) { // copy to aux[] for (int k = lo; k \u003c= hi; k++) { aux[k] = a[k]; } // merge back to a[] int i = lo, j = mid + 1; for (int k = lo; k \u003c= hi; k++) { if (i \u003e mid) a[k] = aux[j++]; // this copying is unnecessary else if (j \u003e hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; } } } ","date":"2023-05-21","objectID":"/posts/algs4/algs4_07/:2:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 归并排序","uri":"/posts/algs4/algs4_07/#自底向上归并排序数组"},{"categories":["数据结构与算法"],"content":" 2.2 自底向上归并排序链表 Java class LinkedListNatureMerge { public static void sort(LinkedList\u003cComparable\u003e a) { if (a == null || a.size() \u003c 2) return; LinkedList.Node sentinel = a.new Node(null, a.first); while (true) { LinkedList.Node prev = sentinel; LinkedList.Node lo = prev.next; LinkedList.Node mid = findAscIndex(lo, a.last); if (mid == a.last) break; while (mid != a.last) { LinkedList.Node hi = findAscIndex(mid.next, a.last); prev = merge(prev, lo, mid, hi); if (a.last.next != null) a.last = prev; // 维护链表 last 指针 lo = prev.next; mid = findAscIndex(lo, a.last); } } a.first = sentinel.next; // 维护链表 first 指针 } private static LinkedList.Node merge(LinkedList.Node prev, LinkedList.Node lo, LinkedList.Node mid, LinkedList.Node hi) { LinkedList.Node next = hi.next; LinkedList.Node p1 = lo; LinkedList.Node p2 = mid.next; mid.next = null; hi.next = null; while (p1 != null \u0026\u0026 p2 != null) { if (less(p2.item, p1.item)) { prev.next = p2; p2 = p2.next; } else { prev.next = p1; p1 = p1.next; } prev = prev.next; } if (p1 == null) { prev.next = p2; } else { prev.next = p1; } while (prev.next != null) { prev = prev.next; } prev.next = next; return prev; } private static LinkedList.Node findAscIndex(LinkedList.Node node, LinkedList.Node last) { if (node == null) return last; while (node.next != null) { if (less(node.next.item, node.item)) return node; node = node.next; } return last; } public static boolean isSorted(LinkedList\u003cComparable\u003e a) { LinkedList.Node pointer = a.first; while (pointer.next != null) { if (less(pointer.next.item, pointer.item)) return false; pointer = pointer.next; } return true; } private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u003c 0; } static class LinkedList\u003cItem extends Comparable\u003e { Node first; Node last; private int size; LinkedList() { first = last = null; size = 0; } public void insert(Item item) { if (first == null) { first = last = new Node(item, null); } else { first = new Node(item, first); } size++; } public Item remove() { if (first == null) return null; Node temp = first; if (first == last) { first = last = null; } else { first = first.next; } size--; return temp.item; } public int size() { return size; } class Node { Item item; Node next; Node(Item item, Node next) { this.item = item; this.next = next; } } } } ","date":"2023-05-21","objectID":"/posts/algs4/algs4_07/:2:2","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 归并排序","uri":"/posts/algs4/algs4_07/#自底向上归并排序链表"},{"categories":["数据结构与算法"],"content":" 3 归并排序的特点归并排序是分治思想的典型应用。 归并排序的算法复杂度： 对于长度为 N 的任意数组，自底向上的归并排序需要 1/2NlgN 至 NlgN次比较，最多访问数组 6NlgN 次； 没有任何基于比较的算法能够保证使用少于 lg(N!) ~ NlgN次比较将长度为 N 的数组排序； 归并排序是一种渐进最优的基于比较排序的算法，归并排序在最坏情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是 ~NlgN。 ","date":"2023-05-21","objectID":"/posts/algs4/algs4_07/:3:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 归并排序","uri":"/posts/algs4/algs4_07/#归并排序的特点"},{"categories":["数据结构与算法"],"content":"选择排序、插入排序和希尔排序","date":"2023-04-20","objectID":"/posts/algs4/algs4_06/","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 初级排序算法","uri":"/posts/algs4/algs4_06/"},{"categories":["数据结构与算法"],"content":" 1 排序算法类的模版 Java public class Sort { public static void sort(Comparable[] a) { // 排序算法具体实现 } private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) \u003c 0; } private static void exch(Comparable[] a, int i, int j) { Comparable temp = a[i]; a[i] = a[j]; a[j] = temp; } private static void show(Comparable[] a) { for (int i = 0; i \u003c a.length; i++) StdOut.print(a[i] + \" \"); StdOut.println(); } private static boolean isSorted(Comparable[] a) { for (int i = 1; i \u003c a.length; i++) { if (less(a[i], a[i - 1])) return false; } return true; } } ","date":"2023-04-20","objectID":"/posts/algs4/algs4_06/:1:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 初级排序算法","uri":"/posts/algs4/algs4_06/#排序算法类的模版"},{"categories":["数据结构与算法"],"content":" 2 选择排序","date":"2023-04-20","objectID":"/posts/algs4/algs4_06/:2:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 初级排序算法","uri":"/posts/algs4/algs4_06/#选择排序"},{"categories":["数据结构与算法"],"content":" 2.1 选择排序算法描述首先，找到数组中最小的元素，其次，将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。直到将整个数组排序。 ","date":"2023-04-20","objectID":"/posts/algs4/algs4_06/:2:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 初级排序算法","uri":"/posts/algs4/algs4_06/#选择排序算法描述"},{"categories":["数据结构与算法"],"content":" 2.2 选择排序的实现 Java public class Selection { public static void sort(Comparable[] a) { int n = a.length; for (int i = 0; i \u003c n; i++) { int min = i; for (int j = i + 1; j \u003c n; j++) { if (less(a[j], a[min])) min = j; } exch(a, i, min); assert isSorted(a, 0, i); } assert isSorted(a); } } 算法将第 i 小的元素放到 a[i] 中。数组的第 i 个位置的左边是 i 个最小的元素且它们不会再被访问。 ","date":"2023-04-20","objectID":"/posts/algs4/algs4_06/:2:2","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 初级排序算法","uri":"/posts/algs4/algs4_06/#选择排序的实现"},{"categories":["数据结构与算法"],"content":" 2.3 选择排序的特点对于长度为 N 的数组，选择排序需要大约 (N^2) / 2 次比较和 N 次交换。 运行时间和输入无关。 数据移动是最少的。数据移动与数组长度线性相关。 ","date":"2023-04-20","objectID":"/posts/algs4/algs4_06/:2:3","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 初级排序算法","uri":"/posts/algs4/algs4_06/#选择排序的特点"},{"categories":["数据结构与算法"],"content":" 3 插入排序","date":"2023-04-20","objectID":"/posts/algs4/algs4_06/:3:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 初级排序算法","uri":"/posts/algs4/algs4_06/#插入排序"},{"categories":["数据结构与算法"],"content":" 3.1 插入排序算法描述初始状态，把第一个元素看做只有一个元素的有序序列，从第二个元素开始及其之后的元素是未排序序列。对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 ","date":"2023-04-20","objectID":"/posts/algs4/algs4_06/:3:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 初级排序算法","uri":"/posts/algs4/algs4_06/#插入排序算法描述"},{"categories":["数据结构与算法"],"content":" 3.2 插入排序的实现 Java public class Insertion { public static void sort(Comparable[] a) { int n = a.length; for (int i = 1; i \u003c n; i++) { for (int j = i; j \u003e 0 \u0026\u0026 less(a[j], a[j - 1]); j--) { exch(a, j, j - 1); } assert isSorted(a, 0, i); } assert isSorted(a); } public static void sort(Comparable[] a, int lo, int hi) { for (int i = lo + 1; i \u003c hi; i++) { for (int j = i; j \u003e lo \u0026\u0026 less(a[j], a[j - 1]); j--) { exch(a, j, j - 1); } } assert isSorted(a, lo, hi); } } 对于 1 到 N - 1 之间的每个 i，将 a[i] 与 a[0] 到 a[i - 1] 中比它小的所有元素依次有序地交换。在索引 i 由左向右变化的过程中，它左侧的元素总是有序的，当 i 到达数组右端时完成排序。 在内循环中将较大的元素都向右移动而不总是交换两个元素，可以大幅提高插入排序的速度。 Java public class InsertionSortWithoutExchange { public static void sort(Comparable[] a) { int n = a.length; for (int i = 1; i \u003c n; i++) { Comparable value = a[i]; int j; for (j = i; j \u003e 0 \u0026\u0026 less(value, a[j - 1]); j--) { a[j] = a[j - 1]; } a[j] = value; } assert isSorted(a, 0, n - 1); } } 先找出最小的元素并将其置于数组的最左边，这样能够规避判断边界条件 j \u003e 0 从而提高插入排序速度，这个元素被称为哨兵。 Java public class InsertionWithSentinel { public static void sort(Comparable[] a) { int min = 0; for (int i = 1; i \u003c a.length; i++) if (less(a[i], a[min])) min = i; exch(a, 0, min); for (int i = 2; i \u003c a.length; i++) { for (int j = i; less(j, j - 1); j--) { exch(a, j, j - 1); } } } } ","date":"2023-04-20","objectID":"/posts/algs4/algs4_06/:3:2","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 初级排序算法","uri":"/posts/algs4/algs4_06/#插入排序的实现"},{"categories":["数据结构与算法"],"content":" 3.3 插入排序的特点对于随机排列的长度为 N 且逐渐不重复的数组，平均情况下插入排序需要 ~(N^2)/4 次比较与交换。最坏情况下需要 ~(N^2)/2 次比较与交换。最好情况下需要 N - 1 次比较和 0 次交换。 插入排序所需时间取决于元素的初始顺序。因此插入排序适合实际应用中部分有序的非随机数组。 插入排序的比较和交换的次数相等。 ","date":"2023-04-20","objectID":"/posts/algs4/algs4_06/:3:3","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 初级排序算法","uri":"/posts/algs4/algs4_06/#插入排序的特点"},{"categories":["数据结构与算法"],"content":" 4 希尔排序","date":"2023-04-20","objectID":"/posts/algs4/algs4_06/:4:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 初级排序算法","uri":"/posts/algs4/algs4_06/#希尔排序"},{"categories":["数据结构与算法"],"content":" 4.1 希尔排序算法描述希尔排序是更高效的插入排序。 对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数维的一端移动到另一端。 希尔排序使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 h 有序数组。在进行排序时，如果 h 很大，我们就能将元素移动到很远的地方，为实现更小的 h 有序创造方便。对于任意以 1 结尾的 h 序列，我们都能够将数组排序。这就是希尔排序。 希尔排序比插入排序更高效的原因：排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。 ","date":"2023-04-20","objectID":"/posts/algs4/algs4_06/:4:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 初级排序算法","uri":"/posts/algs4/algs4_06/#希尔排序算法描述"},{"categories":["数据结构与算法"],"content":" 4.2 希尔排序的实现递增序列为 (3^k - 1) / 2 的希尔排序。 Java public class Shell { public static void sort(Comparable[] a) { int n = a.length; // 3x+1 increment sequence: 1, 4, 13, 40, 121, 364, 1093, ... int h = 1; while (h \u003c n / 3) h = 3 * h + 1; while (h \u003e= 1) { // h-sort the array for (int i = h; i \u003c n; i++) { for (int j = i; j \u003e= h \u0026\u0026 less(a[j], a[j - h]); j -= h) { exch(a, j, j - h); } } assert isHsorted(a, h); h /= 3; } assert isSorted(a); } // is the array h-sorted? private static boolean isHsorted(Comparable[] a, int h) { for (int i = h; i \u003c a.length; i++) if (less(a[i], a[i - h])) return false; return true; } } 也可以将希尔排序的递增序列存储在一个数组中。 Java class ShellSortKeepIncrementSequence { public static void sort(Comparable[] a) { int n = a.length; int[] incrementSequence = getIncrementSequence(n); for (int h : incrementSequence) { for (int i = h; i \u003c n; i++) { for (int j = i; j \u003e= h \u0026\u0026 less(a[j], a[j - h]); j -= h) { exch(a, j, j - h); } } } } private static int[] getIncrementSequence(int n) { int size = (int) (Math.log(2 * n + 1) / Math.log(3)); int[] incrementSequence = new int[size]; for (int h = 0, i = size - 1; i \u003e= 0; i--) { h = 3 * h + 1; incrementSequence[i] = h; } return incrementSequence; } } 一个更加高效的递增序列为 1，5，19，41, 109，209，505，929，2161，3905，8929，16 001，36 289，64 769，146 305，260 609。该序列通过 9 * (4^k) - 9 * (2^k) + 1 与 (4^k) - 3 * (2^k) + 1 综合得到 。在实际应用中可能可以将性能改进 20% ~ 40%。 Java class ShellSortHighPerformanceIncrementSequence { public static void sort(Comparable[] a) { int n = a.length; Stack\u003cInteger\u003e incrementSequence = getIncrementSequence(n); while (!incrementSequence.isEmpty()) { int h = incrementSequence.pop(); for (int i = h; i \u003c n; i++) { for (int j = i; j \u003e= h \u0026\u0026 less(a[j], a[j - h]); j -= h) { exch(a, j, j - h); } } } } private static Stack\u003cInteger\u003e getIncrementSequence(int n) { Stack\u003cInteger\u003e sequence = new Stack\u003c\u003e(); int value = -1; int k = 0; while (true) { value = (int) (9 * Math.pow(4, k) - 9 * Math.pow(2, k) + 1); if (value \u003c n) sequence.push(value); value = (int) (Math.pow(4, k + 2) - 3 * Math.pow(2, k + 2) + 1); if (value \u003c n) sequence.push(value); if (value \u003e= n) break; k++; } return sequence; } } ","date":"2023-04-20","objectID":"/posts/algs4/algs4_06/:4:2","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 初级排序算法","uri":"/posts/algs4/algs4_06/#希尔排序的实现"},{"categories":["数据结构与算法"],"content":" 4.3 希尔排序的特点希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大。 对于中等大小的数组它的运行时间是可以接受的。它的代码量很小，且不需要使用额外的内存空间。 解决一个排序问题时，可以先用希尔排序，然后再考虑是否值得将它替换为更加复杂的排序算法。 ","date":"2023-04-20","objectID":"/posts/algs4/algs4_06/:4:3","series":["算法第四版 阅读笔记"],"tags":["算法第四版","排序算法"],"title":"算法第四版 —— 初级排序算法","uri":"/posts/algs4/algs4_06/#希尔排序的特点"},{"categories":["中间件技术"],"content":"分析 Redis 内存碎片整理功能，给出控制内存碎片可行方案。","date":"2023-04-19","objectID":"/posts/redis_upgrade/redis_upgrade_02/","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/posts/redis_upgrade/redis_upgrade_02/"},{"categories":["中间件技术"],"content":" 1 内存碎片产生原因内存碎片产生有两种原因 ","date":"2023-04-19","objectID":"/posts/redis_upgrade/redis_upgrade_02/:1:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/posts/redis_upgrade/redis_upgrade_02/#内存碎片产生原因"},{"categories":["中间件技术"],"content":" 1.1 内存分配原因 To store user keys, Redis allocates at most as much memory as the maxmemory setting enables (however there are small extra allocations possible). Redis 在分配内存时有可能会分配少量额外空间。 Redis 封装的 zmalloc 方法会调用 ztrymalloc_usable 方法额外分配 PREFIX_SIZE 大小的空间。 C /* Try allocating memory, and return NULL if failed. * '*usable' is set to the usable size if non NULL. */ void *ztrymalloc_usable(size_t size, size_t *usable) { /* Possible overflow, return NULL, so that the caller can panic or handle a failed allocation. */ if (size \u003e= SIZE_MAX/2) return NULL; void *ptr = malloc(MALLOC_MIN_SIZE(size)+PREFIX_SIZE); if (!ptr) return NULL; #ifdef HAVE_MALLOC_SIZE size = zmalloc_size(ptr); update_zmalloc_stat_alloc(size); if (usable) *usable = size; return ptr; #else *((size_t*)ptr) = size; update_zmalloc_stat_alloc(size+PREFIX_SIZE); if (usable) *usable = size; return (char*)ptr+PREFIX_SIZE; #endif } 其次在默认内存分配器 Jemalloc 下，会按照固定大小分配内存，比如需要申请 6 bytes，但实际分配 8 bytes。 ","date":"2023-04-19","objectID":"/posts/redis_upgrade/redis_upgrade_02/:1:1","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/posts/redis_upgrade/redis_upgrade_02/#内存分配原因"},{"categories":["中间件技术"],"content":" 1.2 频繁修改 Redis 中数据 Redis will not always free up (return) memory to the OS when keys are removed. This is not something special about Redis, but it is how most malloc() implementations work. For example if you fill an instance with 5GB worth of data, and then remove the equivalent of 2GB of data, the Resident Set Size (also known as the RSS, which is the number of memory pages consumed by the process) will probably still be around 5GB, even if Redis will claim that the user memory is around 3GB. This happens because the underlying allocator can’t easily release the memory. For example often most of the removed keys were allocated in the same pages as the other keys that still exist. 在删除数据时，Redis 不会直接将该部分内存归还操作系统，原因是有可能有其他数据落在相同页上，这部分删除的内存也会产生内存碎片。 ","date":"2023-04-19","objectID":"/posts/redis_upgrade/redis_upgrade_02/:1:2","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/posts/redis_upgrade/redis_upgrade_02/#频繁修改-redis-中数据"},{"categories":["中间件技术"],"content":" 2 内存碎片率mem_fragmentation_ratio = used_memory_rss / used_memory 可以理解为 Redis 向操作系统申请的内存与 Redis 实际使用内存的比。 理想情况下内存碎片率维持在 1.03 最好。正常情况下在 1-1.5 之间。 ","date":"2023-04-19","objectID":"/posts/redis_upgrade/redis_upgrade_02/:2:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/posts/redis_upgrade/redis_upgrade_02/#内存碎片率"},{"categories":["中间件技术"],"content":" 3 内存碎片整理功能默认配置 conf activedefrag = 0 # 内存碎片整理总开关，默认不开启。 active-defrag-cycle-min = 1 # 内存碎片整理的 CPU 时间占总 CPU 时间不低于 1%。 active-defrag-cycle-max = 25 # 内存碎片整理的 CPU 时间占总 CPU 时间不高于 25%。 active-defrag-threshold-lower = 10 # 内存碎片率小于 10%，不进行内存碎片整理。 active-defrag-threshold-upper = 100 # 在 100% 碎片率时达到最大的碎片整理力度。 active-defrag-max-scan-fields = 1000 # key 中包含的 field 大于 1000 会被单独处理。 active-defrag-ignore-bytes = 100mb # 碎片总空间少于 100mb 不进行内存整理。 ","date":"2023-04-19","objectID":"/posts/redis_upgrade/redis_upgrade_02/:3:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/posts/redis_upgrade/redis_upgrade_02/#内存碎片整理功能默认配置"},{"categories":["中间件技术"],"content":" 4 内存碎片整理的实现内存碎片整理功能通过 activeDefragCycle 函数实现，该函数通过 serverCron 函数调用，在开启该功能后会被定时调用。一次完整的内存碎片整理过程需要多次调用 activeDefragCycle 函数，即会横跨多次定时任务。 ","date":"2023-04-19","objectID":"/posts/redis_upgrade/redis_upgrade_02/:4:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/posts/redis_upgrade/redis_upgrade_02/#内存碎片整理的实现"},{"categories":["中间件技术"],"content":" 4.1 控制占用 CPU 时间比率限制的实现通过 active-defrag-cycle-min、active-defrag-cycle-max、active-defrag-threshold-lower、active-defrag-threshold-upper 四个配置能够控制内存碎片整理功能占用 CPU 时间的百分比。 该百分比最终会被计算为每次执行 activeDefragCycle 函数的最大时间限制 timeLimit，从而控制每次执行内存碎片整理功能的时间。 C #define INTERPOLATE(x, x1, x2, y1, y2) ( (y1) + ((x)-(x1)) * ((y2)-(y1)) / ((x2)-(x1)) ) #define LIMIT(y, min, max) ((y)\u003c(min)? min: ((y)\u003e(max)? max: (y))) /* decide if defrag is needed, and at what CPU effort to invest in it */ void computeDefragCycles() { size_t frag_bytes; // 获得内存碎片率和内存碎片的总字节数 float frag_pct = getAllocatorFragmentation(\u0026frag_bytes); /* If we're not already running, and below the threshold, exit. */ // 如果当前未进行内存碎片整理，且内存碎片率和内存碎片总字节数不满足阈值要求，退出 if (!server.active_defrag_running) { if(frag_pct \u003c server.active_defrag_threshold_lower || frag_bytes \u003c server.active_defrag_ignore_bytes) return; } /* Calculate the adaptive aggressiveness of the defrag */ // 自适应计算内存碎片清理的 cpu 占用百分比 int cpu_pct = INTERPOLATE(frag_pct, server.active_defrag_threshold_lower, server.active_defrag_threshold_upper, server.active_defrag_cycle_min, server.active_defrag_cycle_max); // 将 cpu 占用百分比限制在 [active_defrag_cycle_min, active_defrag_cycle_max] cpu_pct = LIMIT(cpu_pct, server.active_defrag_cycle_min, server.active_defrag_cycle_max); /* We allow increasing the aggressiveness during a scan, but don't * reduce it. */ if (cpu_pct \u003e server.active_defrag_running) { // 记录比率 server.active_defrag_running = cpu_pct; serverLog(LL_VERBOSE, \"Starting active defrag, frag=%.0f%%, frag_bytes=%zu, cpu=%d%%\", frag_pct, frag_bytes, cpu_pct); } } 计算公式： cycle-min + (frag_pct - threshold_lower) * (cycle_max - cycle_min) / (threshold_upper - threshold_lower)。 若当前内存碎片率为 1.5，则计算出来的 cpu_pct = 14。 则 timelimit = 1000000 * server.active_defrag_running / server.hz / 100 = 1000000 * 14 / 10 / 100 = 14,000 μs = 14 ms。 该值计算出来后，会在每 16 次 scan，或每 512 次指针移动，或每 64 个 key 完成内存整理完毕后，判断运行时间是否超过运行时间限制，若超过则退出本次内存整理。 即在内存碎片率为 1.5 时，每次定时任务会花费 14ms 左右时间整理内存碎片。 ","date":"2023-04-19","objectID":"/posts/redis_upgrade/redis_upgrade_02/:4:1","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/posts/redis_upgrade/redis_upgrade_02/#控制占用-cpu-时间比率限制的实现"},{"categories":["中间件技术"],"content":" 4.2 内存碎片整理核心实现内存整理功能通过 scan 键空间实现。每次 scan 时会调用 defragScanCallback 回调函数，执行 scan 出来的 key 的内存碎片清理工作。 cursor = dictScan(db-\u003edict, cursor, defragScanCallback, defragDictBucketCallback, db); defragScanCallback 调用 defragKey 函数，先尝试整理 key 对象，再判断 value 对象的编码从而调用相关函数整理 value 对象。 最终都会调用 activeDefragAlloc 函数进行内存整理。内存整理的过程为：分配新内存、内存复制、释放旧内存。 C /* Defrag helper for generic allocations. * * returns NULL in case the allocation wasn't moved. * when it returns a non-null value, the old pointer was already released * and should NOT be accessed. */ void* activeDefragAlloc(void *ptr) { size_t size; void *newptr; if(!je_get_defrag_hint(ptr)) { server.stat_active_defrag_misses++; return NULL; } /* move this allocation to a new allocation. * make sure not to use the thread cache. so that we don't get back the same * pointers we try to free */ size = zmalloc_size(ptr); // 分配新内存 newptr = zmalloc_no_tcache(size); // 内存复制 memcpy(newptr, ptr, size); // 释放旧内存 zfree_no_tcache(ptr); return newptr; } 这样就完成了单个内存区域的内存整理。 ","date":"2023-04-19","objectID":"/posts/redis_upgrade/redis_upgrade_02/:4:2","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/posts/redis_upgrade/redis_upgrade_02/#内存碎片整理核心实现"},{"categories":["中间件技术"],"content":" 4.3 内存碎片整理大 Key 是否阻塞假设有一大 key 其拥有的元素为 fields 个。 在处理到该 key 时，会比较 fields 与 active-defrag-max-scan-fields 的大小，若 fields \u003e active-defrag-max-scan-fields，则将其标记为大 key 放在一个列表里，并跳过该 key 的内存整理。 C if (dictSize(d) \u003e server.active_defrag_max_scan_fields) defragLater(db, kde); else defragged += activeDefragSdsDict(d, DEFRAG_SDS_DICT_VAL_IS_SDS); 在 scan 下一个桶之前，会检查列表里是否有大 key 未完成内存整理，若有则会单独为大 key 进行内存整理。 C /* before scanning the next bucket, see if we have big keys left from the previous bucket to scan */ if (defragLaterStep(db, endtime)) { quit = 1; /* time is up, we didn't finish all the work */ break; /* this will exit the function and we'll continue on the next cycle */ } 在整理大 key 的内存时，也会分多次整理。会在每 16 次迭代，或每 512 个指针移动，或每 64 个 field 内存整理完毕后，判断运行时间是否超过运行时间限制，若超过则退出本次内存整理。 C do { int quit = 0; if (defragLaterItem(de, \u0026defrag_later_cursor, endtime,db-\u003eid)) quit = 1; /* time is up, we didn't finish all the work */ /* Once in 16 scan iterations, 512 pointer reallocations, or 64 fields * (if we have a lot of pointers in one hash bucket, or rehashing), * check if we reached the time limit. */ if (quit || (++iterations \u003e 16 || server.stat_active_defrag_hits - prev_defragged \u003e 512 || server.stat_active_defrag_scanned - prev_scanned \u003e 64)) { if (quit || ustime() \u003e endtime) { if(key_defragged != server.stat_active_defrag_hits) server.stat_active_defrag_key_hits++; else server.stat_active_defrag_key_misses++; return 1; } iterations = 0; prev_defragged = server.stat_active_defrag_hits; prev_scanned = server.stat_active_defrag_scanned; } } while(defrag_later_cursor); 即一个大 key 的内存整理会分多次处理，不会长时间阻塞主线程。 ","date":"2023-04-19","objectID":"/posts/redis_upgrade/redis_upgrade_02/:4:3","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/posts/redis_upgrade/redis_upgrade_02/#内存碎片整理大-key-是否阻塞"},{"categories":["中间件技术"],"content":" 5 手动内存整理 Memory Purge该命令只在使用 jemalloc 内存分配器下生效。 该命令清理内存脏页，和上述内存碎片整理功能管理的不是相同区域。 ","date":"2023-04-19","objectID":"/posts/redis_upgrade/redis_upgrade_02/:5:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/posts/redis_upgrade/redis_upgrade_02/#手动内存整理-memory-purge"},{"categories":["中间件技术"],"content":" 6 结论Redis 内存碎片整理功能是通过 scan 命令渐进式地整理每次迭代到的 key，每次调用的时间复杂度为 O(1), 完整执行完一次内存碎片整理功能的时间复杂度为 O(n)。 内存碎片整理大 key 会将大 key 分多次处理，不会长时间阻塞主线程。 内存碎片整理功能的核心作用是降低内存碎片率，提高内存利用率以节省内存成本。 但内存整理功能在主线程中执行，会阻塞主线程而降低 Redis 的性能。 ","date":"2023-04-19","objectID":"/posts/redis_upgrade/redis_upgrade_02/:6:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/posts/redis_upgrade/redis_upgrade_02/#结论"},{"categories":["中间件技术"],"content":" 7 参考资料Memory optimization | Redis redis/defrag.c at unstable · redis/redis · GitHub MEMORY PURGE | Redis ","date":"2023-04-19","objectID":"/posts/redis_upgrade/redis_upgrade_02/:7:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 内存碎片整理调研","uri":"/posts/redis_upgrade/redis_upgrade_02/#参考资料"},{"categories":["数据结构与算法"],"content":"算法第四版 —— Union-Find 算法","date":"2023-04-15","objectID":"/posts/algs4/algs4_05/","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— Union-Find 算法","uri":"/posts/algs4/algs4_05/"},{"categories":["数据结构与算法"],"content":" 1 动态连通性问题及其应用若整数对 (p, q) 是“相连”的，则： 自反性：p 和 p 是相连的； 对称性：如果 p 和 q 是相连的，那么 q 和 p 也是相连的； 传递性：如果 p 和 q 是相连的且 q 和 r 是相连的，那么 p 和 r 也是相连的。 当且仅当两个对象相连时它们才属于同一个等价类。 判断一对新的对象是否“相连”，这样的问题叫动态连通性问题。 ","date":"2023-04-15","objectID":"/posts/algs4/algs4_05/:1:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— Union-Find 算法","uri":"/posts/algs4/algs4_05/#动态连通性问题及其应用"},{"categories":["数据结构与算法"],"content":" 1.1 网络在大型计算机网络中，输入的整数表示主机(触点)，整数对表示网络(连接)，同一网络中的主机属于同一等价类(连通分量)。 在社交网络中，整数可以表示社交网络中的人，整数对表示朋友关系。 ","date":"2023-04-15","objectID":"/posts/algs4/algs4_05/:1:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— Union-Find 算法","uri":"/posts/algs4/algs4_05/#网络"},{"categories":["数据结构与算法"],"content":" 1.2 数学集合将每个整数看做属于不同的数学集合，每一个整数对则需要先判断是否在同一数学集合中。若不是，则将 p 所属集合与 q 所属集合归并到同一集合。 ","date":"2023-04-15","objectID":"/posts/algs4/algs4_05/:1:2","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— Union-Find 算法","uri":"/posts/algs4/algs4_05/#数学集合"},{"categories":["数据结构与算法"],"content":" 2 Union-Find 算法的 API Text public class UF UF(int N) 以整数标志 [0, N-1] 初始化 N 个触点 void union(int p, int q) 在 p 和 q 之间添加一条连接 int find(int p) p (0 \u003c= p \u003c= N-1) 所在的分量标识符 boolean connected(int p, int q) p 和 q 是否连通 int count() 连通分量的数量 ","date":"2023-04-15","objectID":"/posts/algs4/algs4_05/:2:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— Union-Find 算法","uri":"/posts/algs4/algs4_05/#union-find-算法的-api"},{"categories":["数据结构与算法"],"content":" 3 Union-Find 算法的实现基本的 UF 算法实现见如下代码，union 与 find 的详细实现分别见 Quick-Find，Quick-Union，Weighted Quick-Union，Quick-Union with Path Compresson 的实现。 Java public class UF { private int[] id; private int count; public UF(int n) { count = n; id = new int[n]; for (int i = 0; i \u003c n; i++) id[i] = i; } public void union(int p, int q); public int find(int p); public boolean connected(int p, int q) { return find(p) == find(q); } public int count() { return count; } private void validate(int p) { int n = id.length; if (p \u003c 0 || p \u003e= n) { throw new IllegalArgumentException(\"index \" + p + \" is not between 0 and \" + (n-1)); } } public static void main(String[] args) { int n = StdIn.readInt(); UF uf = new UF(n); while (!StdIn.isEmpty()) { int p = StdIn.readInt(); int q = StdIn.readInt(); if (uf.find(p) == uf.find(q)) continue; uf.union(p, q); StdOut.println(p + \" \" + q); } StdOut.println(uf.count() + \" components\"); } } ","date":"2023-04-15","objectID":"/posts/algs4/algs4_05/:3:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— Union-Find 算法","uri":"/posts/algs4/algs4_05/#union-find-算法的实现"},{"categories":["数据结构与算法"],"content":" 3.1 Quick-Find Java public class QuickFindUF { private int[] id; // id[i] = component identifier of i private int count; // number of components public QuickFindUF(int n) { count = n; id = new int[n]; for (int i = 0; i \u003c n; i++) id[i] = i; } public void union(int p, int q) { validate(p); validate(q); int pID = id[p]; // needed for correctness int qID = id[q]; // to reduce the number of array accesses // p and q are already in the same component if (pID == qID) return; for (int i = 0; i \u003c id.length; i++) if (id[i] == pID) id[i] = qID; count--; } public int find(int p) { validate(p); return id[p]; } } Quick-Find 算法中，find 方法的时间复杂度为 O(1)，但 union 方法的时间复杂度为 O(n)。 ","date":"2023-04-15","objectID":"/posts/algs4/algs4_05/:3:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— Union-Find 算法","uri":"/posts/algs4/algs4_05/#quick-find"},{"categories":["数据结构与算法"],"content":" 3.2 Quick-Union Java public class QuickUnionUF { private int[] parent; // parent[i] = parent of i private int count; // number of components public QuickUnionUF(int n) { parent = new int[n]; count = n; for (int i = 0; i \u003c n; i++) { parent[i] = i; } } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootP] = rootQ; count--; } public int find(int p) { validate(p); while (p != parent[p]) p = parent[p]; return p; } } Quick-Union 算法中，h 表示树的高度，find 方法的时间复杂度为 O(h)，union 方法的时间复杂度为 2·O(h) + 1 = O(h)。 ","date":"2023-04-15","objectID":"/posts/algs4/algs4_05/:3:2","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— Union-Find 算法","uri":"/posts/algs4/algs4_05/#quick-union"},{"categories":["数据结构与算法"],"content":" 3.3 Weighted Quick-Union Java public class WeightedQuickUnionUF { private int[] parent; // parent[i] = parent of i private int[] size; // size[i] = number of elements in subtree rooted at i private int count; // number of components public WeightedQuickUnionUF(int n) { count = n; parent = new int[n]; size = new int[n]; for (int i = 0; i \u003c n; i++) { parent[i] = i; size[i] = 1; } } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; // make smaller root point to larger one if (size[rootP] \u003c size[rootQ]) { parent[rootP] = rootQ; size[rootQ] += size[rootP]; } else { parent[rootQ] = rootP; size[rootP] += size[rootQ]; } count--; } public int find(int p) { validate(p); while (p != parent[p]) p = parent[p]; return p; } } 加权 Quick-Union 算法在最坏情况下，即归并的两个树大小总是相等，此时能够保证对数级别的性能 O(logN)。 加权 Quick-Union 算法能够在合理时间范围内处理大规模动态连通性问题。 ","date":"2023-04-15","objectID":"/posts/algs4/algs4_05/:3:3","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— Union-Find 算法","uri":"/posts/algs4/algs4_05/#weighted-quick-union"},{"categories":["数据结构与算法"],"content":" 3.4 Weighted Quick-Union with Path Compresson Java public class WeightedQuickUnionWithPathCompression { private final int[] parent; private final int[] size; private int count; WeightedQuickUnionWithPathCompression(int n) { parent = new int[n]; size = new int[n]; for (int i = 0; i \u003c n; i++) { parent[i] = i; size[i] = 1; } count = n; } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; if (size[rootP] \u003c size[rootQ]) { parent[rootP] = rootQ; size[rootQ] += size[rootP]; } else { parent[rootQ] = rootP; size[rootP] += size[rootQ]; } count--; } public int find(int p) { validate(p); int root = p; while (root != parent[root]) { root = parent[root]; } // Path Compression while (parent[p] != root) { int temp = parent[p]; parent[p] = root; p = temp; } return root; } } 路经压缩的加权 Quick-Union 算法，find 方法能够得到几乎完全扁平化的树，使得算法的均摊成本接近 O(1)。 路经压缩的加权 Quick-Union 算法是本题的最优算法。 ","date":"2023-04-15","objectID":"/posts/algs4/algs4_05/:3:4","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— Union-Find 算法","uri":"/posts/algs4/algs4_05/#weighted-quick-union-with-path-compresson"},{"categories":["数据结构与算法"],"content":"算法第四版 —— 算法分析","date":"2023-04-12","objectID":"/posts/algs4/algs4_04/","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 算法分析","uri":"/posts/algs4/algs4_04/"},{"categories":["数据结构与算法"],"content":" 1 算法分析的方法 Observe some feature of the natural world, generally with precise measurements. Hypothesize a model that is consistent with the observations. Predict events using the hypothesis. Verify the predictions by making further observations. Validate by repeating until the hypothesis and observations agree. ","date":"2023-04-12","objectID":"/posts/algs4/algs4_04/:1:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 算法分析","uri":"/posts/algs4/algs4_04/#算法分析的方法"},{"categories":["数据结构与算法"],"content":" 2 算法运行时间实验程序执行速度的快慢通常取决于问题的规模。 通过观察代码初步预测程序的执行时间。 使用类似 DoublingTest 方法不断增加问题规模并计时，进入“预测——验证”循环。 Java public class DoublingTest { public static double timeTrial(int N) { // Time ThreeSum.count() for N random 6-digit ints. int MAX = 1000000; int[] a = new int[N]; for (int i = 0; i \u003c N; i++) a[i] = StdRandom.uniformInt(-MAX, MAX); Stopwatch timer = new Stopwatch(); int cnt = ThreeSum.count(a); return timer.elapsedTime(); } public static void main(String[] args) { // Print table of running times. for (int N = 250; true; N += N) { // Print time for problem size N. double time = timeTrial(N); StdOut.printf(\"%7d %5.1f\\n\", N, time); } } } 分析实验数据，得到其运行时间的数学模型。 ","date":"2023-04-12","objectID":"/posts/algs4/algs4_04/:2:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 算法分析","uri":"/posts/algs4/algs4_04/#算法运行时间实验"},{"categories":["数据结构与算法"],"content":" 3 运行时间的数学模型得到运行时间的数学模型步骤：（书：P114） 确定输入模型，定义问题规模 识别内循环 根据内循环中的操作确定成本模型 对于给定的输入，判断这些操作的执行频率 ","date":"2023-04-12","objectID":"/posts/algs4/algs4_04/:3:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 算法分析","uri":"/posts/algs4/algs4_04/#运行时间的数学模型"},{"categories":["数据结构与算法"],"content":" 4 增长数量级 描述 增长的数量级 典型代码 说明 举例 常数级别 1 a = b + c 普通语句 两个数相加 对数级别 logN 二分查找 二分策略 二分查找 线性级别 N 循环 循环 循环查找最大元素 线性对数级别 NlogN 归并排序 Merge.sort 和 快速排序 Quick.sort 归并排序，快速排序 归并排序，快速排序 平方级别 N^2 选择排序 Selection.sort 和 插入排序 Insertion.sort 双层循环 选择排序，插入排序 立方级别 N^3 ThreeSum 三层循环 三层循环 三层循环 指数级别 2^N 第六章 穷举查找 检查所有子集 ","date":"2023-04-12","objectID":"/posts/algs4/algs4_04/:4:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 算法分析","uri":"/posts/algs4/algs4_04/#增长数量级"},{"categories":["数据结构与算法"],"content":" 5 倍率实验通过倍率实验能够简单有效地预测任意程序的性能并判断它们运行时间大致的增长数量级，但对比值没有极限的算法无效。 Java public class DoublingRatio { public static double timeTrial(int N) { // Time ThreeSum.count() for N random 6-digit ints. int MAX = 1000000; int[] a = new int[N]; for (int i = 0; i \u003c N; i++) a[i] = StdRandom.uniformInt(-MAX, MAX); Stopwatch timer = new Stopwatch(); int cnt = ThreeSum.count(a); return timer.elapsedTime(); } public static void main(String[] args) { double prev = timeTrial(125); for (int N = 250; true; N += N) { double time = timeTrial(N); StdOut.printf(\"%6d %7.1f \", N, time); StdOut.printf(\"%5.1f\\n\", time / prev); prev = time; } } } 在有性能问题的情况家应该考虑对编写过的所有程序进行倍率实验，以便能找到性能问题。 ","date":"2023-04-12","objectID":"/posts/algs4/algs4_04/:5:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 算法分析","uri":"/posts/algs4/algs4_04/#倍率实验"},{"categories":["数据结构与算法"],"content":"算法第四版 —— 背包、队列和栈","date":"2023-03-19","objectID":"/posts/algs4/algs4_03/","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 背包、队列和栈","uri":"/posts/algs4/algs4_03/"},{"categories":["数据结构与算法"],"content":" 1 背包背包 API： Text 背包 public class Bag\u003cItem\u003e implements Iterable\u003cItem\u003e Bag() 创建一个背包 void add(Item item) 添加一个元素 boolean isEmpty() 背包是否为空 int size() 背包中元素数量 背包是一种不支持从中删除元素的集合数据类型——他的目的是帮助用例收集元素并迭代遍历所有收集到的元素。 ","date":"2023-03-19","objectID":"/posts/algs4/algs4_03/:1:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 背包、队列和栈","uri":"/posts/algs4/algs4_03/#背包"},{"categories":["数据结构与算法"],"content":" 1.1 背包的链表实现 Java import java.util.Iterator; public class Bag\u003cItem\u003e implements Iterable\u003cItem\u003e { private Node first; private class Node { Item item; Node next; } public void add(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; } @Override public Iterator\u003cItem\u003e iterator() { return new ListIterator(); } private class ListIterator implements Iterator\u003cItem\u003e { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/posts/algs4/algs4_03/:1:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 背包、队列和栈","uri":"/posts/algs4/algs4_03/#背包的链表实现"},{"categories":["数据结构与算法"],"content":" 2 先进先出（FIFO）队列队列 API： Text 先进先出（FIFO）队列 public class Queue\u003cItem\u003e implements Interable\u003cItem\u003e Queue() 创建空队列 void enqueue(Item item) 添加一个元素 Item dequeue() 删除最早添加的元素 boolean isEmpty() 队列是否为空 int size() 队列中的元素数量 先进先出队列是一种基于先进先出（FIFO）策略的集合类型。 ","date":"2023-03-19","objectID":"/posts/algs4/algs4_03/:2:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 背包、队列和栈","uri":"/posts/algs4/algs4_03/#先进先出fifo队列"},{"categories":["数据结构与算法"],"content":" 2.1 队列的实现 2.1.1 队列的链表实现 Java import java.util.Iterator; public class Queue\u003cItem\u003e implements Iterable\u003cItem\u003e { private Node first; private Node last; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void enqueue(Item item) { Node oldLast = last; last = new Node(); last.item = item; last.next = null; if (isEmpty()) { first = last; } else { oldLast.next = last; } size++; } public Item dequeue() { Item item = first.item; first = first.next; if (isEmpty()) { last = null; } size--; return item; } @Override public Iterator\u003cItem\u003e iterator() { return new ListIterator(); } private class ListIterator implements Iterator\u003cItem\u003e { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/posts/algs4/algs4_03/:2:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 背包、队列和栈","uri":"/posts/algs4/algs4_03/#队列的实现"},{"categories":["数据结构与算法"],"content":" 2.1 队列的实现 2.1.1 队列的链表实现 Java import java.util.Iterator; public class Queue implements Iterable { private Node first; private Node last; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void enqueue(Item item) { Node oldLast = last; last = new Node(); last.item = item; last.next = null; if (isEmpty()) { first = last; } else { oldLast.next = last; } size++; } public Item dequeue() { Item item = first.item; first = first.next; if (isEmpty()) { last = null; } size--; return item; } @Override public Iterator iterator() { return new ListIterator(); } private class ListIterator implements Iterator { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/posts/algs4/algs4_03/:2:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 背包、队列和栈","uri":"/posts/algs4/algs4_03/#队列的链表实现"},{"categories":["数据结构与算法"],"content":" 3 后进先出（LIFO）栈栈 API： Text public class Stack\u003cItem\u003e implements Iterable\u003cItem\u003e Stack() 创建一个空栈 void push() 添加一个元素 Item pop() 删除最近添加的元素 boolean isEmpty() 栈是否为空 int size() 栈中元素数量 ","date":"2023-03-19","objectID":"/posts/algs4/algs4_03/:3:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 背包、队列和栈","uri":"/posts/algs4/algs4_03/#后进先出lifo栈"},{"categories":["数据结构与算法"],"content":" 3.1 栈的实现 3.1.1 栈的数组实现 Java import java.util.Iterator; public class ResizingArrayStack\u003cItem\u003e implements Iterable\u003cItem\u003e { private Item[] array = (Item[]) new Object[1]; private int size = 0; public boolean isEmpty() { return size == 0; } public int size() { return size; } public void push(Item item) { if (size == array.length) { resize(2 * array.length); } array[size++] = item; } public Item pop() { Item item = array[--size]; array[size] = null; if (size \u003e 0 \u0026\u0026 size == array.length / 4) { resize(array.length / 2); } return item; } private void resize(int length) { Item[] temp = (Item[]) new Object[length]; for (int i = 0; i \u003c size; i++) { temp[i] = array[i]; } array = temp; } @Override public Iterator\u003cItem\u003e iterator() { return new ReverseArrayIterator(); } private class ReverseArrayIterator implements Iterator\u003cItem\u003e { private int index = size; @Override public boolean hasNext() { return index \u003e 0; } @Override public Item next() { return array[--index]; } } } 3.1.2 栈的链表实现 Java import java.util.Iterator; public class Stack\u003cItem\u003e implements Iterable\u003cItem\u003e { private Node first; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void push(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; size++; } public Item pop() { Item item = first.item; first = first.next; size--; return item; } @Override public Iterator\u003cItem\u003e iterator() { return new ListIterator(); } private class ListIterator implements Iterator\u003cItem\u003e { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/posts/algs4/algs4_03/:3:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 背包、队列和栈","uri":"/posts/algs4/algs4_03/#栈的实现"},{"categories":["数据结构与算法"],"content":" 3.1 栈的实现 3.1.1 栈的数组实现 Java import java.util.Iterator; public class ResizingArrayStack implements Iterable { private Item[] array = (Item[]) new Object[1]; private int size = 0; public boolean isEmpty() { return size == 0; } public int size() { return size; } public void push(Item item) { if (size == array.length) { resize(2 * array.length); } array[size++] = item; } public Item pop() { Item item = array[--size]; array[size] = null; if (size \u003e 0 \u0026\u0026 size == array.length / 4) { resize(array.length / 2); } return item; } private void resize(int length) { Item[] temp = (Item[]) new Object[length]; for (int i = 0; i \u003c size; i++) { temp[i] = array[i]; } array = temp; } @Override public Iterator iterator() { return new ReverseArrayIterator(); } private class ReverseArrayIterator implements Iterator { private int index = size; @Override public boolean hasNext() { return index \u003e 0; } @Override public Item next() { return array[--index]; } } } 3.1.2 栈的链表实现 Java import java.util.Iterator; public class Stack implements Iterable { private Node first; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void push(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; size++; } public Item pop() { Item item = first.item; first = first.next; size--; return item; } @Override public Iterator iterator() { return new ListIterator(); } private class ListIterator implements Iterator { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/posts/algs4/algs4_03/:3:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 背包、队列和栈","uri":"/posts/algs4/algs4_03/#栈的数组实现"},{"categories":["数据结构与算法"],"content":" 3.1 栈的实现 3.1.1 栈的数组实现 Java import java.util.Iterator; public class ResizingArrayStack implements Iterable { private Item[] array = (Item[]) new Object[1]; private int size = 0; public boolean isEmpty() { return size == 0; } public int size() { return size; } public void push(Item item) { if (size == array.length) { resize(2 * array.length); } array[size++] = item; } public Item pop() { Item item = array[--size]; array[size] = null; if (size \u003e 0 \u0026\u0026 size == array.length / 4) { resize(array.length / 2); } return item; } private void resize(int length) { Item[] temp = (Item[]) new Object[length]; for (int i = 0; i \u003c size; i++) { temp[i] = array[i]; } array = temp; } @Override public Iterator iterator() { return new ReverseArrayIterator(); } private class ReverseArrayIterator implements Iterator { private int index = size; @Override public boolean hasNext() { return index \u003e 0; } @Override public Item next() { return array[--index]; } } } 3.1.2 栈的链表实现 Java import java.util.Iterator; public class Stack implements Iterable { private Node first; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void push(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; size++; } public Item pop() { Item item = first.item; first = first.next; size--; return item; } @Override public Iterator iterator() { return new ListIterator(); } private class ListIterator implements Iterator { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } ","date":"2023-03-19","objectID":"/posts/algs4/algs4_03/:3:1","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 背包、队列和栈","uri":"/posts/algs4/algs4_03/#栈的链表实现"},{"categories":["数据结构与算法"],"content":" 3.2 栈的应用Dijkstra 双栈算术表达式求值算法 Java public class Evaluate { public static void main(String[] args) { Stack\u003cString\u003e ops = new Stack\u003c\u003e(); Stack\u003cDouble\u003e vals = new Stack\u003c\u003e(); while (!StdIn.isEmpty()) { String s = StdIn.readString(); switch (s) { case \"(\" -\u003e { ; } case \"+\", \"-\", \"*\", \"/\", \"sqrt\" -\u003e ops.push(s); case \")\" -\u003e { String op = ops.pop(); double v = vals.pop(); v = switch (op) { case \"+\" -\u003e vals.pop() + v; case \"-\" -\u003e vals.pop() - v; case \"*\" -\u003e vals.pop() * v; case \"/\" -\u003e vals.pop() / v; case \"sqrt\" -\u003e Math.sqrt(v); default -\u003e v; }; vals.push(v); } default -\u003e vals.push(Double.parseDouble(s)); } } StdOut.println(vals.pop()); } } ","date":"2023-03-19","objectID":"/posts/algs4/algs4_03/:3:2","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 背包、队列和栈","uri":"/posts/algs4/algs4_03/#栈的应用"},{"categories":null,"content":"volatile 变量与线程安全","date":"2023-03-11","objectID":"/posts/others/technology/volatile_variable_and_thread_safety/","series":null,"tags":null,"title":"volatile 变量与线程安全","uri":"/posts/others/technology/volatile_variable_and_thread_safety/"},{"categories":null,"content":" 1 一个线程不安全的现象一个数组实现的环形缓冲区，变量 readPos 和 writePos 分别记录下一个读取的索引和下一个写入的索引。当缓冲区为空时，消费者会在数据存入缓冲区前等待。当缓冲区满时，生产者会等待将数据存入缓冲区。 Java public class RingBuffer\u003cItem\u003e { private final Item[] buffer; private int readPos; private int writePos; RingBuffer(int capacity) { this.buffer = (Item[]) new Object[capacity]; this.readPos = 0; this.writePos = 0; } public void write(Item item) { while (isFull()) ; buffer[writePos] = item; writePos = (writePos + 1) % buffer.length; } public Item read() { while (isEmpty()) ; Item item = buffer[readPos]; readPos = (readPos + 1) % buffer.length; return item; } private boolean isEmpty() { return readPos == writePos; } private boolean isFull() { return ((writePos + 1) % buffer.length) == readPos; } public static void main(String[] args) { RingBuffer\u003cInteger\u003e ringBuffer = new RingBuffer\u003c\u003e(10); Thread writer1 = new Thread(() -\u003e { for (int item = 0; item \u003c Integer.MAX_VALUE; item++) { ringBuffer.write(item); } }); writer1.start(); while (true) { StdOut.println(ringBuffer.read()); } } } 在运行此测试用例时发现两个线程都容易进入死循环。写入线程一直认为缓冲区是满的，消费线程一直认为缓冲区是空的。经过排查，此现象是 readPos 和 writePos 变量不一致导致的。 在写入线程中，writePos 变量只会被写入线程修改，因此该变量对于写入线程来说始终是最新值。而写入线程调用 isFull 方法的 readPos 变量会被读取线程修改，导致写入线程中 readPos 变量是旧数据。 在读取线程中，readPos 变量只会被读取线程修改，因此该变量对于读取线程来说始终是最新值。而读取线程调用 isEmpty 方法的 writePos 变量会被写入线程修改，导致读取线程中 writePos 变量是旧数据。 ","date":"2023-03-11","objectID":"/posts/others/technology/volatile_variable_and_thread_safety/:1:0","series":null,"tags":null,"title":"volatile 变量与线程安全","uri":"/posts/others/technology/volatile_variable_and_thread_safety/#一个线程不安全的现象"},{"categories":null,"content":" 2 解决方案将 readPos 和 writePos 改为 volatile 变量，在这个场景中能够保证这两个变量的线程安全。 那么 volatile 变量在此场景中是如何保证线程安全的呢？ ","date":"2023-03-11","objectID":"/posts/others/technology/volatile_variable_and_thread_safety/:2:0","series":null,"tags":null,"title":"volatile 变量与线程安全","uri":"/posts/others/technology/volatile_variable_and_thread_safety/#解决方案"},{"categories":null,"content":" 3 volatile 变量机制","date":"2023-03-11","objectID":"/posts/others/technology/volatile_variable_and_thread_safety/:3:0","series":null,"tags":null,"title":"volatile 变量与线程安全","uri":"/posts/others/technology/volatile_variable_and_thread_safety/#volatile-变量机制"},{"categories":null,"content":" 3.1 可见行保证对于非 volatile 变量，JVM 不会保证线程修改变量会被立即从 CPU 缓存中回写到主内存中。使得另一个线程可能会从主内存读取到该变量的旧值。 对于 volatile 变量，JVM 会保证线程每次都会从主内存中读取该变量。并且对该变量的修改会被立即回写到主内存。此时其余所有线程都会看到该变量的最新值。 ","date":"2023-03-11","objectID":"/posts/others/technology/volatile_variable_and_thread_safety/:3:1","series":null,"tags":null,"title":"volatile 变量与线程安全","uri":"/posts/others/technology/volatile_variable_and_thread_safety/#可见行保证"},{"categories":null,"content":" 3.2 happens-before 保证happens-before 保证会对指令重排序进行限制。 对 volatile 变量进行写入操作之前的所有指令不会因指令重排序导致这些指令在写入操作的后面； 对 volatile 变量进行读取操作之后的所有指令不会因指令重排序导致这些指令在写入操作的之前。 即本应在 volatile 变量读取与写入操作之间的指令，不会因为指令重排序导致这些指令在变量读取与写入操作之外。 ","date":"2023-03-11","objectID":"/posts/others/technology/volatile_variable_and_thread_safety/:3:2","series":null,"tags":null,"title":"volatile 变量与线程安全","uri":"/posts/others/technology/volatile_variable_and_thread_safety/#happens-before-保证"},{"categories":null,"content":" 4 volatile 变量何时是线程安全的？在以下两个场景，volatile 变量是线程安全的： 当只有一个线程向 volatile 变量写入，其余多个线程仅读取该变量时，总会读取最新的数据，此时是线程安全的； 当多个线程向 volatile 变量写入并且对变量的操作是原子操作（被写入的新值不依赖旧值），此时是线程安全的。 ","date":"2023-03-11","objectID":"/posts/others/technology/volatile_variable_and_thread_safety/:4:0","series":null,"tags":null,"title":"volatile 变量与线程安全","uri":"/posts/others/technology/volatile_variable_and_thread_safety/#volatile-变量何时是线程安全的"},{"categories":null,"content":" 5 一个 volitile 变量例子 C# public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } ","date":"2023-03-11","objectID":"/posts/others/technology/volatile_variable_and_thread_safety/:5:0","series":null,"tags":null,"title":"volatile 变量与线程安全","uri":"/posts/others/technology/volatile_variable_and_thread_safety/#一个-volitile-变量例子"},{"categories":null,"content":" 6 参考资料Concurrency in Java: “synchronized” and “volatile” keywords Volatile Variables and Thread Safety ","date":"2023-03-11","objectID":"/posts/others/technology/volatile_variable_and_thread_safety/:6:0","series":null,"tags":null,"title":"volatile 变量与线程安全","uri":"/posts/others/technology/volatile_variable_and_thread_safety/#参考资料"},{"categories":["中间件技术"],"content":"通过分析 Redis 异步删除源码，判断异步删除能否解决大 Key 过期阻塞主线程的问题。","date":"2023-03-04","objectID":"/posts/redis_upgrade/redis_upgrade_01/","series":["Redis升级"],"tags":["Redis"],"title":"Redis 异步删除解决大 Key 过期阻塞问题可行性分析","uri":"/posts/redis_upgrade/redis_upgrade_01/"},{"categories":["中间件技术"],"content":"自 Redis 4 版本引入了异步删除方法 unlink，官方对该接口的解释： “This command is very similar to DEL: it removes the specified keys. Just like DEL a key is ignored if it does not exist. However the command performs the actual memory reclaiming in a different thread, so it is not blocking, while DEL is. This is where the command name comes from: the command just unlinks the keys from the keyspace. The actual removal will happen later asynchronously.” 可知 unlink 与 del 用法相同，只不过内存回收在另一个不同线程中，内存回收操作在 unlink 方法调用结束之后，因此是非阻塞方法。 ","date":"2023-03-04","objectID":"/posts/redis_upgrade/redis_upgrade_01/:0:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 异步删除解决大 Key 过期阻塞问题可行性分析","uri":"/posts/redis_upgrade/redis_upgrade_01/#"},{"categories":["中间件技术"],"content":" 1 源码分析","date":"2023-03-04","objectID":"/posts/redis_upgrade/redis_upgrade_01/:1:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 异步删除解决大 Key 过期阻塞问题可行性分析","uri":"/posts/redis_upgrade/redis_upgrade_01/#源码分析"},{"categories":["中间件技术"],"content":" 1.1 异步删除流程同步删除与异步删除的方法入口分别为 delCommand 方法与 unlinkCommand 方法。 C void delCommand(client *c) { delGenericCommand(c,server.lazyfree_lazy_user_del); } void unlinkCommand(client *c) { delGenericCommand(c,1); } 这两个方法都调用 delGenericCommand 方法，server.lazyfree_lazy_user_del 可通过配置文件配置，配置后可以使 del 命令与 unlink 命令完全相同。 C /* This command implements DEL and LAZYDEL. */ void delGenericCommand(client *c, int lazy) { int numdel = 0, j; for (j = 1; j \u003c c-\u003eargc; j++) { expireIfNeeded(c-\u003edb,c-\u003eargv[j],0); // 判断传入的 lazy 值选择异步删除或同步删除 int deleted = lazy ? dbAsyncDelete(c-\u003edb,c-\u003eargv[j]) : dbSyncDelete(c-\u003edb,c-\u003eargv[j]); if (deleted) { signalModifiedKey(c,c-\u003edb,c-\u003eargv[j]); notifyKeyspaceEvent(NOTIFY_GENERIC, \"del\",c-\u003eargv[j],c-\u003edb-\u003eid); server.dirty++; numdel++; } } addReplyLongLong(c,numdel); } delGenericCommand 方法判断传入的 lazy 参数值决定异步删除或者同步删除。 C /* Delete a key, value, and associated expiration entry if any, from the DB */ int dbSyncDelete(redisDb *db, robj *key) { return dbGenericDelete(db, key, 0); } /* Delete a key, value, and associated expiration entry if any, from the DB. If * the value consists of many allocations, it may be freed asynchronously. */ int dbAsyncDelete(redisDb *db, robj *key) { return dbGenericDelete(db, key, 1); } 同步删除和异步删除都是调用 dbGenericDelete 方法，仅传入的 async 参数不同。 C /* Helper for sync and async delete. */ static int dbGenericDelete(redisDb *db, robj *key, int async) { /* Deleting an entry from the expires dict will not free the sds of * the key, because it is shared with the main dictionary. */ // 删除 expires 字典中该 key，但不会删除 SDS 结构，因为该 SDS 在 dict 字典中被共享。 if (dictSize(db-\u003eexpires) \u003e 0) dictDelete(db-\u003eexpires,key-\u003eptr); // 数据库字典中移除 key，不释放内存。 dictEntry *de = dictUnlink(db-\u003edict,key-\u003eptr); if (de) { robj *val = dictGetVal(de); /* Tells the module that the key has been unlinked from the database. */ moduleNotifyKeyUnlink(key,val,db-\u003eid); /* We want to try to unblock any client using a blocking XREADGROUP */ if (val-\u003etype == OBJ_STREAM) signalKeyAsReady(db,key,val-\u003etype); if (async) { // 异步释放内存 freeObjAsync(key, val, db-\u003eid); dictSetVal(db-\u003edict, de, NULL); } if (server.cluster_enabled) slotToKeyDelEntry(de, db); // 释放内存 dictFreeUnlinkedEntry(db-\u003edict,de); return 1; } else { return 0; } } /* You need to call this function to really free the entry after a call * to dictUnlink(). It's safe to call this function with 'he' = NULL. */ void dictFreeUnlinkedEntry(dict *d, dictEntry *he) { if (he == NULL) return; dictFreeKey(d, he); dictFreeVal(d, he); zfree(he); } dbGenericDelete 方法首先将 key 在 expires 字典中删除并释放内存，再在 dict 字典中移除该 key，但此时不释放内存。 通过 async 参数判断是否需要异步释放内存，若需要则会调用 freeObjAsync 方法进行异步释放内存，若不需要异步释放内存，则在 dictFreeUnlinkedEntry 方法中直接释放。 若进入 freeObjAsync 方法但不满足异步释放条件（在 freeObjAsync 方法中），也会在 dictFreeUnlinkedEntry 方法中直接释放。 C /* If there are enough allocations to free the value object asynchronously, it * may be put into a lazy free list instead of being freed synchronously. The * lazy free list will be reclaimed in a different bio.c thread. If the value is * composed of a few allocations, to free in a lazy way is actually just * slower... So under a certain limit we just free the object synchronously. */ #define LAZYFREE_THRESHOLD 64 /* Free an object, if the object is huge enough, free it in async way. */ void freeObjAsync(robj *key, robj *obj, int dbid) { // 计算异步删除阈值 size_t free_effort = lazyfreeGetFreeEffort(key,obj,dbid); /* Note that if the object is shared, to reclaim it now it is not * possible. This rarely happens, however sometimes the implementation * of parts of the Redis core may call incrRefCount() to protect * objects, and then call dbDelete(). */ if (free_effort \u003e LAZYFREE_THRESHOLD \u0026\u0026 obj-\u003erefcount == 1) { atomicIncr(lazyfree_objects,1); // 任务超过异步删除阈值，创建异步删除任务 bioCreateLazyFreeJob(lazyfreeFreeObject,1,obj); } else { decrRefCount(obj); } } 重点看 freeObjAsync 方法，先计算该 key 的异步删除阈值，若大于阈值 64，则为该 key 创建异步删除任务。 C void bioCreateLazyFreeJob(lazy_free_fn free_fn, int arg_count, ...) { va_list valist; /* Allocate memory for the job structure and ","date":"2023-03-04","objectID":"/posts/redis_upgrade/redis_upgrade_01/:1:1","series":["Redis升级"],"tags":["Redis"],"title":"Redis 异步删除解决大 Key 过期阻塞问题可行性分析","uri":"/posts/redis_upgrade/redis_upgrade_01/#异步删除流程"},{"categories":["中间件技术"],"content":" 1.2 惰性删除与异步删除Redis 惰性删除策略是否采用异步删除策略？ 在惰性删除中，Redis 在操作 Key 时会先判断该 Key 是否过期，若过期则会删除该 Key。 C /* This function is called when we are going to perform some operation * in a given key, but such key may be already logically expired even if * it still exists in the database. The main way this function is called * is via lookupKey*() family of functions. * * The behavior of the function depends on the replication role of the * instance, because by default replicas do not delete expired keys. They * wait for DELs from the master for consistency matters. However even * replicas will try to have a coherent return value for the function, * so that read commands executed in the replica side will be able to * behave like if the key is expired even if still present (because the * master has yet to propagate the DEL). * * In masters as a side effect of finding a key which is expired, such * key will be evicted from the database. Also this may trigger the * propagation of a DEL/UNLINK command in AOF / replication stream. * * On replicas, this function does not delete expired keys by default, but * it still returns 1 if the key is logically expired. To force deletion * of logically expired keys even on replicas, use the EXPIRE_FORCE_DELETE_EXPIRED * flag. Note though that if the current client is executing * replicated commands from the master, keys are never considered expired. * * On the other hand, if you just want expiration check, but need to avoid * the actual key deletion and propagation of the deletion, use the * EXPIRE_AVOID_DELETE_EXPIRED flag. * * The return value of the function is 0 if the key is still valid, * otherwise the function returns 1 if the key is expired. */ int expireIfNeeded(redisDb *db, robj *key, int flags) { if (!keyIsExpired(db,key)) return 0; /* If we are running in the context of a replica, instead of * evicting the expired key from the database, we return ASAP: * the replica key expiration is controlled by the master that will * send us synthesized DEL operations for expired keys. The * exception is when write operations are performed on writable * replicas. * * Still we try to return the right information to the caller, * that is, 0 if we think the key should be still valid, 1 if * we think the key is expired at this time. * * When replicating commands from the master, keys are never considered * expired. */ if (server.masterhost != NULL) { if (server.current_client == server.master) return 0; if (!(flags \u0026 EXPIRE_FORCE_DELETE_EXPIRED)) return 1; } /* In some cases we're explicitly instructed to return an indication of a * missing key without actually deleting it, even on masters. */ if (flags \u0026 EXPIRE_AVOID_DELETE_EXPIRED) return 1; /* If clients are paused, we keep the current dataset constant, * but return to the client what we believe is the right state. Typically, * at the end of the pause we will properly expire the key OR we will * have failed over and the new primary will send us the expire. */ if (checkClientPauseTimeoutAndReturnIfPaused()) return 1; /* Delete the key */ // 删除 key deleteExpiredKeyAndPropagate(db,key); return 1; } expireIfNeeded 方法会调用 deleteExpiredKeyAndPropagate 方法删除 key。 删除 key 时会读取 server.lazyfree_lazy_expire 配置决定删除策略。server.lazyfree_lazy_expire 可在配置文件中配置，配置后惰性删除将采用异步删除策略。 C /* Delete the specified expired key and propagate expire. */ void deleteExpiredKeyAndPropagate(redisDb *db, robj *keyobj) { mstime_t expire_latency; latencyStartMonitor(expire_latency); if (server.lazyfree_lazy_expire) // 采用异步删除策略 dbAsyncDelete(db,keyobj); else dbSyncDelete(db,keyobj); latencyEndMonitor(expire_latency); latencyAddSampleIfNeeded(\"expire-del\",expire_latency); notifyKeyspaceEvent(NOTIFY_EXPIRED,\"expired\",keyobj,db-\u003eid); signalModifiedKey(NULL, db, keyobj); propagateDeletion(db,keyobj,server.lazyfree_lazy_expire); server.stat_expiredkeys++; } 结论：Redis 惰性删除在配置后可采用异步删除策略。 ","date":"2023-03-04","objectID":"/posts/redis_upgrade/redis_upgrade_01/:1:2","series":["Redis升级"],"tags":["Redis"],"title":"Redis 异步删除解决大 Key 过期阻塞问题可行性分析","uri":"/posts/redis_upgrade/redis_upgrade_01/#惰性删除与异步删除"},{"categories":["中间件技术"],"content":" 1.3 定时删除与异步删除定时任务 serverCron 方法最终会调用 activeExpireCycleTryExpire 方法，该方法仍会调用 deleteExpiredKeyAndPropagate 方法。 C /* Helper function for the activeExpireCycle() function. * This function will try to expire the key that is stored in the hash table * entry 'de' of the 'expires' hash table of a Redis database. * * If the key is found to be expired, it is removed from the database and * 1 is returned. Otherwise no operation is performed and 0 is returned. * * When a key is expired, server.stat_expiredkeys is incremented. * * The parameter 'now' is the current time in milliseconds as is passed * to the function to avoid too many gettimeofday() syscalls. */ int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) { long long t = dictGetSignedIntegerVal(de); if (now \u003e t) { sds key = dictGetKey(de); robj *keyobj = createStringObject(key,sdslen(key)); // 删除 key deleteExpiredKeyAndPropagate(db,keyobj); decrRefCount(keyobj); return 1; } else { return 0; } } 结论：Redis 定时删除在配置后可采用异步删除策略。 ","date":"2023-03-04","objectID":"/posts/redis_upgrade/redis_upgrade_01/:1:3","series":["Redis升级"],"tags":["Redis"],"title":"Redis 异步删除解决大 Key 过期阻塞问题可行性分析","uri":"/posts/redis_upgrade/redis_upgrade_01/#定时删除与异步删除"},{"categories":["中间件技术"],"content":" 2 结论异步删除策略能够在删除大 Key 时避免主线程阻塞，惰性删除与定时删除在配置后均可采用异步删除策略，因此异步删除能够解决大 Key 过期引起的主线程阻塞问题。 ","date":"2023-03-04","objectID":"/posts/redis_upgrade/redis_upgrade_01/:2:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 异步删除解决大 Key 过期阻塞问题可行性分析","uri":"/posts/redis_upgrade/redis_upgrade_01/#结论"},{"categories":["中间件技术"],"content":"记录Redis升级流程。","date":"2023-03-03","objectID":"/posts/redis_upgrade/redis_upgrade_00/","series":["Redis升级"],"tags":["Redis"],"title":"Redis 升级 —— 前言","uri":"/posts/redis_upgrade/redis_upgrade_00/"},{"categories":["中间件技术"],"content":" 1 现版本存在的问题目前在生产环境中部署的旧版本Redis存在的问题： 大 key 过期删除引发集群节点阻塞失去响应不可用； 内存碎片高，内存使用率低； 运维时，手动主从切换总会产生复制风暴问题，主从无法同步； bgsave 内存消耗较高，有 OOM 风险。 ","date":"2023-03-03","objectID":"/posts/redis_upgrade/redis_upgrade_00/:1:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 升级 —— 前言","uri":"/posts/redis_upgrade/redis_upgrade_00/#现版本存在的问题"},{"categories":["中间件技术"],"content":" 2 推进版本升级由于以上原因，开始推进 Redis 版本升级。 版本升级工作流程： 通过文档与源码，调研 Redis 新特性； 客户端兼容性改造； 功能测试、性能测试和稳定性测试； 开发配套监控和运维工具； 推进上线。 ","date":"2023-03-03","objectID":"/posts/redis_upgrade/redis_upgrade_00/:2:0","series":["Redis升级"],"tags":["Redis"],"title":"Redis 升级 —— 前言","uri":"/posts/redis_upgrade/redis_upgrade_00/#推进版本升级"},{"categories":["数据结构与算法"],"content":"算法第四版 —— 欧几里得算法求最大公因数","date":"2023-02-27","objectID":"/posts/algs4/algs4_02/","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 欧几里得算法求最大公因数","uri":"/posts/algs4/algs4_02/"},{"categories":["数据结构与算法"],"content":" 1 自然语言描述计算两个非负整数 p 和 q 的最大公约数：若 q 是 0，则最大公约数为 p。否则，将 p 除以 q 得到余数 r，p 和 q 的最大公约数即为 q 和 r 的最大公约数。 ","date":"2023-02-27","objectID":"/posts/algs4/algs4_02/:1:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 欧几里得算法求最大公因数","uri":"/posts/algs4/algs4_02/#自然语言描述"},{"categories":["数据结构与算法"],"content":" 2 递归写法 Java public class Euclid { public static int gcd(int p, int q) { if (q == 0) return p; int r = p % q; return gcd(q, r); } } ","date":"2023-02-27","objectID":"/posts/algs4/algs4_02/:2:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 欧几里得算法求最大公因数","uri":"/posts/algs4/algs4_02/#递归写法"},{"categories":["数据结构与算法"],"content":" 3 循环写法 Java public class Euclid { public static int gcd(int p, int q) { if (q == 0) return p; while (q != 0) { int r = p % q; p = q; q = r; } return p; } } ","date":"2023-02-27","objectID":"/posts/algs4/algs4_02/:3:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 欧几里得算法求最大公因数","uri":"/posts/algs4/algs4_02/#循环写法"},{"categories":["数据结构与算法"],"content":"算法第四版 —— 二分查找","date":"2023-02-26","objectID":"/posts/algs4/algs4_01/","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 二分查找","uri":"/posts/algs4/algs4_01/"},{"categories":["数据结构与算法"],"content":" 1 前提条件查找的数组是有序的。 ","date":"2023-02-26","objectID":"/posts/algs4/algs4_01/:1:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 二分查找","uri":"/posts/algs4/algs4_01/#前提条件"},{"categories":["数据结构与算法"],"content":" 2 递归写法 Java public class BinarySearch { public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1); } public static int rank(int key, int[] a, int lo, int hi) { if (lo \u003e hi) return -1; int mid = lo + (hi - lo) / 2; if (key \u003c a[mid]) return rank(key, a, lo, hi - 1); else if (key \u003e a[mid]) return rank(key, a, lo + 1, hi); else return mid; } } ","date":"2023-02-26","objectID":"/posts/algs4/algs4_01/:2:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 二分查找","uri":"/posts/algs4/algs4_01/#递归写法"},{"categories":["数据结构与算法"],"content":" 3 循环写法 Java public class BinarySearch { public static int rank(int key, int[] a) { int lo = 0; int hi = a.length - 1; while (lo \u003c hi) { int mid = lo + (hi - lo) / 2; if (key \u003c a[mid]) hi = lo - 1; else if (key \u003e a[mid]) lo = hi + 1; else return mid; } return -1; } } ","date":"2023-02-26","objectID":"/posts/algs4/algs4_01/:3:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 二分查找","uri":"/posts/algs4/algs4_01/#循环写法"},{"categories":["数据结构与算法"],"content":" 4 二分查找 key 的最小索引 Java public class BinarySearch { public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1); } public static int rank(int[] array, int key, int lo, int hi) { while (lo \u003c= hi) { int mid = lo + ((hi - lo) \u003e\u003e 1); if (key \u003c= array[mid]) { hi = mid - 1; } else { lo = mid + 1; } } if (lo == array.length) return -1; return array[lo] == key ? lo : -1; } } ","date":"2023-02-26","objectID":"/posts/algs4/algs4_01/:4:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 二分查找","uri":"/posts/algs4/algs4_01/#二分查找-key-的最小索引"},{"categories":["数据结构与算法"],"content":" 5 二分查找极小(大)值 Java public class BinarySearch { public static int partialMin(int[] array) { assert array != null \u0026\u0026 array.length \u003e 0; int lo = 0; int hi = array.length - 1; while (lo \u003c= hi) { int mid = lo + ((hi - lo) \u003e\u003e 1); if (mid == 0 || mid == array.length - 1) break; if (array[mid] \u003c array[mid - 1] \u0026\u0026 array[mid] \u003c array[mid + 1]) { return mid; } else if (array[mid - 1] \u003c= array[mid + 1]) { hi = mid - 1; } else { lo = mid + 1; } } return -1; } } ","date":"2023-02-26","objectID":"/posts/algs4/algs4_01/:5:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 二分查找","uri":"/posts/algs4/algs4_01/#二分查找极小大值"},{"categories":["数据结构与算法"],"content":"算法第四版 —— 前言","date":"2023-02-25","objectID":"/posts/algs4/algs4_00/","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 前言","uri":"/posts/algs4/algs4_00/"},{"categories":["数据结构与算法"],"content":" 1 本系列文章作用2023 年计划将「算法第四版」认真阅读一遍，在博客中整理常用的算法，把书读薄，时常复习，提高编码水平。 习题仓库：https://github.com/Nanciico/algs4 加油！ ","date":"2023-02-25","objectID":"/posts/algs4/algs4_00/:1:0","series":["算法第四版 阅读笔记"],"tags":["算法第四版"],"title":"算法第四版 —— 前言","uri":"/posts/algs4/algs4_00/#本系列文章作用"},{"categories":null,"content":" 1 为何要写技术博客？一开始写技术博客，没错，是技术博客。仅仅是为了记录工作中遇到的技术问题并整理学习中的知识点，时常翻阅，慢慢内化为自己的知识。 在工作中，我经常遇到一些零零散散的知识点，不成体系。遇到问题一次，去查阅资料然后解决问题，这样这个问题便解决了。但第二次、第三次遇到，我仍然需要去翻阅资料，需要去重新解决。这表示我虽然解决了这个问题，但在解决问题的过程中个人并没有成长。写技术博客，就是将这些常见、零散的知识点汇总为一个知识网络的过程。 学习阅读技术书籍时，经常性的读到后面的章节，前面章节忘完了。这时，通过博客简短记录上一章节内容，能够将书读薄，快速拾起遗忘章节，辅助我们阅读书籍。 但在坚持写博客一年时间后，我渐渐感受到了写博客更加重要的意义。 ","date":"0001-01-01","objectID":"/about/:1:0","series":null,"tags":null,"title":"关于","uri":"/about/#为何要写技术博客"},{"categories":null,"content":" 2 不仅仅是技术博客人如果仅仅向一个方向深挖、深钻，虽然他会在这个方向上有所成就，但他的视野会慢慢变得狭隘。 因此我也会通过写博客，整理平时阅读的书籍的思路，或者是记录人生感悟，不再局限于技术与工作。 ","date":"0001-01-01","objectID":"/about/:2:0","series":null,"tags":null,"title":"关于","uri":"/about/#不仅仅是技术博客"}]