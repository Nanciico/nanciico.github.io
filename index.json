[{"content":"Shell å‚æ•°å¤„ç†ç‰¹æ®Šå­—ç¬¦ #!/bin/bash echo \u0026#34;Starting program at $(date)\u0026#34; # 1. $( CMD ) è¿è¡Œ CMD å‘½ä»¤ echo \u0026#34;Running program $0 with $# arguments with pid $$\u0026#34; # 2. è§ç‰¹æ®Šå­—ç¬¦è¡¨ for file in \u0026#34;$@\u0026#34;; do # 3. è§ç‰¹æ®Šå­—ç¬¦è¡¨ grep foobar \u0026#34;$file\u0026#34; \u0026gt; /dev/null 2\u0026gt; /dev/null # 4. \u0026#34;2\u0026gt; /dev/null\u0026#34; æŠŠæ ‡å‡†é”™è¯¯é‡å®šå‘åˆ°/dev/null if [[ $? -ne 0 ]]; then # 5. è§ç‰¹æ®Šå­—ç¬¦è¡¨ï¼›åœ¨æ¯”è¾ƒæ“ä½œä¸­ä½¿ç”¨åŒä¸­æ‹¬å· echo \u0026#34;File $file does not have any foobar, adding one\u0026#34; echo \u0026#34;# foobar\u0026#34; \u0026gt;\u0026gt; \u0026#34;$file\u0026#34; fi done ç‰¹æ®Šå­—ç¬¦è¡¨ å‚æ•°å¤„ç† è¯´æ˜ $0 Shell Script åå­— $# å‚æ•°ä¸ªæ•° $$ è¿›ç¨‹ PID $@ æ‰€æœ‰å‚æ•° $? ä¸Šä¸€æ¡å‘½ä»¤çš„è¿”å›ç  test å‘½ä»¤çš„åŒä¸­æ‹¬å· Differences Between Single and Double Brackets in Bash.Differences Between Single and Double Brackets in Bash.\nsave-bgsave è„šæœ¬æ•´ç† #!/bin/bash function help() # 1. å‡½æ•°å£°æ˜ { echo \u0026#34;usage: safe-bgsave -t THRESHOLD -i INTERVAL -p PORT.\u0026#34; echo \u0026#34; safe-bgsave -t 20 -i 1 -p 7002\u0026#34; exit } # success return 0; fail return 1. function safe_bgsave() { # check security local available=`free -g | grep Mem | awk \u0026#39;{print $7}\u0026#39;` # 2. awk é€‰å–ç¬¬ 7 åˆ— if [ ${available} -le ${THRESHOLD} ] then echo `date` \u0026#34; Available memory: ${available} \u0026lt;= threshold: ${THRESHOLD}. Do not process bgsave.\u0026#34; \u0026gt;\u0026gt; ${LOG_PATH} 2\u0026gt;\u0026amp;1 return 1 fi # bgsave local bgsave=`${REDIS_CLI} -p ${PORT} bgsave` echo `date` \u0026#34; ${bgsave}.\u0026#34; \u0026gt;\u0026gt; ${LOG_PATH} 2\u0026gt;\u0026amp;1 # 3. å­—ç¬¦ä¸²æ‹¼æ¥ï¼›\u0026#34;2\u0026gt;\u0026amp;1\u0026#34; å°†æ ‡å‡†é”™è¯¯é‡å®šå‘åˆ°æ ‡å‡†è¾“å‡º sleep ${INTERVAL} local pid=`ps -ef | grep \u0026#34;${PROCESS_NAME}\u0026#34; | grep -v grep | awk \u0026#39;{print $2}\u0026#39;` while [ -n \u0026#34;${pid}\u0026#34; ] do available=`free -g | grep Mem | awk \u0026#39;{print $7}\u0026#39;` if [ ${available} -le ${THRESHOLD} ] then echo `date` \u0026#34; bgsave failed. Available memory: ${available} \u0026lt;= threshold: ${THRESHOLD}. Trying to kill process.\u0026#34; \u0026gt;\u0026gt; ${LOG_PATH} 2\u0026gt;\u0026amp;1 kill \u0026#34;${pid}\u0026#34; return 1 fi sleep ${INTERVAL} pid=`ps -ef | grep \u0026#34;${PROCESS_NAME}\u0026#34; | grep -v grep | awk \u0026#39;{print $2}\u0026#39;` done echo `date` \u0026#34; bgsave success.\u0026#34; \u0026gt;\u0026gt; ${LOG_PATH} 2\u0026gt;\u0026amp;1 return 0 } # Begin [ $# -ne 6 ] \u0026amp;\u0026amp; help # 4. æ£€æŸ¥å‚æ•°ä¸ªæ•°ï¼›è°ƒç”¨ help å‡½æ•° while [ -n \u0026#34;$1\u0026#34; ] # 5. å‚æ•°èµ‹å€¼çš„å†™æ³• do case \u0026#34;$1\u0026#34; in -t) THRESHOLD=$2 shift 2 # 6. å°†å‚æ•°æ•°ç»„å‘å·¦ç§»åŠ¨ä¸¤ä½ ;; -i) INTERVAL=$2 shift 2 ;; -p) PORT=$2 shift 2 ;; *) help ;; esac done REDIS_CLI=\u0026#34;redis-cli\u0026#34; PROCESS_NAME=\u0026#34;redis-rdb-bgsave\u0026#34; LOG_PATH=\u0026#34;/opt/data/redis/safe_bgsave.${PORT}.log\u0026#34; safe_bgsave if [ $? -eq 1 ] then exit 1 fi exit 0 ","permalink":"https://fullzsy.github.io/posts/tech/shell-script-%E6%95%B4%E7%90%86/","summary":"æ•´ç† Shell Script è¯­æ³•","title":"Shell Script æ•´ç†"},{"content":"ç®—æ³•åˆ†æçš„æ–¹æ³• Observe some feature of the natural world, generally with precise measurements. Hypothesize a model that is consistent with the observations. Predict events using the hypothesis. Verify the predictions by making further observations. Validate by repeating until the hypothesis and observations agree. ç®—æ³•è¿è¡Œæ—¶é—´å®éªŒ ç¨‹åºæ‰§è¡Œé€Ÿåº¦çš„å¿«æ…¢é€šå¸¸å–å†³äºé—®é¢˜çš„è§„æ¨¡ã€‚\né€šè¿‡è§‚å¯Ÿä»£ç åˆæ­¥é¢„æµ‹ç¨‹åºçš„æ‰§è¡Œæ—¶é—´ã€‚\nä½¿ç”¨ç±»ä¼¼ DoublingTest æ–¹æ³•ä¸æ–­å¢åŠ é—®é¢˜è§„æ¨¡å¹¶è®¡æ—¶ï¼Œè¿›å…¥â€œé¢„æµ‹â€”â€”éªŒè¯â€å¾ªç¯ã€‚\npublic class DoublingTest { public static double timeTrial(int N) { // Time ThreeSum.count() for N random 6-digit ints. int MAX = 1000000; int[] a = new int[N]; for (int i = 0; i \u0026lt; N; i++) a[i] = StdRandom.uniformInt(-MAX, MAX); Stopwatch timer = new Stopwatch(); int cnt = ThreeSum.count(a); return timer.elapsedTime(); } public static void main(String[] args) { // Print table of running times. for (int N = 250; true; N += N) { // Print time for problem size N. double time = timeTrial(N); StdOut.printf(\u0026#34;%7d %5.1f\\n\u0026#34;, N, time); } } } åˆ†æå®éªŒæ•°æ®ï¼Œå¾—åˆ°å…¶è¿è¡Œæ—¶é—´çš„æ•°å­¦æ¨¡å‹ã€‚\nè¿è¡Œæ—¶é—´çš„æ•°å­¦æ¨¡å‹ å¾—åˆ°è¿è¡Œæ—¶é—´çš„æ•°å­¦æ¨¡å‹æ­¥éª¤ï¼šï¼ˆä¹¦ï¼šP114ï¼‰\nç¡®å®šè¾“å…¥æ¨¡å‹ï¼Œå®šä¹‰é—®é¢˜è§„æ¨¡ è¯†åˆ«å†…å¾ªç¯ æ ¹æ®å†…å¾ªç¯ä¸­çš„æ“ä½œç¡®å®šæˆæœ¬æ¨¡å‹ å¯¹äºç»™å®šçš„è¾“å…¥ï¼Œåˆ¤æ–­è¿™äº›æ“ä½œçš„æ‰§è¡Œé¢‘ç‡ å¢é•¿æ•°é‡çº§ æè¿° å¢é•¿çš„æ•°é‡çº§ å…¸å‹ä»£ç  è¯´æ˜ ä¸¾ä¾‹ å¸¸æ•°çº§åˆ« 1 a = b + c æ™®é€šè¯­å¥ ä¸¤ä¸ªæ•°ç›¸åŠ  å¯¹æ•°çº§åˆ« logN äºŒåˆ†æŸ¥æ‰¾ äºŒåˆ†ç­–ç•¥ äºŒåˆ†æŸ¥æ‰¾ çº¿æ€§çº§åˆ« N å¾ªç¯ å¾ªç¯ å¾ªç¯æŸ¥æ‰¾æœ€å¤§å…ƒç´  çº¿æ€§å¯¹æ•°çº§åˆ« NlogN å½’å¹¶æ’åº Merge.sort å’Œ å¿«é€Ÿæ’åº Quick.sort å½’å¹¶æ’åºï¼Œå¿«é€Ÿæ’åº å½’å¹¶æ’åºï¼Œå¿«é€Ÿæ’åº å¹³æ–¹çº§åˆ« N^2 é€‰æ‹©æ’åº Selection.sort å’Œ æ’å…¥æ’åº Insertion.sort åŒå±‚å¾ªç¯ é€‰æ‹©æ’åºï¼Œæ’å…¥æ’åº ç«‹æ–¹çº§åˆ« N^3 ThreeSum ä¸‰å±‚å¾ªç¯ ä¸‰å±‚å¾ªç¯ ä¸‰å±‚å¾ªç¯ æŒ‡æ•°çº§åˆ« 2^N ç¬¬å…­ç«  ç©·ä¸¾æŸ¥æ‰¾ æ£€æŸ¥æ‰€æœ‰å­é›† å€ç‡å®éªŒ é€šè¿‡å€ç‡å®éªŒèƒ½å¤Ÿç®€å•æœ‰æ•ˆåœ°é¢„æµ‹ä»»æ„ç¨‹åºçš„æ€§èƒ½å¹¶åˆ¤æ–­å®ƒä»¬è¿è¡Œæ—¶é—´å¤§è‡´çš„å¢é•¿æ•°é‡çº§ï¼Œä½†å¯¹æ¯”å€¼æ²¡æœ‰æé™çš„ç®—æ³•æ— æ•ˆã€‚\npublic class DoublingRatio { public static double timeTrial(int N) { // Time ThreeSum.count() for N random 6-digit ints. int MAX = 1000000; int[] a = new int[N]; for (int i = 0; i \u0026lt; N; i++) a[i] = StdRandom.uniformInt(-MAX, MAX); Stopwatch timer = new Stopwatch(); int cnt = ThreeSum.count(a); return timer.elapsedTime(); } public static void main(String[] args) { double prev = timeTrial(125); for (int N = 250; true; N += N) { double time = timeTrial(N); StdOut.printf(\u0026#34;%6d %7.1f \u0026#34;, N, time); StdOut.printf(\u0026#34;%5.1f\\n\u0026#34;, time / prev); prev = time; } } } åœ¨æœ‰æ€§èƒ½é—®é¢˜çš„æƒ…å†µå®¶åº”è¯¥è€ƒè™‘å¯¹ç¼–å†™è¿‡çš„æ‰€æœ‰ç¨‹åºè¿›è¡Œå€ç‡å®éªŒï¼Œä»¥ä¾¿èƒ½æ‰¾åˆ°æ€§èƒ½é—®é¢˜ã€‚\n","permalink":"https://fullzsy.github.io/posts/read/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_04_%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/","summary":"ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹ç®—æ³•åˆ†æ","title":"ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹ç®—æ³•åˆ†æ"},{"content":"èƒŒåŒ… èƒŒåŒ… APIï¼š\nèƒŒåŒ… public class Bag\u0026lt;Item\u0026gt; implements Iterable\u0026lt;Item\u0026gt; Bag() åˆ›å»ºä¸€ä¸ªèƒŒåŒ… void add(Item item) æ·»åŠ ä¸€ä¸ªå…ƒç´  boolean isEmpty() èƒŒåŒ…æ˜¯å¦ä¸ºç©º int size() èƒŒåŒ…ä¸­å…ƒç´ æ•°é‡ èƒŒåŒ…æ˜¯ä¸€ç§ä¸æ”¯æŒä»ä¸­åˆ é™¤å…ƒç´ çš„é›†åˆæ•°æ®ç±»å‹â€”â€”ä»–çš„ç›®çš„æ˜¯å¸®åŠ©ç”¨ä¾‹æ”¶é›†å…ƒç´ å¹¶è¿­ä»£éå†æ‰€æœ‰æ”¶é›†åˆ°çš„å…ƒç´ ã€‚\nèƒŒåŒ…çš„é“¾è¡¨å®ç° import java.util.Iterator; public class Bag\u0026lt;Item\u0026gt; implements Iterable\u0026lt;Item\u0026gt; { private Node first; private class Node { Item item; Node next; } public void add(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; } @Override public Iterator\u0026lt;Item\u0026gt; iterator() { return new ListIterator(); } private class ListIterator implements Iterator\u0026lt;Item\u0026gt; { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰é˜Ÿåˆ— é˜Ÿåˆ— APIï¼š\nå…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰é˜Ÿåˆ— public class Queue\u0026lt;Item\u0026gt; implements Interable\u0026lt;Item\u0026gt; Queue() åˆ›å»ºç©ºé˜Ÿåˆ— void enqueue(Item item) æ·»åŠ ä¸€ä¸ªå…ƒç´  Item dequeue() åˆ é™¤æœ€æ—©æ·»åŠ çš„å…ƒç´  boolean isEmpty() é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º int size() é˜Ÿåˆ—ä¸­çš„å…ƒç´ æ•°é‡ å…ˆè¿›å…ˆå‡ºé˜Ÿåˆ—æ˜¯ä¸€ç§åŸºäºå…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰ç­–ç•¥çš„é›†åˆç±»å‹ã€‚\né˜Ÿåˆ—çš„å®ç° é˜Ÿåˆ—çš„é“¾è¡¨å®ç° import java.util.Iterator; public class Queue\u0026lt;Item\u0026gt; implements Iterable\u0026lt;Item\u0026gt; { private Node first; private Node last; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void enqueue(Item item) { Node oldLast = last; last = new Node(); last.item = item; last.next = null; if (isEmpty()) { first = last; } else { oldLast.next = last; } size++; } public Item dequeue() { Item item = first.item; first = first.next; if (isEmpty()) { last = null; } size--; return item; } @Override public Iterator\u0026lt;Item\u0026gt; iterator() { return new ListIterator(); } private class ListIterator implements Iterator\u0026lt;Item\u0026gt; { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } åè¿›å…ˆå‡ºï¼ˆLIFOï¼‰æ ˆ æ ˆ APIï¼š\npublic class Stack\u0026lt;Item\u0026gt; implements Iterable\u0026lt;Item\u0026gt; Stack() åˆ›å»ºä¸€ä¸ªç©ºæ ˆ void push() æ·»åŠ ä¸€ä¸ªå…ƒç´  Item pop() åˆ é™¤æœ€è¿‘æ·»åŠ çš„å…ƒç´  boolean isEmpty() æ ˆæ˜¯å¦ä¸ºç©º int size() æ ˆä¸­å…ƒç´ æ•°é‡ æ ˆçš„å®ç° æ ˆçš„æ•°ç»„å®ç° import java.util.Iterator; public class ResizingArrayStack\u0026lt;Item\u0026gt; implements Iterable\u0026lt;Item\u0026gt; { private Item[] array = (Item[]) new Object[1]; private int size = 0; public boolean isEmpty() { return size == 0; } public int size() { return size; } public void push(Item item) { if (size == array.length) { resize(2 * array.length); } array[size++] = item; } public Item pop() { Item item = array[--size]; array[size] = null; if (size \u0026gt; 0 \u0026amp;\u0026amp; size == array.length / 4) { resize(array.length / 2); } return item; } private void resize(int length) { Item[] temp = (Item[]) new Object[length]; for (int i = 0; i \u0026lt; size; i++) { temp[i] = array[i]; } array = temp; } @Override public Iterator\u0026lt;Item\u0026gt; iterator() { return new ReverseArrayIterator(); } private class ReverseArrayIterator implements Iterator\u0026lt;Item\u0026gt; { private int index = size; @Override public boolean hasNext() { return index \u0026gt; 0; } @Override public Item next() { return array[--index]; } } } æ ˆçš„é“¾è¡¨å®ç° import java.util.Iterator; public class Stack\u0026lt;Item\u0026gt; implements Iterable\u0026lt;Item\u0026gt; { private Node first; private int size; private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return size; } public void push(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; size++; } public Item pop() { Item item = first.item; first = first.next; size--; return item; } @Override public Iterator\u0026lt;Item\u0026gt; iterator() { return new ListIterator(); } private class ListIterator implements Iterator\u0026lt;Item\u0026gt; { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } } } æ ˆçš„åº”ç”¨ Dijkstra åŒæ ˆç®—æœ¯è¡¨è¾¾å¼æ±‚å€¼ç®—æ³•\npublic class Evaluate { public static void main(String[] args) { Stack\u0026lt;String\u0026gt; ops = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;Double\u0026gt; vals = new Stack\u0026lt;\u0026gt;(); while (!StdIn.isEmpty()) { String s = StdIn.readString(); switch (s) { case \u0026#34;(\u0026#34; -\u0026gt; { ; } case \u0026#34;+\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;/\u0026#34;, \u0026#34;sqrt\u0026#34; -\u0026gt; ops.push(s); case \u0026#34;)\u0026#34; -\u0026gt; { String op = ops.pop(); double v = vals.pop(); v = switch (op) { case \u0026#34;+\u0026#34; -\u0026gt; vals.pop() + v; case \u0026#34;-\u0026#34; -\u0026gt; vals.pop() - v; case \u0026#34;*\u0026#34; -\u0026gt; vals.pop() * v; case \u0026#34;/\u0026#34; -\u0026gt; vals.pop() / v; case \u0026#34;sqrt\u0026#34; -\u0026gt; Math.sqrt(v); default -\u0026gt; v; }; vals.push(v); } default -\u0026gt; vals.push(Double.parseDouble(s)); } } StdOut.println(vals.pop()); } } ","permalink":"https://fullzsy.github.io/posts/read/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_03_%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/","summary":"ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹èƒŒåŒ…ã€é˜Ÿåˆ—å’Œæ ˆ","title":"ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹èƒŒåŒ…ã€é˜Ÿåˆ—å’Œæ ˆ"},{"content":"ä¸€ä¸ªçº¿ç¨‹ä¸å®‰å…¨çš„ç°è±¡ ä¸€ä¸ªæ•°ç»„å®ç°çš„ç¯å½¢ç¼“å†²åŒºï¼Œå˜é‡ readPos å’Œ writePos åˆ†åˆ«è®°å½•ä¸‹ä¸€ä¸ªè¯»å–çš„ç´¢å¼•å’Œä¸‹ä¸€ä¸ªå†™å…¥çš„ç´¢å¼•ã€‚å½“ç¼“å†²åŒºä¸ºç©ºæ—¶ï¼Œæ¶ˆè´¹è€…ä¼šåœ¨æ•°æ®å­˜å…¥ç¼“å†²åŒºå‰ç­‰å¾…ã€‚å½“ç¼“å†²åŒºæ»¡æ—¶ï¼Œç”Ÿäº§è€…ä¼šç­‰å¾…å°†æ•°æ®å­˜å…¥ç¼“å†²åŒºã€‚\npublic class RingBuffer\u0026lt;Item\u0026gt; { private final Item[] buffer; private int readPos; private int writePos; RingBuffer(int capacity) { this.buffer = (Item[]) new Object[capacity]; this.readPos = 0; this.writePos = 0; } public void write(Item item) { while (isFull()) ; buffer[writePos] = item; writePos = (writePos + 1) % buffer.length; } public Item read() { while (isEmpty()) ; Item item = buffer[readPos]; readPos = (readPos + 1) % buffer.length; return item; } private boolean isEmpty() { return readPos == writePos; } private boolean isFull() { return ((writePos + 1) % buffer.length) == readPos; } public static void main(String[] args) { RingBuffer\u0026lt;Integer\u0026gt; ringBuffer = new RingBuffer\u0026lt;\u0026gt;(10); Thread writer1 = new Thread(() -\u0026gt; { for (int item = 0; item \u0026lt; Integer.MAX_VALUE; item++) { ringBuffer.write(item); } }); writer1.start(); while (true) { StdOut.println(ringBuffer.read()); } } } åœ¨è¿è¡Œæ­¤æµ‹è¯•ç”¨ä¾‹æ—¶å‘ç°ä¸¤ä¸ªçº¿ç¨‹éƒ½å®¹æ˜“è¿›å…¥æ­»å¾ªç¯ã€‚å†™å…¥çº¿ç¨‹ä¸€ç›´è®¤ä¸ºç¼“å†²åŒºæ˜¯æ»¡çš„ï¼Œæ¶ˆè´¹çº¿ç¨‹ä¸€ç›´è®¤ä¸ºç¼“å†²åŒºæ˜¯ç©ºçš„ã€‚ç»è¿‡æ’æŸ¥ï¼Œæ­¤ç°è±¡æ˜¯ readPos å’Œ writePos å˜é‡ä¸ä¸€è‡´å¯¼è‡´çš„ã€‚\nåœ¨å†™å…¥çº¿ç¨‹ä¸­ï¼ŒwritePos å˜é‡åªä¼šè¢«å†™å…¥çº¿ç¨‹ä¿®æ”¹ï¼Œå› æ­¤è¯¥å˜é‡å¯¹äºå†™å…¥çº¿ç¨‹æ¥è¯´å§‹ç»ˆæ˜¯æœ€æ–°å€¼ã€‚è€Œå†™å…¥çº¿ç¨‹è°ƒç”¨ isFull æ–¹æ³•çš„ readPos å˜é‡ä¼šè¢«è¯»å–çº¿ç¨‹ä¿®æ”¹ï¼Œå¯¼è‡´å†™å…¥çº¿ç¨‹ä¸­ readPos å˜é‡æ˜¯æ—§æ•°æ®ã€‚\nåœ¨è¯»å–çº¿ç¨‹ä¸­ï¼ŒreadPos å˜é‡åªä¼šè¢«è¯»å–çº¿ç¨‹ä¿®æ”¹ï¼Œå› æ­¤è¯¥å˜é‡å¯¹äºè¯»å–çº¿ç¨‹æ¥è¯´å§‹ç»ˆæ˜¯æœ€æ–°å€¼ã€‚è€Œè¯»å–çº¿ç¨‹è°ƒç”¨ isEmpty æ–¹æ³•çš„ writePos å˜é‡ä¼šè¢«å†™å…¥çº¿ç¨‹ä¿®æ”¹ï¼Œå¯¼è‡´è¯»å–çº¿ç¨‹ä¸­ writePos å˜é‡æ˜¯æ—§æ•°æ®ã€‚\nè§£å†³æ–¹æ¡ˆ å°† readPos å’Œ writePos æ”¹ä¸º volatile å˜é‡ï¼Œåœ¨è¿™ä¸ªåœºæ™¯ä¸­èƒ½å¤Ÿä¿è¯è¿™ä¸¤ä¸ªå˜é‡çš„çº¿ç¨‹å®‰å…¨ã€‚\né‚£ä¹ˆ volatile å˜é‡åœ¨æ­¤åœºæ™¯ä¸­æ˜¯å¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨çš„å‘¢ï¼Ÿ\nvolatile å˜é‡æœºåˆ¶ å¯è§è¡Œä¿è¯ å¯¹äºé volatile å˜é‡ï¼ŒJVM ä¸ä¼šä¿è¯çº¿ç¨‹ä¿®æ”¹å˜é‡ä¼šè¢«ç«‹å³ä» CPU ç¼“å­˜ä¸­å›å†™åˆ°ä¸»å†…å­˜ä¸­ã€‚ä½¿å¾—å¦ä¸€ä¸ªçº¿ç¨‹å¯èƒ½ä¼šä»ä¸»å†…å­˜è¯»å–åˆ°è¯¥å˜é‡çš„æ—§å€¼ã€‚\nå¯¹äº volatile å˜é‡ï¼ŒJVM ä¼šä¿è¯çº¿ç¨‹æ¯æ¬¡éƒ½ä¼šä»ä¸»å†…å­˜ä¸­è¯»å–è¯¥å˜é‡ã€‚å¹¶ä¸”å¯¹è¯¥å˜é‡çš„ä¿®æ”¹ä¼šè¢«ç«‹å³å›å†™åˆ°ä¸»å†…å­˜ã€‚æ­¤æ—¶å…¶ä½™æ‰€æœ‰çº¿ç¨‹éƒ½ä¼šçœ‹åˆ°è¯¥å˜é‡çš„æœ€æ–°å€¼ã€‚\nhappens-before ä¿è¯ happens-before ä¿è¯ä¼šå¯¹æŒ‡ä»¤é‡æ’åºè¿›è¡Œé™åˆ¶ã€‚\nå¯¹ volatile å˜é‡è¿›è¡Œå†™å…¥æ“ä½œä¹‹å‰çš„æ‰€æœ‰æŒ‡ä»¤ä¸ä¼šå› æŒ‡ä»¤é‡æ’åºå¯¼è‡´è¿™äº›æŒ‡ä»¤åœ¨å†™å…¥æ“ä½œçš„åé¢ï¼› å¯¹ volatile å˜é‡è¿›è¡Œè¯»å–æ“ä½œä¹‹åçš„æ‰€æœ‰æŒ‡ä»¤ä¸ä¼šå› æŒ‡ä»¤é‡æ’åºå¯¼è‡´è¿™äº›æŒ‡ä»¤åœ¨å†™å…¥æ“ä½œçš„ä¹‹å‰ã€‚ å³æœ¬åº”åœ¨ volatile å˜é‡è¯»å–ä¸å†™å…¥æ“ä½œä¹‹é—´çš„æŒ‡ä»¤ï¼Œä¸ä¼šå› ä¸ºæŒ‡ä»¤é‡æ’åºå¯¼è‡´è¿™äº›æŒ‡ä»¤åœ¨å˜é‡è¯»å–ä¸å†™å…¥æ“ä½œä¹‹å¤–ã€‚\nvolatile å˜é‡ä½•æ—¶æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Ÿ åœ¨ä»¥ä¸‹ä¸¤ä¸ªåœºæ™¯ï¼Œvolatile å˜é‡æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼š\nå½“åªæœ‰ä¸€ä¸ªçº¿ç¨‹å‘ volatile å˜é‡å†™å…¥ï¼Œå…¶ä½™å¤šä¸ªçº¿ç¨‹ä»…è¯»å–è¯¥å˜é‡æ—¶ï¼Œæ€»ä¼šè¯»å–æœ€æ–°çš„æ•°æ®ï¼Œæ­¤æ—¶æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼› å½“å¤šä¸ªçº¿ç¨‹å‘ volatile å˜é‡å†™å…¥å¹¶ä¸”å¯¹å˜é‡çš„æ“ä½œæ˜¯åŸå­æ“ä½œï¼ˆè¢«å†™å…¥çš„æ–°å€¼ä¸ä¾èµ–æ—§å€¼ï¼‰ï¼Œæ­¤æ—¶æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚ ä¸€ä¸ª volitile å˜é‡ä¾‹å­ public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } å‚è€ƒèµ„æ–™ Concurrency in Java: \u0026ldquo;synchronized\u0026rdquo; and \u0026ldquo;volatile\u0026rdquo; keywords\nVolatile Variables and Thread Safety\n","permalink":"https://fullzsy.github.io/posts/tech/volatile%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/","summary":"Volatileå˜é‡ä¸çº¿ç¨‹å®‰å…¨","title":"Volatileå˜é‡ä¸çº¿ç¨‹å®‰å…¨"},{"content":"ç°ç‰ˆæœ¬å­˜åœ¨çš„é—®é¢˜ ç›®å‰åœ¨ç”Ÿäº§ç¯å¢ƒä¸­éƒ¨ç½²çš„æ—§ç‰ˆæœ¬Rediså­˜åœ¨çš„é—®é¢˜ï¼š\nå¤§ key è¿‡æœŸåˆ é™¤å¼•å‘é›†ç¾¤èŠ‚ç‚¹é˜»å¡å¤±å»å“åº”ä¸å¯ç”¨ï¼› å†…å­˜ç¢ç‰‡é«˜ï¼Œå†…å­˜ä½¿ç”¨ç‡ä½ï¼› è¿ç»´æ—¶ï¼Œæ‰‹åŠ¨ä¸»ä»åˆ‡æ¢æ€»ä¼šäº§ç”Ÿå¤åˆ¶é£æš´é—®é¢˜ï¼Œä¸»ä»æ— æ³•åŒæ­¥ï¼› bgsave å†…å­˜æ¶ˆè€—è¾ƒé«˜ï¼Œæœ‰ OOM é£é™©ã€‚ æ¨è¿›ç‰ˆæœ¬å‡çº§ ç”±äºä»¥ä¸ŠåŸå› ï¼Œå¼€å§‹æ¨è¿› Redis ç‰ˆæœ¬å‡çº§ã€‚\nç‰ˆæœ¬å‡çº§å·¥ä½œæµç¨‹ï¼š\né€šè¿‡æ–‡æ¡£ä¸æºç ï¼Œè°ƒç ” Redis æ–°ç‰¹æ€§ï¼› å®¢æˆ·ç«¯å…¼å®¹æ€§æ”¹é€ ï¼› åŠŸèƒ½æµ‹è¯•ã€æ€§èƒ½æµ‹è¯•å’Œç¨³å®šæ€§æµ‹è¯•ï¼› å¼€å‘é…å¥—ç›‘æ§å’Œè¿ç»´å·¥å…·ï¼› æ¨è¿›ä¸Šçº¿ã€‚ ","permalink":"https://fullzsy.github.io/posts/tech/redis%E5%8D%87%E7%BA%A7_0_%E5%BC%80%E7%AF%87/","summary":"è®°å½•Rediså‡çº§æµç¨‹ã€‚","title":"Rediså‡çº§â€”â€”å¼€ç¯‡"},{"content":"è‡ª Redis 4 ç‰ˆæœ¬å¼•å…¥äº†å¼‚æ­¥åˆ é™¤æ–¹æ³• unlinkï¼Œå®˜æ–¹å¯¹è¯¥æ¥å£çš„è§£é‡Šï¼š\nâ€œThis command is very similar to DEL: it removes the specified keys. Just like DEL a key is ignored if it does not exist. However the command performs the actual memory reclaiming in a different thread, so it is not blocking, while DEL is. This is where the command name comes from: the command just unlinks the keys from the keyspace. The actual removal will happen later asynchronously.â€\nå¯çŸ¥ unlink ä¸ del ç”¨æ³•ç›¸åŒï¼Œåªä¸è¿‡å†…å­˜å›æ”¶åœ¨å¦ä¸€ä¸ªä¸åŒçº¿ç¨‹ä¸­ï¼Œå†…å­˜å›æ”¶æ“ä½œåœ¨ unlink æ–¹æ³•è°ƒç”¨ç»“æŸä¹‹åï¼Œå› æ­¤æ˜¯éé˜»å¡æ–¹æ³•ã€‚\næºç åˆ†æ å¼‚æ­¥åˆ é™¤æµç¨‹ åŒæ­¥åˆ é™¤ä¸å¼‚æ­¥åˆ é™¤çš„æ–¹æ³•å…¥å£åˆ†åˆ«ä¸º delCommand æ–¹æ³•ä¸ unlinkCommand æ–¹æ³•ã€‚\nvoid delCommand(client *c) { delGenericCommand(c,server.lazyfree_lazy_user_del); } void unlinkCommand(client *c) { delGenericCommand(c,1); } è¿™ä¸¤ä¸ªæ–¹æ³•éƒ½è°ƒç”¨ delGenericCommand æ–¹æ³•ï¼Œserver.lazyfree_lazy_user_del å¯é€šè¿‡é…ç½®æ–‡ä»¶é…ç½®ï¼Œé…ç½®åå¯ä»¥ä½¿ del å‘½ä»¤ä¸ unlink å‘½ä»¤å®Œå…¨ç›¸åŒã€‚\n/* This command implements DEL and LAZYDEL. */ void delGenericCommand(client *c, int lazy) { int numdel = 0, j; for (j = 1; j \u0026lt; c-\u0026gt;argc; j++) { expireIfNeeded(c-\u0026gt;db,c-\u0026gt;argv[j],0); // åˆ¤æ–­ä¼ å…¥çš„ lazy å€¼é€‰æ‹©å¼‚æ­¥åˆ é™¤æˆ–åŒæ­¥åˆ é™¤ int deleted = lazy ? dbAsyncDelete(c-\u0026gt;db,c-\u0026gt;argv[j]) : dbSyncDelete(c-\u0026gt;db,c-\u0026gt;argv[j]); if (deleted) { signalModifiedKey(c,c-\u0026gt;db,c-\u0026gt;argv[j]); notifyKeyspaceEvent(NOTIFY_GENERIC, \u0026#34;del\u0026#34;,c-\u0026gt;argv[j],c-\u0026gt;db-\u0026gt;id); server.dirty++; numdel++; } } addReplyLongLong(c,numdel); } delGenericCommand æ–¹æ³•åˆ¤æ–­ä¼ å…¥çš„ lazy å‚æ•°å€¼å†³å®šå¼‚æ­¥åˆ é™¤æˆ–è€…åŒæ­¥åˆ é™¤ã€‚\n/* Delete a key, value, and associated expiration entry if any, from the DB */ int dbSyncDelete(redisDb *db, robj *key) { return dbGenericDelete(db, key, 0); } /* Delete a key, value, and associated expiration entry if any, from the DB. If * the value consists of many allocations, it may be freed asynchronously. */ int dbAsyncDelete(redisDb *db, robj *key) { return dbGenericDelete(db, key, 1); } åŒæ­¥åˆ é™¤å’Œå¼‚æ­¥åˆ é™¤éƒ½æ˜¯è°ƒç”¨ dbGenericDelete æ–¹æ³•ï¼Œä»…ä¼ å…¥çš„ async å‚æ•°ä¸åŒã€‚\n/* Helper for sync and async delete. */ static int dbGenericDelete(redisDb *db, robj *key, int async) { /* Deleting an entry from the expires dict will not free the sds of * the key, because it is shared with the main dictionary. */ // åˆ é™¤ expires å­—å…¸ä¸­è¯¥ keyï¼Œä½†ä¸ä¼šåˆ é™¤ SDS ç»“æ„ï¼Œå› ä¸ºè¯¥ SDS åœ¨ dict å­—å…¸ä¸­è¢«å…±äº«ã€‚ if (dictSize(db-\u0026gt;expires) \u0026gt; 0) dictDelete(db-\u0026gt;expires,key-\u0026gt;ptr); // æ•°æ®åº“å­—å…¸ä¸­ç§»é™¤ keyï¼Œä¸é‡Šæ”¾å†…å­˜ã€‚ dictEntry *de = dictUnlink(db-\u0026gt;dict,key-\u0026gt;ptr); if (de) { robj *val = dictGetVal(de); /* Tells the module that the key has been unlinked from the database. */ moduleNotifyKeyUnlink(key,val,db-\u0026gt;id); /* We want to try to unblock any client using a blocking XREADGROUP */ if (val-\u0026gt;type == OBJ_STREAM) signalKeyAsReady(db,key,val-\u0026gt;type); if (async) { // å¼‚æ­¥é‡Šæ”¾å†…å­˜ freeObjAsync(key, val, db-\u0026gt;id); dictSetVal(db-\u0026gt;dict, de, NULL); } if (server.cluster_enabled) slotToKeyDelEntry(de, db); // é‡Šæ”¾å†…å­˜ dictFreeUnlinkedEntry(db-\u0026gt;dict,de); return 1; } else { return 0; } } /* You need to call this function to really free the entry after a call * to dictUnlink(). It\u0026#39;s safe to call this function with \u0026#39;he\u0026#39; = NULL. */ void dictFreeUnlinkedEntry(dict *d, dictEntry *he) { if (he == NULL) return; dictFreeKey(d, he); dictFreeVal(d, he); zfree(he); } dbGenericDelete æ–¹æ³•é¦–å…ˆå°† key åœ¨ expires å­—å…¸ä¸­åˆ é™¤å¹¶é‡Šæ”¾å†…å­˜ï¼Œå†åœ¨ dict å­—å…¸ä¸­ç§»é™¤è¯¥ keyï¼Œä½†æ­¤æ—¶ä¸é‡Šæ”¾å†…å­˜ã€‚ é€šè¿‡ async å‚æ•°åˆ¤æ–­æ˜¯å¦éœ€è¦å¼‚æ­¥é‡Šæ”¾å†…å­˜ï¼Œè‹¥éœ€è¦åˆ™ä¼šè°ƒç”¨ freeObjAsync æ–¹æ³•è¿›è¡Œå¼‚æ­¥é‡Šæ”¾å†…å­˜ï¼Œè‹¥ä¸éœ€è¦å¼‚æ­¥é‡Šæ”¾å†…å­˜ï¼Œåˆ™åœ¨ dictFreeUnlinkedEntry æ–¹æ³•ä¸­ç›´æ¥é‡Šæ”¾ã€‚ è‹¥è¿›å…¥ freeObjAsync æ–¹æ³•ä½†ä¸æ»¡è¶³å¼‚æ­¥é‡Šæ”¾æ¡ä»¶ï¼ˆåœ¨ freeObjAsync æ–¹æ³•ä¸­ï¼‰ï¼Œä¹Ÿä¼šåœ¨ dictFreeUnlinkedEntry æ–¹æ³•ä¸­ç›´æ¥é‡Šæ”¾ã€‚\n/* If there are enough allocations to free the value object asynchronously, it * may be put into a lazy free list instead of being freed synchronously. The * lazy free list will be reclaimed in a different bio.c thread. If the value is * composed of a few allocations, to free in a lazy way is actually just * slower... So under a certain limit we just free the object synchronously. */ #define LAZYFREE_THRESHOLD 64 /* Free an object, if the object is huge enough, free it in async way. */ void freeObjAsync(robj *key, robj *obj, int dbid) { // è®¡ç®—å¼‚æ­¥åˆ é™¤é˜ˆå€¼ size_t free_effort = lazyfreeGetFreeEffort(key,obj,dbid); /* Note that if the object is shared, to reclaim it now it is not * possible. This rarely happens, however sometimes the implementation * of parts of the Redis core may call incrRefCount() to protect * objects, and then call dbDelete(). */ if (free_effort \u0026gt; LAZYFREE_THRESHOLD \u0026amp;\u0026amp; obj-\u0026gt;refcount == 1) { atomicIncr(lazyfree_objects,1); // ä»»åŠ¡è¶…è¿‡å¼‚æ­¥åˆ é™¤é˜ˆå€¼ï¼Œåˆ›å»ºå¼‚æ­¥åˆ é™¤ä»»åŠ¡ bioCreateLazyFreeJob(lazyfreeFreeObject,1,obj); } else { decrRefCount(obj); } } é‡ç‚¹çœ‹ freeObjAsync æ–¹æ³•ï¼Œå…ˆè®¡ç®—è¯¥ key çš„å¼‚æ­¥åˆ é™¤é˜ˆå€¼ï¼Œè‹¥å¤§äºé˜ˆå€¼ 64ï¼Œåˆ™ä¸ºè¯¥ key åˆ›å»ºå¼‚æ­¥åˆ é™¤ä»»åŠ¡ã€‚\nvoid bioCreateLazyFreeJob(lazy_free_fn free_fn, int arg_count, ...) { va_list valist; /* Allocate memory for the job structure and all required * arguments */ bio_job *job = zmalloc(sizeof(*job) + sizeof(void *) * (arg_count)); job-\u0026gt;free_args.free_fn = free_fn; va_start(valist, arg_count); for (int i = 0; i \u0026lt; arg_count; i++) { job-\u0026gt;free_args.free_args[i] = va_arg(valist, void *); } va_end(valist); // æäº¤ä»»åŠ¡ bioSubmitJob(BIO_LAZY_FREE, job); } void bioSubmitJob(int type, bio_job *job) { // äº’æ–¥é” pthread_mutex_lock(\u0026amp;bio_mutex[type]); // æ·»åŠ ä»»åŠ¡è‡³æœ«å°¾ listAddNodeTail(bio_jobs[type],job); bio_pending[type]++; // å‘é€ä¿¡å·å”¤é†’é˜»å¡çº¿ç¨‹ pthread_cond_signal(\u0026amp;bio_newjob_cond[type]); pthread_mutex_unlock(\u0026amp;bio_mutex[type]); } bioCreateLazyFreeJob æ–¹æ³•åˆ›å»ºä»»åŠ¡å¹¶è°ƒç”¨ bioSubmitJob æ–¹æ³•æäº¤ä»»åŠ¡åˆ° job æ•°æ®ç»“æ„ä¸­ã€‚\nvoid *bioProcessBackgroundJobs(void *arg) { bio_job *job; unsigned long type = (unsigned long) arg; sigset_t sigset; /* Check that the type is within the right interval. */ if (type \u0026gt;= BIO_NUM_OPS) { serverLog(LL_WARNING, \u0026#34;Warning: bio thread started with wrong type %lu\u0026#34;,type); return NULL; } switch (type) { case BIO_CLOSE_FILE: redis_set_thread_title(\u0026#34;bio_close_file\u0026#34;); break; case BIO_AOF_FSYNC: redis_set_thread_title(\u0026#34;bio_aof_fsync\u0026#34;); break; case BIO_LAZY_FREE: redis_set_thread_title(\u0026#34;bio_lazy_free\u0026#34;); break; } redisSetCpuAffinity(server.bio_cpulist); makeThreadKillable(); pthread_mutex_lock(\u0026amp;bio_mutex[type]); /* Block SIGALRM so we are sure that only the main thread will * receive the watchdog signal. */ sigemptyset(\u0026amp;sigset); sigaddset(\u0026amp;sigset, SIGALRM); if (pthread_sigmask(SIG_BLOCK, \u0026amp;sigset, NULL)) serverLog(LL_WARNING, \u0026#34;Warning: can\u0026#39;t mask SIGALRM in bio.c thread: %s\u0026#34;, strerror(errno)); while(1) { listNode *ln; /* The loop always starts with the lock hold. */ if (listLength(bio_jobs[type]) == 0) { pthread_cond_wait(\u0026amp;bio_newjob_cond[type],\u0026amp;bio_mutex[type]); continue; } /* Pop the job from the queue. */ ln = listFirst(bio_jobs[type]); job = ln-\u0026gt;value; /* It is now possible to unlock the background system as we know have * a stand alone job structure to process.*/ pthread_mutex_unlock(\u0026amp;bio_mutex[type]); /* Process the job accordingly to its type. */ if (type == BIO_CLOSE_FILE) { if (job-\u0026gt;fd_args.need_fsync) { redis_fsync(job-\u0026gt;fd_args.fd); } close(job-\u0026gt;fd_args.fd); } else if (type == BIO_AOF_FSYNC) { /* The fd may be closed by main thread and reused for another * socket, pipe, or file. We just ignore these errno because * aof fsync did not really fail. */ if (redis_fsync(job-\u0026gt;fd_args.fd) == -1 \u0026amp;\u0026amp; errno != EBADF \u0026amp;\u0026amp; errno != EINVAL) { int last_status; atomicGet(server.aof_bio_fsync_status,last_status); atomicSet(server.aof_bio_fsync_status,C_ERR); atomicSet(server.aof_bio_fsync_errno,errno); if (last_status == C_OK) { serverLog(LL_WARNING, \u0026#34;Fail to fsync the AOF file: %s\u0026#34;,strerror(errno)); } } else { atomicSet(server.aof_bio_fsync_status,C_OK); } } else if (type == BIO_LAZY_FREE) { job-\u0026gt;free_args.free_fn(job-\u0026gt;free_args.free_args); } else { serverPanic(\u0026#34;Wrong job type in bioProcessBackgroundJobs().\u0026#34;); } zfree(job); /* Lock again before reiterating the loop, if there are no longer * jobs to process we\u0026#39;ll block again in pthread_cond_wait(). */ pthread_mutex_lock(\u0026amp;bio_mutex[type]); listDelNode(bio_jobs[type],ln); bio_pending[type]--; /* Unblock threads blocked on bioWaitStepOfType() if any. */ pthread_cond_broadcast(\u0026amp;bio_step_cond[type]); } } æ‰§è¡Œåå°ä»»åŠ¡æ–¹æ³• bioProcessBackgroundJobsï¼Œè¯¦ç»†è¿‡ç¨‹ä¸åœ¨è®¨è®ºçš„ä¸»é¢˜ä¸­ã€‚\nç»“è®ºï¼šå¼‚æ­¥åˆ é™¤èƒ½å¤Ÿè§£å†³ä¸»çº¿ç¨‹é˜»å¡é—®é¢˜ã€‚\næƒ°æ€§åˆ é™¤ä¸å¼‚æ­¥åˆ é™¤ Redis æƒ°æ€§åˆ é™¤ç­–ç•¥æ˜¯å¦é‡‡ç”¨å¼‚æ­¥åˆ é™¤ç­–ç•¥ï¼Ÿ\nåœ¨æƒ°æ€§åˆ é™¤ä¸­ï¼ŒRedis åœ¨æ“ä½œ Key æ—¶ä¼šå…ˆåˆ¤æ–­è¯¥ Key æ˜¯å¦è¿‡æœŸï¼Œè‹¥è¿‡æœŸåˆ™ä¼šåˆ é™¤è¯¥ Keyã€‚\n/* This function is called when we are going to perform some operation * in a given key, but such key may be already logically expired even if * it still exists in the database. The main way this function is called * is via lookupKey*() family of functions. * * The behavior of the function depends on the replication role of the * instance, because by default replicas do not delete expired keys. They * wait for DELs from the master for consistency matters. However even * replicas will try to have a coherent return value for the function, * so that read commands executed in the replica side will be able to * behave like if the key is expired even if still present (because the * master has yet to propagate the DEL). * * In masters as a side effect of finding a key which is expired, such * key will be evicted from the database. Also this may trigger the * propagation of a DEL/UNLINK command in AOF / replication stream. * * On replicas, this function does not delete expired keys by default, but * it still returns 1 if the key is logically expired. To force deletion * of logically expired keys even on replicas, use the EXPIRE_FORCE_DELETE_EXPIRED * flag. Note though that if the current client is executing * replicated commands from the master, keys are never considered expired. * * On the other hand, if you just want expiration check, but need to avoid * the actual key deletion and propagation of the deletion, use the * EXPIRE_AVOID_DELETE_EXPIRED flag. * * The return value of the function is 0 if the key is still valid, * otherwise the function returns 1 if the key is expired. */ int expireIfNeeded(redisDb *db, robj *key, int flags) { if (!keyIsExpired(db,key)) return 0; /* If we are running in the context of a replica, instead of * evicting the expired key from the database, we return ASAP: * the replica key expiration is controlled by the master that will * send us synthesized DEL operations for expired keys. The * exception is when write operations are performed on writable * replicas. * * Still we try to return the right information to the caller, * that is, 0 if we think the key should be still valid, 1 if * we think the key is expired at this time. * * When replicating commands from the master, keys are never considered * expired. */ if (server.masterhost != NULL) { if (server.current_client == server.master) return 0; if (!(flags \u0026amp; EXPIRE_FORCE_DELETE_EXPIRED)) return 1; } /* In some cases we\u0026#39;re explicitly instructed to return an indication of a * missing key without actually deleting it, even on masters. */ if (flags \u0026amp; EXPIRE_AVOID_DELETE_EXPIRED) return 1; /* If clients are paused, we keep the current dataset constant, * but return to the client what we believe is the right state. Typically, * at the end of the pause we will properly expire the key OR we will * have failed over and the new primary will send us the expire. */ if (checkClientPauseTimeoutAndReturnIfPaused()) return 1; /* Delete the key */ // åˆ é™¤ key deleteExpiredKeyAndPropagate(db,key); return 1; } expireIfNeeded æ–¹æ³•ä¼šè°ƒç”¨ deleteExpiredKeyAndPropagate æ–¹æ³•åˆ é™¤ keyã€‚\nåˆ é™¤ key æ—¶ä¼šè¯»å– server.lazyfree_lazy_expire é…ç½®å†³å®šåˆ é™¤ç­–ç•¥ã€‚server.lazyfree_lazy_expire å¯åœ¨é…ç½®æ–‡ä»¶ä¸­é…ç½®ï¼Œé…ç½®åæƒ°æ€§åˆ é™¤å°†é‡‡ç”¨å¼‚æ­¥åˆ é™¤ç­–ç•¥ã€‚\n/* Delete the specified expired key and propagate expire. */ void deleteExpiredKeyAndPropagate(redisDb *db, robj *keyobj) { mstime_t expire_latency; latencyStartMonitor(expire_latency); if (server.lazyfree_lazy_expire) // é‡‡ç”¨å¼‚æ­¥åˆ é™¤ç­–ç•¥ dbAsyncDelete(db,keyobj); else dbSyncDelete(db,keyobj); latencyEndMonitor(expire_latency); latencyAddSampleIfNeeded(\u0026#34;expire-del\u0026#34;,expire_latency); notifyKeyspaceEvent(NOTIFY_EXPIRED,\u0026#34;expired\u0026#34;,keyobj,db-\u0026gt;id); signalModifiedKey(NULL, db, keyobj); propagateDeletion(db,keyobj,server.lazyfree_lazy_expire); server.stat_expiredkeys++; } ç»“è®ºï¼šRedis æƒ°æ€§åˆ é™¤åœ¨é…ç½®åå¯é‡‡ç”¨å¼‚æ­¥åˆ é™¤ç­–ç•¥ã€‚\nå®šæ—¶åˆ é™¤ä¸å¼‚æ­¥åˆ é™¤ å®šæ—¶ä»»åŠ¡ serverCron æ–¹æ³•æœ€ç»ˆä¼šè°ƒç”¨ activeExpireCycleTryExpire æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä»ä¼šè°ƒç”¨ deleteExpiredKeyAndPropagate æ–¹æ³•ã€‚\n/* Helper function for the activeExpireCycle() function. * This function will try to expire the key that is stored in the hash table * entry \u0026#39;de\u0026#39; of the \u0026#39;expires\u0026#39; hash table of a Redis database. * * If the key is found to be expired, it is removed from the database and * 1 is returned. Otherwise no operation is performed and 0 is returned. * * When a key is expired, server.stat_expiredkeys is incremented. * * The parameter \u0026#39;now\u0026#39; is the current time in milliseconds as is passed * to the function to avoid too many gettimeofday() syscalls. */ int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) { long long t = dictGetSignedIntegerVal(de); if (now \u0026gt; t) { sds key = dictGetKey(de); robj *keyobj = createStringObject(key,sdslen(key)); // åˆ é™¤ key deleteExpiredKeyAndPropagate(db,keyobj); decrRefCount(keyobj); return 1; } else { return 0; } } ç»“è®ºï¼šRedis å®šæ—¶åˆ é™¤åœ¨é…ç½®åå¯é‡‡ç”¨å¼‚æ­¥åˆ é™¤ç­–ç•¥ã€‚\nç»“è®º å¼‚æ­¥åˆ é™¤ç­–ç•¥èƒ½å¤Ÿåœ¨åˆ é™¤å¤§ Key æ—¶é¿å…ä¸»çº¿ç¨‹é˜»å¡ï¼Œæƒ°æ€§åˆ é™¤ä¸å®šæ—¶åˆ é™¤åœ¨é…ç½®åå‡å¯é‡‡ç”¨å¼‚æ­¥åˆ é™¤ç­–ç•¥ï¼Œå› æ­¤å¼‚æ­¥åˆ é™¤èƒ½å¤Ÿè§£å†³å¤§ Key è¿‡æœŸå¼•èµ·çš„ä¸»çº¿ç¨‹é˜»å¡é—®é¢˜ã€‚\n","permalink":"https://fullzsy.github.io/posts/tech/redis%E5%8D%87%E7%BA%A7_1_%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4/","summary":"é€šè¿‡åˆ†æ Redis å¼‚æ­¥åˆ é™¤æºç ï¼Œåˆ¤æ–­å¼‚æ­¥åˆ é™¤èƒ½å¦è§£å†³å¤§ Key è¿‡æœŸé˜»å¡ä¸»çº¿ç¨‹çš„é—®é¢˜ã€‚","title":"Rediså¼‚æ­¥åˆ é™¤è§£å†³å¤§Keyè¿‡æœŸé˜»å¡é—®é¢˜å¯è¡Œæ€§åˆ†æ"},{"content":"å‰ææ¡ä»¶ æŸ¥æ‰¾çš„æ•°ç»„æ˜¯æœ‰åºçš„ã€‚\né€’å½’å†™æ³• public class BinarySearch { public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1); } public static int rank(int key, int[] a, int lo, int hi) { if (lo \u0026gt; hi) return -1; int mid = lo + (hi - lo) / 2; if (key \u0026lt; a[mid]) return rank(key, a, lo, hi - 1); else if (key \u0026gt; a[mid]) return rank(key, a, lo + 1, hi); else return mid; } } å¾ªç¯å†™æ³• public class BinarySearch { public static int rank(int key, int[] a) { int lo = 0; int hi = a.length - 1; while (lo \u0026lt; hi) { int mid = lo + (hi - lo) / 2; if (key \u0026lt; a[mid]) hi = lo - 1; else if (key \u0026gt; a[mid]) lo = hi + 1; else return mid; } return -1; } } äºŒåˆ†æŸ¥æ‰¾ key çš„æœ€å°ç´¢å¼• public class BinarySearch { public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1); } public static int rank(int[] array, int key, int lo, int hi) { while (lo \u0026lt;= hi) { int mid = lo + ((hi - lo) \u0026gt;\u0026gt; 1); if (key \u0026lt;= array[mid]) { hi = mid - 1; } else { lo = mid + 1; } } if (lo == array.length) return -1; return array[lo] == key ? lo : -1; } } äºŒåˆ†æŸ¥æ‰¾æå°(å¤§)å€¼ public class BinarySearch { public static int partialMin(int[] array) { assert array != null \u0026amp;\u0026amp; array.length \u0026gt; 0; int lo = 0; int hi = array.length - 1; while (lo \u0026lt;= hi) { int mid = lo + ((hi - lo) \u0026gt;\u0026gt; 1); if (mid == 0 || mid == array.length - 1) break; if (array[mid] \u0026lt; array[mid - 1] \u0026amp;\u0026amp; array[mid] \u0026lt; array[mid + 1]) { return mid; } else if (array[mid - 1] \u0026lt;= array[mid + 1]) { hi = mid - 1; } else { lo = mid + 1; } } return -1; } } ","permalink":"https://fullzsy.github.io/posts/read/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","summary":"ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹äºŒåˆ†æŸ¥æ‰¾","title":"ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹äºŒåˆ†æŸ¥æ‰¾"},{"content":"è‡ªç„¶è¯­è¨€æè¿° è®¡ç®—ä¸¤ä¸ªéè´Ÿæ•´æ•° p å’Œ q çš„æœ€å¤§å…¬çº¦æ•°ï¼šè‹¥ q æ˜¯ 0ï¼Œåˆ™æœ€å¤§å…¬çº¦æ•°ä¸º pã€‚å¦åˆ™ï¼Œå°† p é™¤ä»¥ q å¾—åˆ°ä½™æ•° rï¼Œp å’Œ q çš„æœ€å¤§å…¬çº¦æ•°å³ä¸º q å’Œ r çš„æœ€å¤§å…¬çº¦æ•°ã€‚\né€’å½’å†™æ³• public class Euclid { public static int gcd(int p, int q) { if (q == 0) return p; int r = p % q; return gcd(q, r); } } å¾ªç¯å†™æ³• public class Euclid { public static int gcd(int p, int q) { if (q == 0) return p; while (q != 0) { int r = p % q; p = q; q = r; } return p; } } ","permalink":"https://fullzsy.github.io/posts/read/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_02_%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/","summary":"ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚æœ€å¤§å…¬å› æ•°","title":"ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚æœ€å¤§å…¬å› æ•°"},{"content":"æœ¬ç³»åˆ—æ–‡ç« ä½œç”¨ 2023 å¹´è®¡åˆ’å°†ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹è®¤çœŸé˜…è¯»ä¸€éï¼Œåœ¨åšå®¢ä¸­æ•´ç†å¸¸ç”¨çš„ç®—æ³•ï¼ŒæŠŠä¹¦è¯»è–„ï¼Œæ—¶å¸¸å¤ä¹ ï¼Œæé«˜ç¼–ç æ°´å¹³ã€‚\nä¹ é¢˜ä»“åº“ï¼šhttps://github.com/FullZSY/algs4\nåŠ æ²¹ï¼\n","permalink":"https://fullzsy.github.io/posts/read/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88_00_%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/","summary":"ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹é˜…è¯»æ€»ç»“","title":"ã€Šç®—æ³•ç¬¬å››ç‰ˆã€‹é˜…è¯»"},{"content":"å…³äºæˆ‘ å§“å: Shuyang èŒä¸š: åç«¯ç¨‹åºå‘˜ï¼Œè´Ÿè´£ Redis ç›¸å…³å·¥ä½œ ","permalink":"https://fullzsy.github.io/about/","summary":"å…³äºæˆ‘ å§“å: Shuyang èŒä¸š: åç«¯ç¨‹åºå‘˜ï¼Œè´Ÿè´£ Redis ç›¸å…³å·¥ä½œ ","title":"ğŸ™‹ğŸ»â€â™‚ï¸å…³äº"}]